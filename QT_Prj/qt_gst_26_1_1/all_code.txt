
========== ./main.cpp ==========
Lines: 36

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <variant>

#ifdef slots
#undef slots
#endif
#ifdef signals
#undef signals
#endif

#include <QApplication>
#include "widget.h"
#include "LoginWidget.h"
#include "AppWindow.h"

// #include "widget.h"
// #include "LoginWidget.h"
// #include <QApplication>
// #include "AppWindow.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    qRegisterMetaType<Frame>("Frame");
    AppWindow w;
    //LoginWidget login_W;
    //login_W.show();
    w.show();
    return a.exec();
}

========== ./core/ClientCore.cpp ==========
Lines: 105

#include "ClientCore.h"

// 构造函数：初始化 Executor，设置回调
ClientCore::ClientCore() : fsm_() {
    // 初始化 Executor：回调函数用于接收 Executor 推送的 CoreInput
    executor_ = std::make_unique<CoreExecutor>(
        [this](core::CoreInput ev) {
            this->postInput(std::move(ev)); // 将 Executor 的事件推入输入队列
        }
        );

    // 启动事件处理线程（仅调度，无 IO）
    std::thread([this]{ processEvents(); }).detach();
}

ClientCore::~ClientCore() {
    // 释放 Executor 资源
    if (executor_) {
        executor_->stop();
    }
}

// 原 postInput/pollOutput 逻辑不变（补充 core:: 前缀）
void ClientCore::postInput(core::CoreInput ev) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        inputQueue_.push(std::move(ev));
    }
    cv_.notify_one();
}

bool ClientCore::pollOutput(core::CoreOutput& out) { // 补充 core:: 前缀
    std::lock_guard<std::mutex> lock(mtx_);
    if (outputQueue_.empty()) return false;
    out = std::move(outputQueue_.front());
    outputQueue_.pop();
    return true;
}

// 原 processEvents 逻辑不变（补充 core:: 前缀）
void ClientCore::processEvents() {
    while (true) {
        core::CoreInput ev;
        {
            std::unique_lock<std::mutex> lock(mtx_);
            cv_.wait(lock, [this]{ return !inputQueue_.empty(); });
            ev = std::move(inputQueue_.front());
            inputQueue_.pop();
        }

        auto outputs = fsm_.handle(state_, ev);
        {
            std::lock_guard<std::mutex> lock(mtx_);
            for (auto& o : outputs) {
                handleOutput(std::move(o));
            }
        }
    }
}

// 原 handleOutput/applyStateChange 逻辑不变（补充 core:: 前缀）
void ClientCore::handleOutput(core::CoreOutput&& o) { // 补充 core:: 前缀
    std::visit([this](auto&& e){
        using T = std::decay_t<decltype(e)>;

        if constexpr (std::is_same_v<T, core::OutStateChanged>) { // 补充 core:: 前缀
            applyStateChange(e);
        }
        else if constexpr (std::is_same_v<T, core::OutConnect>) { // 补充 core:: 前缀
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendLogin>) { // 补充 core:: 前缀
            execute(e);
        }
        else {
            outputQueue_.push(std::move(e));
        }
    }, std::move(o));
}

void ClientCore::applyStateChange(const core::OutStateChanged& e) { // 补充 core:: 前缀
    std::cout << "[Core] State: "
              << stateToString(e.from)
              << " -> "
              << stateToString(e.to)
              << std::endl;

    state_ = e.to;
    outputQueue_.push(e);
}

// 关键修改：execute 仅调用 Executor 接口，无 IO 逻辑（补充 core:: 前缀）
void ClientCore::execute(const core::OutConnect& e) { // 补充 core:: 前缀
    // 调度 Executor 执行连接（Core 仅发命令，不做具体操作）
    executor_->connectToServer(e.host, e.port);
}

void ClientCore::execute(const core::OutSendLogin& e) { // 补充 core:: 前缀
    // 调度 Executor 发送登录请求
    executor_->sendLoginRequest(e.user, e.pass);
}

// 废弃原 socket 操作接口（可直接删除）
// bool ClientCore::connectToServer(const std::string& host, int port) { ... }
// void ClientCore::sendLogin(const std::string& user, const std::string& pass) { ... }

========== ./core/FSM.h ==========
Lines: 35

// core/FSM.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "ClientState.h"
#include <vector>
#include <functional>
#include "ClientEventEnum.h"
#include <variant>
#include <iostream>

struct FSMEntry {
    State current_state;
    EventType event_type;
    // 补充 core:: 前缀
    std::function<std::vector<core::CoreOutput>(
        State current,
        const core::CoreInput&
        )> action;
    State next_state;
};

class FSM {
public:
    FSM();

    // 补充 core:: 前缀
    std::vector<core::CoreOutput>
    handle(State current, const core::CoreInput& ev);

private:
    EventType eventTypeFromInput(const core::CoreInput& ev);
    std::vector<FSMEntry> table_;
    void initTable();
};

========== ./core/CoreInput.h ==========
Lines: 29

// core/CoreInput.h
#pragma once
#include <variant>
#include <string>
namespace core {

// 所有 Core 输入事件前缀改为 In
struct InCmdConnect { std::string host; int port; };
struct InCmdDisconnect {};
struct InCmdLogin { std::string user; std::string pass; };
struct InTcpConnected {};
struct InTcpDisconnected {};
struct InLoginOk {};
struct InLoginFail { std::string msg; };
struct InOnlineUsers { std::string list; };
struct InUnknow {};

using CoreInput = std::variant<
    InCmdConnect,
    InCmdDisconnect,
    InCmdLogin,
    InTcpConnected,
    InTcpDisconnected,
    InLoginOk,
    InLoginFail,
    InOnlineUsers,
    InUnknow
    >;
}

========== ./core/FSM.cpp ==========
Lines: 159

// core/FSM.cpp
#include "FSM.h"

FSM::FSM() {
    initTable();
}

// 补充 core:: 前缀
std::vector<core::CoreOutput>
FSM::handle(State current, const core::CoreInput& ev)
{
    EventType evType = eventTypeFromInput(ev);

    for (auto& entry : table_) {
        if (entry.current_state == current &&
            entry.event_type == evType) {

            auto outputs = entry.action(current, ev);
            return outputs;
        }
    }
    return {};
}

EventType FSM::eventTypeFromInput(const core::CoreInput& ev) {
    EventType evType = EventType::Unknow;
    std::visit([&evType](auto&& e){
        using T = std::decay_t<decltype(e)>;
        // 全部替换为 InXXX 前缀
        if constexpr (std::is_same_v<T, core::InCmdConnect>)      evType = EventType::CmdConnect;
        else if constexpr (std::is_same_v<T, core::InCmdDisconnect>) evType = EventType::CmdDisconnect;
        else if constexpr (std::is_same_v<T, core::InCmdLogin>)   evType = EventType::CmdLogin;

        else if constexpr (std::is_same_v<T, core::InTcpConnected>)    evType = EventType::TcpConnected;
        else if constexpr (std::is_same_v<T, core::InTcpDisconnected>) evType = EventType::TcpDisconnected;

        else if constexpr (std::is_same_v<T, core::InLoginOk>)   evType = EventType::LoginOk;
        else if constexpr (std::is_same_v<T, core::InLoginFail>) evType = EventType::LoginFail;
        else if constexpr (std::is_same_v<T, core::InOnlineUsers>) evType = EventType::OnlineUsers;

        else evType = EventType::Unknow;
    }, ev);
    return evType;
}

void FSM::initTable() {
    table_ = {
              // ===== 断开态 =====
              { State::Disconnected, EventType::CmdConnect,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                      std::vector<core::CoreOutput> out;
                      // 替换为 InCmdConnect
                      if (auto e = std::get_if<core::InCmdConnect>(&ev)) {
                          out.push_back(core::OutStateChanged{cur, State::Connecting}); // 补充 core::
                          out.push_back(core::OutConnect{e->host, e->port}); // 补充 core::
                      }
                      return out;
                  },
                  State::Connecting
              },

              // ===== 正在连接 =====
              { State::Connecting, EventType::TcpConnected,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                      std::vector<core::CoreOutput> out;
                      // 替换为 InTcpConnected
                      if (auto e = std::get_if<core::InTcpConnected>(&ev)) {
                          out.push_back(core::OutStateChanged{cur, State::Connected}); // 补充 core::
                      }
                      return out;
                  },
                  State::Connected
              },

              { State::Connecting, EventType::TcpDisconnected,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput&){ return std::vector<core::CoreOutput>{}; },
                  State::Disconnected
              },

              // ===== 已连接 =====
              { State::Connected, EventType::CmdLogin,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                      std::vector<core::CoreOutput> out;
                      // 替换为 InCmdLogin
                      if (auto e = std::get_if<core::InCmdLogin>(&ev)) {
                          out.push_back(core::OutStateChanged{cur, State::LoggingIn}); // 补充 core::
                          out.push_back(core::OutSendLogin{e->user, e->pass}); // 补充 core::
                      }
                      return out;
                  },
                  State::LoggingIn
              },

              // ===== 正在登录 =====
              { State::LoggingIn, EventType::LoginOk ,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                      std::vector<core::CoreOutput> out;
                      // 替换为 InLoginOk
                      if (auto e = std::get_if<core::InLoginOk>(&ev)) {
                          out.push_back(core::OutLoginOk{}); // 补充 core::
                          out.push_back(core::OutStateChanged{cur, State::LoggedIn}); // 补充 core::
                      }
                      return out;
                  },
                  State::LoggedIn
              },

              { State::LoggingIn, EventType::LoginFail ,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                      std::vector<core::CoreOutput> out;
                      // 替换为 InLoginFail
                      if (auto e = std::get_if<core::InLoginFail>(&ev)) {
                          out.push_back(core::OutLoginFail{e->msg}); // 补充 core::
                          out.push_back(core::OutStateChanged{cur, State::Connected}); // 补充 core::
                      }
                      return out;
                  },
                  State::Connected
              },

              // ===== 任何在线状态断线 =====
              { State::Connected,  EventType::TcpDisconnected,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput&){
                      return std::vector<core::CoreOutput>{
                          core::OutStateChanged{cur, State::Disconnected}, // 补充 core::
                          core::OutDisconnected{} // 补充 core::
                      };
                  },
                  State::Disconnected
              },
              { State::LoggingIn,  EventType::TcpDisconnected,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput&){
                      return std::vector<core::CoreOutput>{
                          core::OutStateChanged{cur, State::Disconnected}, // 补充 core::
                          core::OutDisconnected{} // 补充 core::
                      };
                  },
                  State::Disconnected
              },
              { State::LoggedIn,   EventType::TcpDisconnected,
                  // 补充 core:: 前缀
                  [](State cur, const core::CoreInput&){
                      return std::vector<core::CoreOutput>{
                          core::OutStateChanged{cur, State::Disconnected}, // 补充 core::
                          core::OutDisconnected{} // 补充 core::
                      };
                  },
                  State::Disconnected
              },
              };
}

========== ./core/ClientCore.h ==========
Lines: 43

#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "FSM.h"
#include "ClientState.h"
#include "CoreExecutor.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <memory>

class ClientCore {
public:
    ClientCore();
    ~ClientCore();

    // 线程安全接口（对外暴露）
    void postInput(core::CoreInput ev);
    bool pollOutput(core::CoreOutput& out); // 补充 core:: 前缀

    // 废弃：原直接操作 socket 的接口
    // bool connectToServer(const std::string& host, int port);
    // void sendLogin(const std::string& user, const std::string& pass);

private:
    FSM fsm_;
    State state_ = State::Disconnected;
    std::unique_ptr<CoreExecutor> executor_;

    // 线程安全队列（补充 core:: 前缀）
    std::queue<core::CoreInput>  inputQueue_;
    std::queue<core::CoreOutput> outputQueue_; // 补充 core:: 前缀
    std::mutex mtx_;
    std::condition_variable cv_;

    // 核心方法（参数补充 core:: 前缀）
    void processEvents();
    void applyStateChange(const core::OutStateChanged& e); // 补充 core:: 前缀
    void handleOutput(core::CoreOutput&& o); // 补充 core:: 前缀
    void execute(const core::OutConnect& e) ; // 补充 core:: 前缀
    void execute(const core::OutSendLogin& e) ; // 补充 core:: 前缀
};

========== ./core/CoreExecutor.cpp ==========
Lines: 73

//CoreExecutor.cpp
#include "CoreExecutor.h"
#include "ClientEventFactory.h"
#include <thread>
#include <iostream>

CoreExecutor::CoreExecutor(InputCallback cb)
    : postInput_(std::move(cb)) {
    initSocketCallbacks();
}

CoreExecutor::~CoreExecutor() {
    stop();
}

void CoreExecutor::initSocketCallbacks() {
    // 1. 连接成功回调：推送 InTcpConnected 到 Core
    socket_.setConnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpConnected{}); // 替换为 InTcpConnected
            std::cout << "[Executor] Socket connected, push InTcpConnected to Core" << std::endl;
        }
    });

    // 2. 断开连接回调：推送 InTcpDisconnected 到 Core
    socket_.setDisconnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpDisconnected{}); // 替换为 InTcpDisconnected
            std::cout << "[Executor] Socket disconnected, push InTcpDisconnected to Core" << std::endl;
        }
    });

    // 3. 消息接收回调：解析消息并推送对应 CoreInput 到 Core
    socket_.setMessageCallback([this](const std::string& msg) {
        if (!isRunning_) return;

        ClientEvent event = ClientEventFactory::makeEvent(msg);
        std::visit([this](auto&& e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, ProtoEvtLoginOk>) {
                postInput_(core::InLoginOk{}); // 替换为 InLoginOk
            } else if constexpr (std::is_same_v<T, ProtoEvtLoginFail>) {
                postInput_(core::InLoginFail{e.resp.message}); // 替换为 InLoginFail
            } else if constexpr (std::is_same_v<T, ProtoEvtOnlineUsers>) {
                postInput_(core::InOnlineUsers{""}); // 替换为 InOnlineUsers
            } else {
                postInput_(core::InUnknow{}); // 替换为 InUnknow
            }
        }, event);
    });
}

void CoreExecutor::connectToServer(const std::string& host, int port) {
    // 异步执行连接
    std::thread([this, host, port]() {
        if (!socket_.connectToServer(host, port)) {
            // 连接失败：推送 InTcpDisconnected
            postInput_(core::InTcpDisconnected{}); // 替换为 InTcpDisconnected
            std::cout << "[Executor] Connect to " << host << ":" << port << " failed" << std::endl;
        }
    }).detach();
}

void CoreExecutor::sendLoginRequest(const std::string& user, const std::string& pass) {
    std::string loginMsg = proto::makeLoginRequest(user, pass);
    socket_.sendMessage(loginMsg);
    std::cout << "[Executor] Send login request for user: " << user << std::endl;
}

void CoreExecutor::stop() {
    isRunning_ = false;
    socket_.stop();
}

========== ./core/ClientState.h ==========
Lines: 24

// ClientState.h
#pragma once

#include <string>

enum class State {
    Disconnected,
    Connecting,
    Connected,
    LoggingIn,
    LoggedIn
};

// 将 State 转换为字符串
inline std::string stateToString(State s) {
    switch (s) {
    case State::Disconnected: return "Disconnected";
    case State::Connecting:   return "Connecting";
    case State::Connected:    return "Connected";
    case State::LoggingIn:    return "LoggingIn";
    case State::LoggedIn:     return "LoggedIn";
    default:                  return "Unknown";
    }
}

========== ./core/CoreExecutor.h ==========
Lines: 34

//CoreExecutor.h
#pragma once
#include "CoreInput.h"
#include "CommandSocket.h"
#include "protocol_text.h"
#include "ClientEventFactory.h"
#include <functional>
#include <memory>

// 定义回调类型：Executor 执行 IO 后，通过该回调向 ClientCore 推送 CoreInput
using InputCallback = std::function<void(core::CoreInput)>;

class CoreExecutor {
public:
    // 构造函数：接收回调函数（用于向 Core 推送输入事件）
    explicit CoreExecutor(InputCallback cb);
    ~CoreExecutor();

    // 对外暴露的 IO 操作接口（语义化命名）
    void connectToServer(const std::string& host, int port);
    void sendLoginRequest(const std::string& user, const std::string& pass);
    void stop(); // 资源释放接口

private:
    // 封装的 socket 实例（Executor 唯一持有）
    CommandSocket socket_;
    // 向 Core 推送事件的回调
    InputCallback postInput_;
    // 线程安全标记
    std::atomic<bool> isRunning_{true};

    // 初始化 socket 回调（内部私有）
    void initSocketCallbacks();
};

========== ./core/CoreOutput.h ==========
Lines: 28

// core/CoreOutput.h
#pragma once
#include <variant>
#include "ClientState.h"

// 输出层事件全部纳入 core 命名空间
namespace core {

struct OutStateChanged {
    State from;
    State to;
};
struct OutLoginOk {};
struct OutLoginFail { std::string msg; };
struct OutDisconnected {};
struct OutConnect { std::string host; int port; };
struct OutSendLogin { std::string user; std::string pass; };

using CoreOutput = std::variant<
    OutStateChanged,
    OutLoginOk,
    OutLoginFail,
    OutDisconnected,
    OutConnect,
    OutSendLogin
    >;

} // namespace core

========== ./net/PacketCodec.h ==========
Lines: 39

//PacketCodec.h
#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // 打包：payload → 带长度头的二进制数据
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // 尝试解包：从 buffer 中提取一个完整 payload
    // 成功返回 true，并填充 outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 48

//CommandSocket.h
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <vector>
#include "PacketCodec.h"

class CommandSocket {
public:
    using MessageCallback = std::function<void(const std::string&)>;
    using ConnectCallback = std::function<void()>;
    using DisconnectCallback = std::function<void()>;

    CommandSocket();
    ~CommandSocket();

    void setConnectCallback(ConnectCallback cb);
    void setDisconnectCallback(DisconnectCallback cb);
    // TCP 客户端
    bool connectToServer(const std::string& host, int port);

    // TCP 服务器
    bool startServer(int port);

    void setMessageCallback(MessageCallback cb);

    // 发送数据
    void sendMessage(const std::string& msg);

    // 停止
    void stop();

private:
    void clientThreadFunc();
    void serverThreadFunc();
    void sendPacket(int fd, const std::string& payload);
    int sockfd_ = -1;
    int clientfd_ = -1;  // 对于服务器端保存客户端连接
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    MessageCallback callback_;

    ConnectCallback onConnect_;
    DisconnectCallback onDisconnect_;

};

========== ./net/CommandSocket.cpp ==========
Lines: 139

//CommandSocket.cpp
#include "CommandSocket.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

CommandSocket::CommandSocket() {}

CommandSocket::~CommandSocket() {
    stop();
}

void CommandSocket::setMessageCallback(MessageCallback cb) {
    callback_ = std::move(cb);
}

void CommandSocket::setConnectCallback(ConnectCallback cb) {
    onConnect_ = std::move(cb);
}

void CommandSocket::setDisconnectCallback(DisconnectCallback cb) {
    onDisconnect_ = std::move(cb);
}


void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


bool CommandSocket::connectToServer(const std::string& host, int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &serv_addr.sin_addr);

    if (connect(sockfd_, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sockfd_);
        sockfd_ = -1;
        return false;
    }

    if (onConnect_) onConnect_();   // ⭐ TCP真正建立
    // std::thread([this]{
    //     if (onConnect_) onConnect_();
    // }).detach();

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::clientThreadFunc, this);
    return true;
}

bool CommandSocket::startServer(int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(sockfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(sockfd_, 1) < 0) return false;

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::serverThreadFunc, this);
    return true;
}

void CommandSocket::sendMessage(const std::string& msg) {
    int fd = (clientfd_ >= 0) ? clientfd_ : sockfd_;
    sendPacket(fd,msg);
}

void CommandSocket::stop() {
    running_ = false;
    if (workerThread_.joinable())
        workerThread_.join();
    if (sockfd_ >= 0) close(sockfd_);
    if (clientfd_ >= 0) close(clientfd_);
    sockfd_ = -1;
    clientfd_ = -1;
}

void CommandSocket::clientThreadFunc() {
    std::vector<char> recvBuffer;
    char temp[1024];

    while (running_) {
        int n = recv(sockfd_, temp, sizeof(temp), 0);
        if (n > 0) {

            // 1️⃣ 把收到的字节塞进缓存
            recvBuffer.insert(recvBuffer.end(), temp, temp + n);

            // 2️⃣ 尝试从缓存中拆完整包
            std::string payload;
            while (PacketCodec::tryDecode(recvBuffer, payload)) {

                // 3️⃣ 每一个 payload = 一条完整“应用层消息”
                if (callback_) {
                    callback_(payload);
                }
            }

        } else if (n <= 0) {
            if (onDisconnect_) onDisconnect_();  // ⭐ TCP断线
            break; // 服务器正常断开
        }
    }
}

void CommandSocket::serverThreadFunc() {
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    clientfd_ = accept(sockfd_, (sockaddr*)&client_addr, &client_len);
    if (clientfd_ < 0) return;

    char buffer[1024];
    while (running_) {
        int n = recv(clientfd_, buffer, sizeof(buffer) - 1, 0);
        if (n > 0) {
            buffer[n] = '\0';
            if (callback_) callback_(std::string(buffer));
        } else if (n == 0) {
            break; // 客户端断开
        }
    }
}

========== ./ui/VideoWidget.cpp ==========
Lines: 35

//VideoWidget.cpp
#include "VideoWidget.h"
#include <QPainter>
#include <QDebug>
VideoWidget::VideoWidget(QWidget *parent)
    : QWidget(parent) {
    setMinimumSize(640, 480);
}

void VideoWidget::setFrame(const QImage &img) {
    frame_ = img;
    update();
}

void VideoWidget::paintEvent(QPaintEvent *) {
    QPainter p(this);
    p.fillRect(rect(), Qt::black);

    if (frame_.isNull())
        return;

    QSize imgSize = frame_.size();
    imgSize.scale(size(), Qt::KeepAspectRatio);

    QRect targetRect(
        (width()  - imgSize.width())  / 2,
        (height() - imgSize.height()) / 2,
        imgSize.width(),
        imgSize.height()
        );
    //qDebug() << "widget size:" << size();

    p.drawImage(targetRect, frame_);
}


========== ./ui/widget.cpp ==========
Lines: 46

//widget.cpp
#include "widget.h"
#include "./ui_widget.h"
#include <QDebug>

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    video_ = new VideoWidget(ui->videoContainer);
    // video_->setSizePolicy(QSizePolicy::Expanding,
    //                       QSizePolicy::Expanding);
    adapter_ = new QtCameraAdapter(video_, this);


}

Widget::~Widget()
{
    delete ui;
}

void Widget::on_Bt_video_on_off_clicked()
{
    qDebug("Button clicked!");
    camera_.start("/dev/video0");
}


void Widget::on_Bt_video_off_clicked()
{
    qDebug("Button clicked!");
    camera_.stop();
}


void Widget::on_Bt_tcp_send_clicked()
{
}


void Widget::on_Bt_tcp_connect_clicked()
{
}


========== ./ui/QtCameraAdapter.cpp ==========
Lines: 18

//QtCameraAdapter.cpp
#include "QtCameraAdapter.h"
#include <QImage>

QtCameraAdapter::QtCameraAdapter(VideoWidget* view, QObject* parent)
    : QObject(parent), view_(view) {}

void QtCameraAdapter::onFrame(Frame f) {
    QImage img(
        f.data.data(),
        f.width,
        f.height,
        f.stride,
        QImage::Format_RGB888
        );

    view_->setFrame(img.copy());
}

========== ./ui/LoginWidget.h ==========
Lines: 44

//LoginWidget.h
#ifndef LOGINWIDGET_H
#define LOGINWIDGET_H

#include <QWidget>

#include "widget.h"
#include "ClientCore.h"

namespace Ui {
class LoginWidget;
}

class LoginWidget : public QWidget
{
    Q_OBJECT

public:
    explicit LoginWidget(QWidget *parent = nullptr);
    ~LoginWidget();

signals:
    void loginSuccess();

private slots:
    void on_Bt_Jump_Test_clicked();
    void on_Bt_ConnectToServer_clicked();
    void on_Bt_tcp_test_send_clicked();
    void on_Bt_Login_clicked();

private:
    Ui::LoginWidget *ui;
    ClientCore* core_;

    // 所有参数补充 core:: 前缀
    void handle(const core::OutLoginFail&);
    void handle(const core::OutDisconnected&) ;
    void handle(const core::OutLoginOk&) ;
    void handle(const core::OutStateChanged& e) ;
    void handle(const core::OutConnect&);       // 新增
    void handle(const core::OutSendLogin&);     // 新增
};

#endif // LOGINWIDGET_H

========== ./ui/AppWindow.cpp ==========
Lines: 30

//AppWindow.cpp
#include "AppWindow.h"
#include "LoginWidget.h"
#include "widget.h"
#include <QVBoxLayout>

AppWindow::AppWindow(QWidget *parent)
    : QWidget(parent)
{
    resize(900, 600);
    stack = new QStackedWidget(this);

    loginPage = new LoginWidget;
    mainPage  = new Widget;

    stack->addWidget(loginPage); // index 0
    stack->addWidget(mainPage);  // index 1

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(stack);
    setLayout(layout);

    // 登录成功 → 切换页面
    connect(loginPage, &LoginWidget::loginSuccess, this, [=](){
        stack->setCurrentIndex(PAGE_MAIN);
    });

    // 初始页面
    stack->setCurrentIndex(PAGE_LOGIN);
}

========== ./ui/VideoWidget.h ==========
Lines: 17

//VideoWidget.h
#pragma once
#include <QWidget>
#include <QImage>

class VideoWidget : public QWidget {
    Q_OBJECT
public:
    explicit VideoWidget(QWidget *parent = nullptr);
    void setFrame(const QImage &img);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QImage frame_;
};

========== ./ui/QtCameraAdapter.h ==========
Lines: 17

//QtCameraAdapter.h
#pragma once
#include <QObject>
#include "Frame.h"
#include "VideoWidget.h"

class QtCameraAdapter : public QObject {
    Q_OBJECT
public:
    explicit QtCameraAdapter(VideoWidget* view, QObject* parent = nullptr);

public slots:
    void onFrame(Frame frame);

private:
    VideoWidget* view_;
};

========== ./ui/LoginWidget.cpp ==========
Lines: 97

//LoginWidget.cpp
#include "LoginWidget.h"
#include "./ui_LoginWidget.h"
#include <QMessageBox>
#include <QMetaObject>
#include <QDebug>

#include <QThread>
#include <QTimer>

LoginWidget::LoginWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::LoginWidget)
{
    ui->setupUi(this);

    core_ = new ClientCore;

    QTimer* timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, [this]{
        core::CoreOutput out; // 补充 core:: 前缀
        while (core_->pollOutput(out)) {
            std::cout << "[UI] get output, type index: " << out.index() << std::endl;
            std::visit([this](const auto& e){
                handle(e);
            }, out);
        }
    });
    timer->start(10);
}

LoginWidget::~LoginWidget()
{
    delete ui;
}

void LoginWidget::on_Bt_Jump_Test_clicked()
{
    emit loginSuccess();
}

void LoginWidget::on_Bt_ConnectToServer_clicked()
{
    qDebug() << "current thread:" << QThread::currentThread();
    qDebug() << "ui thread:" << qApp->thread();

    ui->TextEdit_tcp_test_recv->setPlainText("Connecting\n");
    // 替换为 InCmdConnect
    core_->postInput(core::InCmdConnect{"127.0.0.1",6001});
}

void LoginWidget::on_Bt_tcp_test_send_clicked()
{
    QString qmsg = ui->LE_tcp_send_test->text();
    std::string msg = qmsg.toStdString();
}

// 所有 handle 函数参数补充 core:: 前缀
void LoginWidget::handle(const core::OutLoginFail&) {
    std::cout << "[UI] handle OutLoginFail: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login failed");
}

void LoginWidget::handle(const core::OutDisconnected&) {
    std::cout << "[UI] handle OutDisconnected: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutDisconnected");
}

void LoginWidget::handle(const core::OutLoginOk&) {
    std::cout << "[UI] handle OutLoginOk: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login success");
}

void LoginWidget::handle(const core::OutStateChanged& e) {
    std::cout << "[UI] handle OutStateChanged: " << stateToString(e.from) << " to " << stateToString(e.to) << std::endl;
    ui->TextEdit_FSM_State->setPlainText(QString::fromStdString(stateToString(e.to)));
}

void LoginWidget::handle(const core::OutConnect&) {
    std::cout << "[UI] Ignore OutConnect (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutSendLogin&) {
    std::cout << "[UI] Ignore OutSendLogin (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::on_Bt_Login_clicked()
{
    QString qstr_user_name = ui->LE_UserName->text();
    std::string msg_user_name = qstr_user_name.toStdString();

    QString qstr_user_pass = ui->LE_UserPass->text();
    std::string msg_user_pass = qstr_user_pass.toStdString();

    // 替换为 InCmdLogin
    core_->postInput(core::InCmdLogin{msg_user_name, msg_user_pass});
}

========== ./ui/AppWindow.h ==========
Lines: 23

//AppWindow.h
#pragma once
#include <QWidget>
#include <QStackedWidget>
#include "LoginWidget.h"
#include "widget.h"

class AppWindow : public QWidget
{
    Q_OBJECT
public:
    explicit AppWindow(QWidget *parent = nullptr);

private:
    QStackedWidget *stack;
    LoginWidget *loginPage;
    Widget *mainPage;

    enum PageIndex {
        PAGE_LOGIN = 0,
        PAGE_MAIN
    };
};

========== ./ui/widget.h ==========
Lines: 39

//widget.h
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "QtCameraAdapter.h"
#include "CameraManager.h"


QT_BEGIN_NAMESPACE
namespace Ui {
class Widget;
}
QT_END_NAMESPACE

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

private slots:
    void on_Bt_video_on_off_clicked();

    void on_Bt_video_off_clicked();

    void on_Bt_tcp_send_clicked();

    void on_Bt_tcp_connect_clicked();

private:
    Ui::Widget *ui;
    VideoWidget *video_;
    CameraManager camera_;
    QtCameraAdapter* adapter_;
};
#endif // WIDGET_H

========== ./protocol/protocol_types.h ==========
Lines: 27

//protocol_types.h
#pragma once
#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct Unknown {
    std::string message;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

}

========== ./protocol/protocol_text.h ==========
Lines: 19

//protocol_text.h
#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);

// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);

}

========== ./protocol/protocol_text.cpp ==========
Lines: 126

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

// Client 使用
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server 使用
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server 使用
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server 使用
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    oss ;
    return oss.str();
}

/* ================= parse ================= */

// Server 使用
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client 使用
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client 使用
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}

} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 20

//protocol_common.h
#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN        = "LOGIN";
constexpr const char* CMD_LOGIN_OK     = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL   = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS = "ONLINE_USERS";

// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}

========== ./app/ClientEvent.h ==========
Lines: 40

//ClientEvent.h
#pragma once

#include <string>
#include "protocol_types.h"
#include <variant>

// 协议层事件统一前缀：ProtoEvt
struct ProtoEvtTcpConnected {};
struct ProtoEvtTcpDisconnected {};
struct ProtoEvtLoginOk    { proto::LoginResponse resp; };
struct ProtoEvtLoginFail { proto::LoginResponse resp; };
struct ProtoEvtOnlineUsers { proto::OnlineUsers users; };
struct ProtoEvtUnknow { proto::Unknown error_msg; };
struct ProtoEvtCmdConnect {
    std::string host;
    int port;
};
struct ProtoEvtCmdDisconnect {};
struct ProtoEvtCmdLogin {
    std::string user;
    std::string pass;
};

using ClientEvent = std::variant<
    // UI 触发的协议命令
    ProtoEvtCmdConnect,
    ProtoEvtCmdDisconnect,
    ProtoEvtCmdLogin,

    // TCP 底层事件
    ProtoEvtTcpConnected,
    ProtoEvtTcpDisconnected,

    // 协议解析后的业务事件
    ProtoEvtLoginOk,
    ProtoEvtLoginFail,
    ProtoEvtOnlineUsers,
    ProtoEvtUnknow
    >;

========== ./app/ClientEventFactory.h ==========
Lines: 18

//ClientEventFactory.h
#ifndef CLIENTEVENTFACTORY_H
#define CLIENTEVENTFACTORY_H

#include "protocol_types.h"
#include "ClientEvent.h"
class ClientEventFactory
{
public:
    ClientEventFactory();
    static ClientEvent makeEvent(const std::string& msg);

private:


};

#endif // CLIENTEVENTFACTORY_H

========== ./app/ClientEventFactory.cpp ==========
Lines: 27

//ClientEventFactory.cpp
#include "ClientEventFactory.h"

// 只在 cpp 中 include 解析函数
#include "protocol_text.h"

ClientEventFactory::ClientEventFactory() {}

ClientEvent ClientEventFactory::makeEvent(const std::string& msg)
{
    proto::LoginResponse login;
    if (proto::parseLoginResponse(msg, login)) {
        if (login.success)
            return ProtoEvtLoginOk{login}; // 改为 ProtoEvt 前缀
        else
            return ProtoEvtLoginFail{login}; // 改为 ProtoEvt 前缀
    }

    proto::OnlineUsers users;
    if (proto::parseOnlineUsers(msg, users)) {
        return ProtoEvtOnlineUsers{users}; // 改为 ProtoEvt 前缀
    }

    proto::Unknown req_error;
    req_error.message = msg;
    return ProtoEvtUnknow{req_error}; // 改为 ProtoEvt 前缀
}

========== ./app/ClientEventEnum.h ==========
Lines: 20

//ClientEventEnum.h
#pragma once


enum class EventType {
    // ===== UI 命令 =====
    CmdConnect,
    CmdDisconnect,
    CmdLogin,

    // ===== TCP =====
    TcpConnected,
    TcpDisconnected,

    // ===== 协议 =====
    LoginOk,
    LoginFail,
    OnlineUsers,
    Unknow
};

========== ./media/CameraManager.cpp ==========
Lines: 98

//CameraManager.cpp
#include "CameraManager.h"
#include <iostream>
#include <cstring>

CameraManager::CameraManager() {
    gst_init(nullptr, nullptr);
}

CameraManager::~CameraManager() {
    stop();
}

void CameraManager::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool CameraManager::start(const std::string& device) {
    if (pipeline_) return true;

    std::string pipelineStr =
        "v4l2src device=" + device +
        " ! video/x-raw,format=YUY2,width=640,height=480,framerate=30/1 "
        " ! videoconvert "
        " ! openh264enc bitrate=2000000 "
        " ! h264parse "
        " ! tee name=t "
        " t. ! queue "
        "     ! avdec_h264 "
        "     ! videoconvert "
        "     ! video/x-raw,format=RGB "
        "     ! appsink name=sink "
        " t. ! queue "
        "     ! rtph264pay pt=96 config-interval=1 "
        "     ! udpsink host=192.168.6.15 port=5000 sync=false async=false";

    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "Failed to create pipeline\n";
        return false;
    }

    /* appsink 用于 Qt 显示 */
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "sink");

    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1);
    
    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    return true;
}

void CameraManager::stop() {
    if (!pipeline_) return;

    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn CameraManager::onNewSample(GstAppSink* sink, gpointer user_data) {
    auto* self = static_cast<CameraManager*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3;
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    self->callback_(frame);

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

========== ./media/CameraManager.h ==========
Lines: 29

//CameraManager.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

class CameraManager {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    CameraManager();
    ~CameraManager();

    bool start(const std::string& device);
    void stop();

    void setFrameCallback(FrameCallback cb);

private:
    GstElement* pipeline_ = nullptr;
    GstElement* appsink_  = nullptr;

    FrameCallback callback_;

    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);
};

========== ./media/Frame.h ==========
Lines: 19

//Frame.h
#pragma once
#include <vector>
#include <cstdint>
#include <QMetaType>   // ⚠️ 必须加这一行
enum class PixelFormat {
    RGB888
};

struct Frame {
    std::vector<uint8_t> data; // 连续内存
    int width = 0;
    int height = 0;
    int stride = 0;
    PixelFormat format;
    uint64_t timestamp = 0;
};

Q_DECLARE_METATYPE(Frame)


=====================================
Total files: 34
Total lines: 1601
