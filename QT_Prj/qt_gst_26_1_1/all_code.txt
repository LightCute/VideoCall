========== å·¥ç¨‹ç›®å½•ç»“æ„ï¼ˆä»…å«.h/.cppï¼‰==========

ğŸ“‚ .:
  â””â”€ main.cpp

ğŸ“‚ ./util:
  â””â”€ GetLocalIP.h
  â””â”€ PortUtils.cpp
  â””â”€ PortUtils.h

ğŸ“‚ ./core:
  â””â”€ CallManager.cpp
  â””â”€ CallManager.h
  â””â”€ CallSession.h
  â””â”€ ClientCore.cpp
  â””â”€ ClientCore.h
  â””â”€ ClientState.h
  â””â”€ CoreExecutor.cpp
  â””â”€ CoreExecutor.h
  â””â”€ CoreInput.h
  â””â”€ CoreOutput.h
  â””â”€ FSM.cpp
  â””â”€ FSM.h
  â””â”€ ICoreListener.h

ğŸ“‚ ./net:
  â””â”€ CommandSocket.cpp
  â””â”€ CommandSocket.h
  â””â”€ PacketCodec.h

ğŸ“‚ ./ui:
  â””â”€ AppWindow.cpp
  â””â”€ AppWindow.h
  â””â”€ LoginWidget.cpp
  â””â”€ LoginWidget.h
  â””â”€ QtCameraAdapter.cpp
  â””â”€ QtCameraAdapter.h
  â””â”€ VideoWidget.cpp
  â””â”€ VideoWidget.h
  â””â”€ widget.cpp
  â””â”€ widget.h

ğŸ“‚ ./protocol:
  â””â”€ protocol_common.h
  â””â”€ protocol_text.cpp
  â””â”€ protocol_text.h
  â””â”€ protocol_types.h

ğŸ“‚ ./app:
  â””â”€ ClientEvent.h
  â””â”€ ClientEventEnum.h
  â””â”€ ClientEventFactory.cpp
  â””â”€ ClientEventFactory.h

ğŸ“‚ ./media:
  â””â”€ CameraManager.cpp
  â””â”€ CameraManager.h
  â””â”€ Frame.h
  â””â”€ VideoReceiver.cpp
  â””â”€ VideoReceiver.h

==================================================
========== æ‰€æœ‰.h/.cppæ–‡ä»¶å†…å®¹ ==========


========== ./main.cpp ==========
Lines: 37

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <variant>

#ifdef slots
#undef slots
#endif
#ifdef signals
#undef signals
#endif

#include <QApplication>
#include "widget.h"
#include "LoginWidget.h"
#include "AppWindow.h"
#include "core/CoreOutput.h"
// #include "widget.h"
// #include "LoginWidget.h"
// #include <QApplication>
// #include "AppWindow.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    qRegisterMetaType<Frame>("Frame");
    qRegisterMetaType<core::UiOutput>("core::UiOutput");  // æ–°å¢
    AppWindow w;
    //LoginWidget login_W;
    //login_W.show();
    w.show();
    return a.exec();
}

========== ./util/PortUtils.h ==========
Lines: 10

//PortUtils.h
#pragma once
#include <cstdint>

// æ£€æµ‹æŒ‡å®šUDPç«¯å£æ˜¯å¦å¯ç”¨ï¼ˆç»‘å®šæˆåŠŸåˆ™å¯ç”¨ï¼‰
bool isUdpPortAvailable(uint16_t port);

// æŸ¥æ‰¾æŒ‡å®šèŒƒå›´å†…çš„å¯ç”¨UDPç«¯å£ï¼Œæ— å¯ç”¨è¿”å›-1
// é»˜è®¤èŒƒå›´ï¼š5000-65535ï¼ˆé¿å¼€çŸ¥åç«¯å£ï¼Œé€‚åˆéŸ³è§†é¢‘ä¼ è¾“ï¼‰
int findAvailableUdpPort(uint16_t startPort = 5000, uint16_t endPort = 65535);

========== ./util/GetLocalIP.h ==========
Lines: 51

#include <arpa/inet.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <netdb.h>
std::string getLocalLanIP()
{
    struct ifaddrs *ifaddr, *ifa;
    char host[NI_MAXHOST];

    // è·å–æ‰€æœ‰ç½‘ç»œæ¥å£ä¿¡æ¯ï¼Œå¤±è´¥åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs failed"); // æ‰“å°é”™è¯¯ä¿¡æ¯
        return "";
    }

    std::string result = "";

    // éå†æ‰€æœ‰ç½‘ç»œæ¥å£
    for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr) continue;

        // ç­›é€‰IPv4åœ°å€ï¼ˆAF_INETï¼‰
        if (ifa->ifa_addr->sa_family == AF_INET) {
            void* addr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
            // å°†äºŒè¿›åˆ¶IPè½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
            inet_ntop(AF_INET, addr, host, NI_MAXHOST);

            std::string ip = host;

            // è¿‡æ»¤å›ç¯åœ°å€ï¼ˆ127.0.0.1ï¼‰ï¼Œå–ç¬¬ä¸€ä¸ªéå›ç¯çš„LAN IP
            if (ip != "127.0.0.1") {
                result = ip;
                break;
            }
        }
    }

    // é‡Šæ”¾æ¥å£ä¿¡æ¯å†…å­˜
    freeifaddrs(ifaddr);
    return result;
}


std::string getVpnIp()
{
    return "10.0.0.1";
}

========== ./util/PortUtils.cpp ==========
Lines: 49

//PortUtils.cpp
#include "PortUtils.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <iostream>

bool isUdpPortAvailable(uint16_t port) {
    // 1. åˆ›å»ºUDPå¥—æ¥å­—ï¼ˆSOCK_DGRAMï¼‰
    // åŸå› ï¼šUDPç«¯å£æ£€æµ‹å¿…é¡»ç”¨UDPå¥—æ¥å­—ï¼ŒTCPæ£€æµ‹ç»“æœä¸é€‚ç”¨
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        std::cerr << "Failed to create socket for port check: " << port << std::endl;
        return false;
    }

    // 2. è®¾ç½®ç«¯å£å¤ç”¨
    // åŸå› ï¼šé¿å…TIME_WAITçŠ¶æ€å¯¼è‡´çš„ç«¯å£æš‚æ—¶ä¸å¯ç”¨ï¼Œæé«˜æ£€æµ‹å‡†ç¡®æ€§
    int opt = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // 3. å°è¯•ç»‘å®šç«¯å£
    // åŸå› ï¼šUDPç«¯å£æ˜¯å¦å¯ç”¨çš„æ ¸å¿ƒåˆ¤æ–­ä¾æ®ï¼ˆèƒ½ç»‘å®šåˆ™æœªè¢«å ç”¨ï¼‰
    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®šæ‰€æœ‰ç½‘å¡

    bool available = (bind(sockfd, (sockaddr*)&addr, sizeof(addr)) == 0);

    // 4. å…³é—­å¥—æ¥å­—
    // åŸå› ï¼šä»…æ£€æµ‹å¯ç”¨æ€§ï¼Œæ— éœ€ä¿ç•™å¥—æ¥å­—ï¼Œé‡Šæ”¾èµ„æº
    close(sockfd);

    return available;
}

int findAvailableUdpPort(uint16_t startPort, uint16_t endPort) {
    // éå†ç«¯å£èŒƒå›´ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨ç«¯å£
    // åŸå› ï¼šä¼˜å…ˆä½¿ç”¨ä½ç«¯å£ï¼ˆ5000+ï¼‰ï¼Œç¬¦åˆéŸ³è§†é¢‘ä¼ è¾“çš„å¸¸ç”¨ç«¯å£ä¹ æƒ¯
    for (uint16_t port = startPort; port <= endPort; ++port) {
        if (isUdpPortAvailable(port)) {
            std::cout << "[PortUtils] Found available UDP port: " << port << std::endl;
            return port;
        }
    }
    std::cerr << "[PortUtils] No available UDP port in range [" << startPort << ", " << endPort << "]" << std::endl;
    return -1;
}

========== ./core/ClientCore.cpp ==========
Lines: 367

#include "ClientCore.h"
#include <algorithm>
#include <iostream>

// æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ– Executorï¼Œè®¾ç½®å›è°ƒ
ClientCore::ClientCore() : fsm_() {
    // åˆå§‹åŒ– Executorï¼šå›è°ƒå‡½æ•°ç”¨äºæ¥æ”¶ Executor æ¨é€çš„ CoreInput
    executor_ = std::make_unique<CoreExecutor>(
        [this](core::CoreInput ev) {
            this->postInput(std::move(ev)); // å°† Executor çš„äº‹ä»¶æ¨å…¥è¾“å…¥é˜Ÿåˆ—
        }
        );
    // å¯åŠ¨äº‹ä»¶å¤„ç†çº¿ç¨‹ï¼ˆä»…è°ƒåº¦ï¼Œæ—  IOï¼‰
    std::thread([this]{ processEvents(); }).detach();
    current_call_session_.emplace();
}

ClientCore::~ClientCore() {
    // é‡Šæ”¾ Executor èµ„æº
    stop();
    if (executor_) {
        executor_->stop();
    }
}

void ClientCore::stop() {
    is_running_ = false;
    cv_.notify_one(); // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ï¼Œä½¿å…¶é€€å‡ºå¾ªç¯
}

// çº¿ç¨‹å®‰å…¨ï¼šæ¨å…¥è¾“å…¥äº‹ä»¶
void ClientCore::postInput(core::CoreInput ev) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        inputQueue_.push(std::move(ev));
    }
    cv_.notify_one();
}

// æ–°å¢ï¼šæ·»åŠ ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::addListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.push_back(listener);
}

// æ–°å¢ï¼šç§»é™¤ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::removeListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.erase(
        std::remove(listeners_.begin(), listeners_.end(), listener),
        listeners_.end()
        );
}

// äº‹ä»¶å¤„ç†ä¸»å¾ªç¯ï¼ˆä¿ç•™åŸæœ‰çº¿ç¨‹æ¨¡å‹ï¼Œé€‚é…æ–°è¾“å‡ºé€»è¾‘ï¼‰
void ClientCore::processEvents() {
    while (is_running_) {
        core::CoreInput ev;
        {
            std::unique_lock<std::mutex> lock(mtx_);
            cv_.wait(lock, [this]{ return !inputQueue_.empty() || !is_running_; });
            if (!is_running_ && inputQueue_.empty()) break; // é€€å‡ºæ¡ä»¶ï¼šåœæ­¢ä¸”é˜Ÿåˆ—ç©º
            ev = std::move(inputQueue_.front());
            inputQueue_.pop();
            std::cout << "[ClientCore] Processing Input event, remaining queue size: " << inputQueue_.size()
                      << ", Event type : " << core::CoreInputIndexToName(ev.index())  << std::endl;
        }


        if (core::CoreInputIndexToName(ev.index()) == "InCallIncoming") {
            auto& incoming = std::get<core::InCallIncoming>(ev);
            // æ–°å¢ï¼šç¡®ä¿Sessionå·²åˆå§‹åŒ–ï¼ˆé˜²æ­¢ç©ºæŒ‡é’ˆï¼‰
            if (!current_call_session_.has_value()) {
                current_call_session_.emplace(); // åˆå§‹åŒ–ç©ºSession
                std::cout << "[ClientCore] Create new Session for incoming call from: " << incoming.from << std::endl;
            }
            auto& session = current_call_session_.value();
            // 1. ä¼˜å…ˆå†™å…¥Sessionï¼ˆå”¯ä¸€çœŸç›¸æºï¼‰
            session.peerName = incoming.from;
            session.isCaller = false;
            session.currentCallState = CallState::Ringing;
            // 2. åŒæ­¥åˆ°æ—§å­—æ®µï¼ˆä»…é•œåƒï¼Œç¦æ­¢ç›´æ¥ä¿®æ”¹æ—§å­—æ®µï¼‰
            peer_ = incoming.from;
            isCaller_ = false;
            std::cout << "[ClientCore] Incoming call: Session updated (peer: " << session.peerName << ", sessionId: " << session.sessionId << ")" << std::endl;
        }

        if (core::CoreInputIndexToName(ev.index()) == "InCallEnded") {
            auto& callEnded = std::get<core::InCallEnded>(ev);
            CallEndReason reason = CallEndReason::PeerHangup;
            if (callEnded.reason == "server_timeout") {
                reason = CallEndReason::ServerTimeout;
            }
            this->endCurrentSession(reason);
            std::cout << "[ClientCore] opposite hang up: " << callEnded.peer << ", reason: " << callEnded.reason << "ï¼‰" << std::endl;
            return;
        }

        if (core::CoreInputIndexToName(ev.index()) == "InTcpDisconnected") {
            if (current_call_session_.has_value()) {
                this->endCurrentSession(CallEndReason::NetworkError);
                std::cout << "[ClientCore] ç½‘ç»œæ–­å¼€ï¼Œç»“æŸæ´»è·ƒä¼šè¯" << std::endl;
            }
        }
        if (core::CoreInputIndexToName(ev.index()) == "InHeartbeatTimeout") {
            if (current_call_session_.has_value()) {
                this->endCurrentSession(CallEndReason::NetworkError);
                std::cout << "[ClientCore] å¿ƒè·³è¶…æ—¶ï¼Œç»“æŸæ´»è·ƒä¼šè¯" << std::endl;
            }
        }

        // è°ƒç”¨ FSM å¤„ç†è¾“å…¥ï¼Œè·å–æ–°è¯­ä¹‰è§„èŒƒçš„ CoreOutput åˆ—è¡¨
        auto outputs = fsm_.handle(state_, ev);


        {
            std::lock_guard<std::mutex> lock(mtx_);
            for (auto& o : outputs) {
                handleOutput(std::move(o)); // å¤„ç†æ¯ä¸ªè¾“å‡ºäº‹ä»¶
            }
        }
    }
}

void ClientCore::endCurrentSession(CallEndReason reason) {
    // 1ï¸âƒ£ é˜²é‡å¤ç»“æŸï¼šæ— æ´»è·ƒSession æˆ– æ­£åœ¨ç»“æŸï¼Œç›´æ¥è¿”å›
    if (!current_call_session_.has_value()) {
        std::cerr << "[ClientCore] endCurrentSession: æ— æ´»è·ƒä¼šè¯ï¼Œè·³è¿‡ç»“æŸé€»è¾‘" << std::endl;
        return;
    }
    auto& session = current_call_session_.value();
    if (session.currentCallState == CallState::Ending) {
        std::cout << "[ClientCore] endCurrentSession: ä¼šè¯æ­£åœ¨ç»“æŸï¼ˆreason: " << callEndReasonToString(reason) << "ï¼‰ï¼Œè·³è¿‡é‡å¤è°ƒç”¨" << std::endl;
        return;
    }

    // 2ï¸âƒ£ æ ‡è®°ä¸ºEndingçŠ¶æ€ï¼Œé˜»æ­¢åç»­é‡å¤è°ƒç”¨
    session.currentCallState = CallState::Ending;
    std::cout << "[ClientCore] å¼€å§‹ç»“æŸä¼šè¯ï¼ˆsessionId: " << session.sessionId << ", reason: " << callEndReasonToString(reason) << "ï¼‰" << std::endl;

    // 3ï¸âƒ£ åœæ­¢åª’ä½“ï¼ˆé€šè¿‡UIäº‹ä»¶é€šçŸ¥ï¼Œè€Œéç›´æ¥è°ƒç”¨â€”â€”ç¬¦åˆUI/CoreèŒè´£è¾¹ç•Œï¼‰
    // åŸå› ï¼šCameraManager/VideoReceiverç”±UIå±‚æŒæœ‰ï¼ŒCoreä¸ç›´æ¥æ“ä½œUIå±‚å®ä¾‹
    broadcastUiOutput(core::UiOutput{core::UiOutStopMedia{}});
    std::cout << "[ClientCore] å‘é€åœæ­¢åª’ä½“äº‹ä»¶ï¼ˆsessionId: " << session.sessionId << "ï¼‰" << std::endl;

    // 4ï¸âƒ£ æ¸…ç†Sessionï¼ˆå”¯ä¸€çœŸç›¸æºï¼‰
    current_call_session_.reset();
    std::cout << "[ClientCore] æ¸…ç†Sessionï¼ˆsessionId: " << session.sessionId << "ï¼‰" << std::endl;

    // 5ï¸âƒ£ åŒæ­¥æ—§å­—æ®µï¼ˆä»…è¿‡æ¸¡ç”¨ï¼Œcommit4å¯åˆ é™¤ï¼‰
    peer_.clear();
    peerIp_.clear();
    peerPort_ = 0;
    isCaller_ = false;

    // 6ï¸âƒ£ å‘é€é€šè¯ç»“æŸUIäº‹ä»¶ï¼ˆä»…é€šçŸ¥ï¼Œä¸å¼ºåˆ¶æ”¹çŠ¶æ€â€”â€”ç”±FSMå†³å®šçŠ¶æ€è¿ç§»ï¼‰
    core::UiOutCallEnded uiCallEnded{session.peerName, callEndReasonToString(reason)};
    broadcastUiOutput(core::UiOutput{uiCallEnded});
    std::cout << "[ClientCore] å‘é€é€šè¯ç»“æŸäº‹ä»¶ï¼ˆpeer: " << session.peerName << ", reason: " << callEndReasonToString(reason) << "ï¼‰" << std::endl;
}

// æ ¸å¿ƒï¼šæ€»è¾“å‡ºå¤„ç†å…¥å£ï¼Œå®ç°ä¸‰è·¯åˆ†æµ
void ClientCore::handleOutput(core::CoreOutput&& o) {
    std::visit([this](auto&& out){
        using T = std::decay_t<decltype(out)>;

        // åˆ†æµ1ï¼šå¤„ç† Executor è¾“å‡ºï¼ˆIO å‘½ä»¤ï¼‰
        if constexpr (std::is_same_v<T, core::ExecOutput>) {
            handleExecOutput(std::move(out));
        }
        // åˆ†æµ2ï¼šå¹¿æ’­ UI è¾“å‡ºï¼ˆçŠ¶æ€é€šçŸ¥ï¼‰
        else if constexpr (std::is_same_v<T, core::UiOutput>) {
            // å…ˆå¤„ç†çŠ¶æ€å˜æ›´ï¼Œæ›´æ–°å†…éƒ¨ state_
            std::visit([this](auto&& ui_out){
                using UiT = std::decay_t<decltype(ui_out)>;
                if constexpr (std::is_same_v<UiT, core::UiOutStateChanged>) {
                    std::cout << "[Core] State: "
                              << stateToString(ui_out.from)
                              << " -> "
                              << stateToString(ui_out.to)
                              << std::endl;
                    state_ = ui_out.to; // æ›´æ–°å†…éƒ¨çŠ¶æ€
                }
            }, out);
            // å¹¿æ’­ UI äº‹ä»¶ç»™æ‰€æœ‰ç›‘å¬è€…
            broadcastUiOutput(out);
        }
        // åˆ†æµ3ï¼šå¤„ç† Core å†…éƒ¨è¾…åŠ©äº‹ä»¶ï¼ˆæ— å¯¹å¤–äº¤äº’ï¼‰
        else if constexpr (std::is_same_v<T, core::InternalOutUpdateAlive>) {
            std::cout << "[Executor] Received PONG from server" << std::endl;
        }
    }, std::move(o));
}

// åˆ†æµå‡½æ•°1ï¼šå¤„ç† Executor è¾“å‡ºï¼Œåˆ†å‘åˆ°å¯¹åº” execute æ–¹æ³•
void ClientCore::handleExecOutput(core::ExecOutput&& out) {
    std::visit([this](auto&& e){
        using T = std::decay_t<decltype(e)>;

        // æŒ‰ ExecOutXXX ç±»å‹åˆ†å‘ï¼ˆè¦†ç›–æ‰€æœ‰ CoreOutput.h å®šä¹‰çš„ç±»å‹ï¼‰
        if constexpr (std::is_same_v<T, core::ExecOutConnect>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendLogin>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendPing>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSelectLan>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSelectVpn>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutLoginOk>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendText>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendCall>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendAcceptCall>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendRejectCall>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendMediaOffer>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendMediaAnswer>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutMediaReady>) {
            execute(std::move(e));
        }
        else if constexpr (std::is_same_v<T, core::ExecOutSendHangup>) {
            executor_->sendHangup();
            this->endCurrentSession(CallEndReason::UserHangup);
            std::cout << "[ClientCore] user hang up: send + end session" << std::endl;
        }
    }, std::move(out));
}

// åˆ†æµå‡½æ•°2ï¼šå¹¿æ’­ UI è¾“å‡ºï¼Œä»…å‘é€ UiOutput ç»™ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::broadcastUiOutput(const core::UiOutput& out) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    for (auto* l : listeners_) {
        if (l) { // é˜²æ­¢ç©ºæŒ‡é’ˆ
            l->onUiOutput(out); // è°ƒç”¨ç›‘å¬è€…çš„ UI å›è°ƒ
        }
    }
}

// ========== æ–°çš„ execute é‡è½½å‡½æ•°ï¼ˆé€‚é… ExecOutXXX ç±»å‹ï¼‰ ==========
void ClientCore::execute(const core::ExecOutConnect& e) {
    executor_->connectToServer(e.host, e.port);
}

void ClientCore::execute(const core::ExecOutSendLogin& e) {
    executor_->sendLoginRequest(e.user, e.pass);
}

void ClientCore::execute(const core::ExecOutSendPing& e) {
    (void)e; // æ¶ˆé™¤æœªä½¿ç”¨å‚æ•°è­¦å‘Š
    executor_->sendPing();
}

void ClientCore::execute(const core::ExecOutSelectLan& e) {
    (void)e; // æ¶ˆé™¤æœªä½¿ç”¨å‚æ•°è­¦å‘Š
    std::cout << "[Executor] Select LAN" << std::endl;
    executor_->setLanMode();
}

void ClientCore::execute(const core::ExecOutSelectVpn& e) {
    (void)e; // æ¶ˆé™¤æœªä½¿ç”¨å‚æ•°è­¦å‘Š
    std::cout << "[Executor] Select VPN" << std::endl;
    executor_->setVpnMode();
}

void ClientCore::execute(const core::ExecOutLoginOk& e) {
    (void)e; // æ¶ˆé™¤æœªä½¿ç”¨å‚æ•°è­¦å‘Š
    std::cout << "[Executor] ExecOutLoginOk: Send local IP to server" << std::endl;
    executor_->sendLocalIP();
}

void ClientCore::execute(const core::ExecOutSendText& e) {
    executor_->sendTextMsg(e.target_user, e.content);
}

void ClientCore::execute(const core::ExecOutSendCall& e) {
    // ç¬¬ä¸€æ­¥ï¼šå…ˆå†™å…¥ CallSessionï¼ˆå”¯ä¸€çœŸç›¸æºï¼‰
    if (current_call_session_.has_value()) {
        auto& session = current_call_session_.value();
        session.peerName = e.target_user; // å†™å…¥ peerName
        session.isCaller = true;          // å†™å…¥ isCaller
        session.currentCallState = CallState::Calling; // åŒæ­¥çŠ¶æ€
    }

    // ç¬¬äºŒæ­¥ï¼šåŒæ­¥åˆ°æ—§å­—æ®µï¼ˆä¿ç•™åŸæœ‰é€»è¾‘ï¼Œä¸åˆ é™¤ï¼‰
    isCaller_ = true;
    peer_ = e.target_user; // è¡¥å……ï¼šåŸæœ‰ä»£ç æœªå†™ peer_ï¼Œè¿™é‡Œè¡¥ä¸Šä»¥åŒæ­¥

    // åŸæœ‰é€»è¾‘ï¼šè°ƒç”¨ executor å‘é€å‘¼å«
    executor_->sendCallRequest(e.target_user);
}

void ClientCore::execute(const core::ExecOutSendAcceptCall& e) {
    (void)e;
    executor_->sendAcceptCall();

    // æ–°å¢ï¼šæ›´æ–°SessionçŠ¶æ€ï¼ˆå”¯ä¸€çœŸç›¸æºï¼‰
    if (current_call_session_.has_value()) {
        auto& session = current_call_session_.value();
        session.currentCallState = CallState::InCall; // æ ‡è®°ä¸ºâ€œé€šè¯ä¸­â€
        std::cout << "[ClientCore] Accept call: Session state updated to InCall (sessionId: " << session.sessionId << ")" << std::endl;
    }
}

void ClientCore::execute(const core::ExecOutSendRejectCall& e) {
    (void)e;
    executor_->sendRejectCall();

    // æ–°å¢ï¼šæ‹’ç»é€šè¯ç›´æ¥ç»“æŸSessionï¼ˆç»Ÿä¸€èµ°endCurrentSessionï¼‰
    endCurrentSession(CallEndReason::UserReject);
    std::cout << "[ClientCore] Reject call: Session ended" << std::endl;
}

void ClientCore::execute(const core::ExecOutSendMediaOffer& e) {
    executor_->sendMediaOffer(e.peer);
}

void ClientCore::execute(const core::ExecOutSendMediaAnswer& e) {
    executor_->sendMediaAnswer(e.peer);
}

void ClientCore::execute(const core::ExecOutSendHangup& e) {
    (void)e; // æ¶ˆé™¤æœªä½¿ç”¨å‚æ•°è­¦å‘Š
    executor_->sendHangup();
}

void ClientCore::execute(const core::ExecOutMediaReady& e) {
    // 1. è®¡ç®—æœ€ç»ˆPeer IP/Portï¼ˆä»…è®¡ç®—ï¼Œä¸ç›´æ¥å†™å…¥æ—§å­—æ®µï¼‰
    std::string peerIp = executor_->selectPeerIp(e.lanIp, e.vpnIp);
    int peerPort = e.peerPort;

    // 2. ä¼˜å…ˆå†™å…¥Sessionï¼ˆå”¯ä¸€çœŸç›¸æºï¼‰
    if (current_call_session_.has_value()) {
        auto& session = current_call_session_.value();
        session.peerIp = peerIp;
        session.peerPort = peerPort;
        session.currentCallState = CallState::MediaReady;
        std::cout << "[ClientCore] MediaReady: Session updated (peerIp: " << peerIp << ", port: " << peerPort << ")" << std::endl;
    }

    // 3. åŒæ­¥åˆ°æ—§å­—æ®µï¼ˆä»…é•œåƒï¼Œç¦æ­¢ç›´æ¥ä¿®æ”¹ï¼‰
    peerIp_ = peerIp;
    peerPort_ = peerPort;

    // 4. åŸæœ‰é€»è¾‘ï¼šæ„å»ºUIè¾“å‡ºï¼ˆæ•°æ®æ¥è‡ªSessionçš„é•œåƒï¼‰
    std::cout << "[ClientCore] MediaReady -> use IP: " << peerIp_ << ":" << peerPort_ << std::endl;
    core::UiOutMediaReadyFinal uiMediaReadyFinal{peerIp_, peerPort_};
    broadcastUiOutput(core::UiOutput{uiMediaReadyFinal});
}

========== ./core/FSM.h ==========
Lines: 36

// core/FSM.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "ClientState.h"
#include <vector>
#include <functional>
#include "ClientEventEnum.h"
#include <variant>
#include <iostream>

struct FSMEntry {
    State current_state;
    EventType event_type;
    // è¡¥å…… core:: å‰ç¼€
    std::function<std::vector<core::CoreOutput>(
        State current,
        const core::CoreInput&
        )> action;
    State next_state;
};

class FSM {
public:
    FSM();

    // è¡¥å…… core:: å‰ç¼€
    std::vector<core::CoreOutput>
    handle(State current, const core::CoreInput& ev);

private:
    EventType eventTypeFromInput(const core::CoreInput& ev);
    bool isOnlineState(State s);
    std::vector<FSMEntry> table_;
    void initTable();
};

========== ./core/CoreInput.h ==========
Lines: 126

// core/CoreInput.h
#pragma once
#include <variant>
#include <string>
#include <vector>
namespace core {

struct OnlineUser {
    std::string name;
    int privilege;

    std::string lan_ip;   // å±€åŸŸç½‘ IP
    std::string vpn_ip;   // VPN IPï¼ˆæœªæ¥å¯ç”¨ï¼‰
    int media_port;       // GStreamer/UDP è§†é¢‘ç«¯å£
};


struct InCmdSendText { std::string target_user; std::string content; };

struct InForwardText { std::string from_user; std::string content; };

// æ‰€æœ‰ Core è¾“å…¥äº‹ä»¶å‰ç¼€æ”¹ä¸º In
struct InCmdConnect { std::string host; int port; };
struct InCmdDisconnect {};
struct InCmdLogin { std::string user; std::string pass; };
struct InTcpConnected {};
struct InTcpDisconnected {};
struct InLoginOk {};
struct InLoginFail { std::string msg; };
struct InOnlineUsers { std::vector<OnlineUser> users; };
struct InUnknow {};
struct InHeartbeatOk {};      // æ”¶åˆ° PONG
struct InHeartbeatTimeout {}; // å¿ƒè·³è¶…æ—¶
struct InHeartbeatTick {};    // Send PING
struct InSelectLan {};
struct InSelectVpn {};

// å‘èµ·å‘¼å«
struct InCmdCall { std::string target_user; };
// æ”¶åˆ°æ¥ç”µ
struct InCallIncoming { std::string from; };
// é€šè¯è¢«æ¥å¬
struct InCallAccepted { std::string peer; };
// é€šè¯è¢«æ‹’ç»
struct InCallRejected { std::string peer; };
// ç”¨æˆ·æ¥å¬/æ‹’ç»é€šè¯
struct InCmdAcceptCall {};
struct InCmdRejectCall {};
// åª’ä½“åå•†å“åº”
struct InMediaPeer {
    std::string peer;
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};

// ç”¨æˆ·ä¸»åŠ¨ç‚¹å‡»æŒ‚æ–­ï¼ˆUIè§¦å‘ï¼‰
struct InCmdHangup {};

// æ”¶åˆ°æœåŠ¡ç«¯é€šçŸ¥ï¼ˆå¯¹ç«¯æŒ‚æ–­/æœåŠ¡å™¨å›æ”¶ï¼‰
struct InCallEnded {
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    std::string reason;  // æŒ‚æ–­åŸå› ï¼š"peer_hangup" / "server_timeout"
};

using CoreInput = std::variant<
    InCmdConnect,
    InCmdDisconnect,
    InCmdLogin,
    InTcpConnected,
    InTcpDisconnected,
    InLoginOk,
    InLoginFail,
    InOnlineUsers,
    InUnknow,
    InHeartbeatOk,
    InHeartbeatTimeout,
    InHeartbeatTick,
    InSelectLan,
    InSelectVpn,
    InCmdSendText,
    InForwardText,
    InCmdCall,
    InCallIncoming,
    InCallAccepted,
    InCallRejected,
    InCmdAcceptCall,
    InCmdRejectCall,
    InMediaPeer,
    InCmdHangup,
    InCallEnded
    >;


inline std::string CoreInputIndexToName(size_t index) {
    // ä¸¥æ ¼æŒ‰ç…§CoreInput variantçš„ç±»å‹é¡ºåºæ˜ å°„ç´¢å¼•å’Œåç§°
    switch (index) {
    case 0:  return "InCmdConnect";
    case 1:  return "InCmdDisconnect";
    case 2:  return "InCmdLogin";
    case 3:  return "InTcpConnected";
    case 4:  return "InTcpDisconnected";
    case 5:  return "InLoginOk";
    case 6:  return "InLoginFail";
    case 7:  return "InOnlineUsers";
    case 8:  return "InUnknow";
    case 9:  return "InHeartbeatOk";
    case 10: return "InHeartbeatTimeout";
    case 11: return "InHeartbeatTick";
    case 12: return "InSelectLan";
    case 13: return "InSelectVpn";
    case 14: return "InCmdSendText";
    case 15: return "InForwardText";
    case 16: return "InCmdCall";
    case 17: return "InCallIncoming";
    case 18: return "InCallAccepted";
    case 19: return "InCallRejected";
    case 20: return "InCmdAcceptCall";
    case 21: return "InCmdRejectCall";
    case 22: return "InMediaPeer";
    // å…œåº•ï¼šç´¢å¼•è¶…å‡ºèŒƒå›´æ—¶è¿”å›æç¤ºï¼ˆé˜²æ­¢æ–°å¢ç±»å‹æœªæ›´æ–°å‡½æ•°ï¼‰
    default: return "InUnknownCoreInputType";
    }
}

}

========== ./core/FSM.cpp ==========
Lines: 601

// core/FSM.cpp
#include "FSM.h"
#include "CoreOutput.h"
#include <set>
#include <iostream>

FSM::FSM() {
    initTable();
}

bool FSM::isOnlineState(State s) {
    return s != State::Disconnected;
}

// è¡¥å…… core:: å‰ç¼€ï¼Œè¿”å›ç¬¦åˆæ–°è¯­ä¹‰è§„èŒƒçš„ CoreOutput åˆ—è¡¨
std::vector<core::CoreOutput>
FSM::handle(State current, const core::CoreInput& ev)
{
    EventType evType = eventTypeFromInput(ev);
    std::cout << "[FSM] Current state: " << stateToString(current)
              << ", Received event type: " << EventTypeToString(evType) << std::endl;
    if (isOnlineState(current) && evType == EventType::HeartbeatTick) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨ï¼šOutSendPing å¯¹åº” ExecOutSendPingï¼ŒåŒ…è£¹è¿› ExecOutput
        std::cout << "[FSM] Online state, directly handle HeartbeatTick event" << std::endl;
        core::ExecOutSendPing execSendPing;
        return { core::ExecOutput{execSendPing} };
    }

    else if (isOnlineState(current) && evType == EventType::HeartbeatOk) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨ï¼šOutUpdateAlive å¯¹åº” InternalOutUpdateAliveï¼Œç›´æ¥ä½œä¸º CoreOutput
        core::InternalOutUpdateAlive internalUpdateAlive;
        return { internalUpdateAlive };
    }

    if (isOnlineState(current)) {
        // å®šä¹‰éœ€è¦ç»Ÿä¸€å¤„ç†çš„æ‰çº¿äº‹ä»¶ç±»å‹
        std::set<EventType> disconnectEvents = {
            EventType::TcpDisconnected,  // TCPé“¾è·¯æ–­å¼€
            EventType::HeartbeatTimeout   // å¿ƒè·³è¶…æ—¶ï¼ˆè§¦å‘ä¸»åŠ¨æ–­çº¿ï¼‰
        };

        if (disconnectEvents.count(evType) > 0) {
            std::cout << "[FSM] Online state, directly handle disconnect event: " << EventTypeToString(evType) << std::endl;
            // ç»Ÿä¸€è¿”å›æ‰çº¿è¾“å‡ºï¼Œæ‰€æœ‰åœ¨çº¿çŠ¶æ€æ‰çº¿éƒ½åˆ‡æ¢åˆ°Disconnected
            // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
            // 2. æ‰çº¿é€šçŸ¥ï¼šUiOutDisconnected åŒ…è£¹è¿› UiOutput
            std::vector<core::CoreOutput> out;
            core::UiOutStateChanged uiStateChange{current, State::Disconnected};
            core::UiOutDisconnected uiDisconnected;
            out.push_back(core::UiOutput{uiStateChange});
            out.push_back(core::UiOutput{uiDisconnected});
            return out;
        }
    }

    for (auto& entry : table_) {
        if (entry.current_state == current &&
            entry.event_type == evType) {

            auto outputs = entry.action(current, ev);
            return outputs;
        }
    }
    return {};
}

EventType FSM::eventTypeFromInput(const core::CoreInput& ev) {
    EventType evType = EventType::Unknow;
    std::visit([&evType](auto&& e){
        using T = std::decay_t<decltype(e)>;
        if constexpr (std::is_same_v<T, core::InCmdConnect>)      evType = EventType::CmdConnect;
        else if constexpr (std::is_same_v<T, core::InCmdDisconnect>) evType = EventType::CmdDisconnect;
        else if constexpr (std::is_same_v<T, core::InCmdLogin>)   evType = EventType::CmdLogin;

        else if constexpr (std::is_same_v<T, core::InTcpConnected>)    evType = EventType::TcpConnected;
        else if constexpr (std::is_same_v<T, core::InTcpDisconnected>) evType = EventType::TcpDisconnected;

        else if constexpr (std::is_same_v<T, core::InLoginOk>)   evType = EventType::LoginOk;
        else if constexpr (std::is_same_v<T, core::InLoginFail>) evType = EventType::LoginFail;
        else if constexpr (std::is_same_v<T, core::InOnlineUsers>) evType = EventType::OnlineUsers;

        else if constexpr (std::is_same_v<T, core::InHeartbeatOk>)
            evType = EventType::HeartbeatOk;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTimeout>)
            evType = EventType::HeartbeatTimeout;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTick>)
            evType = EventType::HeartbeatTick;

        else if constexpr (std::is_same_v<T, core::InSelectLan>)
            evType = EventType::SelectLan;

        else if constexpr (std::is_same_v<T, core::InSelectVpn>)
            evType = EventType::SelectVpn;

        else if constexpr (std::is_same_v<T, core::InCmdSendText>)
            evType = EventType::CmdSendText;

        else if constexpr (std::is_same_v<T, core::InForwardText>)
            evType = EventType::ForwardText;

        else if constexpr (std::is_same_v<T, core::InCmdCall>)
            evType = EventType::CmdCall;
        else if constexpr (std::is_same_v<T, core::InCallIncoming>)
            evType = EventType::CallIncoming;
        else if constexpr (std::is_same_v<T, core::InCallAccepted>)
            evType = EventType::CallAccepted;
        else if constexpr (std::is_same_v<T, core::InCallRejected>)
            evType = EventType::CallRejected;
        else if constexpr (std::is_same_v<T, core::InCmdAcceptCall>)
            evType = EventType::CmdAcceptCall;
        else if constexpr (std::is_same_v<T, core::InCmdRejectCall>)
            evType = EventType::CmdRejectCall;
        else if constexpr (std::is_same_v<T, core::InMediaPeer>)
            evType = EventType::MediaPeer;
        else if constexpr (std::is_same_v<T, core::InCmdHangup>)
            evType = EventType::CmdHangup;
        else if constexpr (std::is_same_v<T, core::InCallEnded>)
            evType = EventType::CallEnded;

        else evType = EventType::Unknow;
    }, ev);
    return evType;
}

void FSM::initTable() {
    table_ = {
        // ===== æ–­å¼€æ€ =====
        { State::Disconnected, EventType::CmdConnect,
            // è¡¥å…… core:: å‰ç¼€ï¼ŒæŒ‰æ–°è¯­ä¹‰è§„èŒƒæ„å»ºè¾“å‡º
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // æ›¿æ¢ä¸º InCmdConnectï¼Œæ„å»º UiOutput å’Œ ExecOutput
                if (auto e = std::get_if<core::InCmdConnect>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::Connecting};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. è¿æ¥å‘½ä»¤ï¼šExecOutConnect åŒ…è£¹è¿› ExecOutput
                    core::ExecOutConnect execConnect{e->host, e->port};
                    out.push_back(core::ExecOutput{execConnect});
                }
                return out;
            },
            State::Connecting
        },

        // ===== æ­£åœ¨è¿æ¥ =====
        { State::Connecting, EventType::TcpConnected,
            // è¡¥å…… core:: å‰ç¼€ï¼ŒæŒ‰æ–°è¯­ä¹‰è§„èŒƒæ„å»ºè¾“å‡º
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // æ›¿æ¢ä¸º InTcpConnectedï¼Œæ„å»º UiOutputï¼ˆçŠ¶æ€å˜æ›´ï¼‰
                if (auto e = std::get_if<core::InTcpConnected>(&ev)) {
                    core::UiOutStateChanged uiStateChange{cur, State::Connected};
                    out.push_back(core::UiOutput{uiStateChange});
                }
                return out;
            },
            State::Connected
        },

        { State::Connecting, EventType::TcpDisconnected,
            // è¡¥å…… core:: å‰ç¼€ï¼Œæ— è¾“å‡ºï¼ˆç©ºåˆ—è¡¨ï¼‰
            [](State cur, const core::CoreInput&){ return std::vector<core::CoreOutput>{}; },
            State::Disconnected
        },

        // ===== å·²è¿æ¥ =====
        { State::Connected, EventType::CmdLogin,
            // è¡¥å…… core:: å‰ç¼€ï¼ŒæŒ‰æ–°è¯­ä¹‰è§„èŒƒæ„å»ºè¾“å‡º
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // æ›¿æ¢ä¸º InCmdLoginï¼Œæ„å»º UiOutput å’Œ ExecOutput
                if (auto e = std::get_if<core::InCmdLogin>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::LoggingIn};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. å‘é€ç™»å½•å‘½ä»¤ï¼šExecOutSendLogin åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendLogin execSendLogin{e->user, e->pass};
                    out.push_back(core::ExecOutput{execSendLogin});
                }
                return out;
            },
            State::LoggingIn
        },

        // ===== æ­£åœ¨ç™»å½• =====
        { State::LoggingIn, EventType::LoginOk ,
            // è¡¥å…… core:: å‰ç¼€ï¼ŒæŒ‰æ–°è¯­ä¹‰è§„èŒƒæ„å»ºè¾“å‡º
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // æ›¿æ¢ä¸º InLoginOkï¼Œæ„å»º ExecOutput å’Œä¸¤ä¸ª UiOutput
                if (auto e = std::get_if<core::InLoginOk>(&ev)) {
                    // 1. é€šçŸ¥ Executor å‘é€æœ¬åœ° IPï¼šExecOutLoginOk åŒ…è£¹è¿› ExecOutput
                    core::ExecOutLoginOk execLoginOk;
                    out.push_back(core::ExecOutput{execLoginOk});

                    // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 3. é€šçŸ¥ UI ç™»å½•æˆåŠŸï¼šUiOutLoginOk åŒ…è£¹è¿› UiOutput
                    core::UiOutLoginOk uiLoginOk;
                    out.push_back(core::UiOutput{uiLoginOk});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggingIn, EventType::LoginFail ,
            // è¡¥å…… core:: å‰ç¼€ï¼ŒæŒ‰æ–°è¯­ä¹‰è§„èŒƒæ„å»ºè¾“å‡º
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // æ›¿æ¢ä¸º InLoginFailï¼Œæ„å»º UiOutputï¼ˆç™»å½•å¤±è´¥+çŠ¶æ€å˜æ›´ï¼‰
                if (auto e = std::get_if<core::InLoginFail>(&ev)) {
                    // 1. é€šçŸ¥ UI ç™»å½•å¤±è´¥ï¼šUiOutLoginFail åŒ…è£¹è¿› UiOutput
                    core::UiOutLoginFail uiLoginFail{e->msg};
                    out.push_back(core::UiOutput{uiLoginFail});

                    // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::Connected};
                    out.push_back(core::UiOutput{uiStateChange});
                }
                return out;
            },
            State::Connected
        },

        { State::LoggedIn, EventType::OnlineUsers,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InOnlineUsers>(&ev)) {
                    // é€šçŸ¥ UI æ›´æ–°åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼šUiOutOnlineUsers åŒ…è£¹è¿› UiOutput
                    core::UiOutOnlineUsers uiOnlineUsers{e->users};
                    out.push_back(core::UiOutput{uiOnlineUsers});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::SelectLan,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InSelectLan>(&ev)) {
                    // é€šçŸ¥ Executor é€‰æ‹© LANï¼šExecOutSelectLan åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSelectLan execSelectLan;
                    out.push_back(core::ExecOutput{execSelectLan});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::SelectVpn,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InSelectVpn>(&ev)) {
                    // é€šçŸ¥ Executor é€‰æ‹© VPNï¼šExecOutSelectVpn åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSelectVpn execSelectVpn;
                    out.push_back(core::ExecOutput{execSelectVpn});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::CmdSendText,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdSendText>(&ev)) {
                    // é€šçŸ¥ Executor å‘é€æ–‡æœ¬ï¼šExecOutSendText åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendText execSendText{e->target_user, e->content};
                    out.push_back(core::ExecOutput{execSendText});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::ForwardText,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InForwardText>(&ev)) {
                    // é€šçŸ¥ UI æ˜¾ç¤ºè½¬å‘æ–‡æœ¬ï¼šUiOutForwardText åŒ…è£¹è¿› UiOutput
                    core::UiOutForwardText uiForwardText{e->from_user, e->content};
                    out.push_back(core::UiOutput{uiForwardText});
                }
                return out;
            },
            State::LoggedIn
        },

        // 1. LoggedInçŠ¶æ€ä¸‹å‘èµ·å‘¼å«
        { State::LoggedIn, EventType::CmdCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdCall>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::CALLING};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ Executor å‘é€å‘¼å«ï¼šExecOutSendCall åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendCall execSendCall{e->target_user};
                    out.push_back(core::ExecOutput{execSendCall});
                }
                return out;
            },
            State::CALLING
        },

        // 2. LoggedInçŠ¶æ€ä¸‹æ”¶åˆ°æ¥ç”µ
        { State::LoggedIn, EventType::CallIncoming,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallIncoming>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::RINGING};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ UI æ˜¾ç¤ºæ¥ç”µï¼šUiOutShowIncomingCall åŒ…è£¹è¿› UiOutput
                    core::UiOutShowIncomingCall uiShowIncomingCall{e->from};
                    out.push_back(core::UiOutput{uiShowIncomingCall});
                }
                return out;
            },
            State::RINGING
        },

        // 3. RINGINGçŠ¶æ€ä¸‹ç”¨æˆ·æ¥å¬
        { State::RINGING, EventType::CmdAcceptCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdAcceptCall>(&ev))
                {
                    // é€šçŸ¥ Executor å‘é€æ¥å¬å‘½ä»¤ï¼šExecOutSendAcceptCall åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendAcceptCall execSendAcceptCall;
                    out.push_back(core::ExecOutput{execSendAcceptCall});
                }
                return out;
            },
            State::RINGING
        },

        // 4. RINGINGçŠ¶æ€ä¸‹ç”¨æˆ·æ‹’ç»
        { State::RINGING, EventType::CmdRejectCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdRejectCall>(&ev))
                {
                    // 1. é€šçŸ¥ Executor å‘é€æ‹’ç»å‘½ä»¤ï¼šExecOutSendRejectCall åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendRejectCall execSendRejectCall;
                    out.push_back(core::ExecOutput{execSendRejectCall});

                    // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                    out.push_back(core::UiOutput{uiStateChange});
                }
                return out;
            },
            State::LoggedIn
        },

        // 5. CALLING/RINGINGçŠ¶æ€ä¸‹æ”¶åˆ°é€šè¯è¢«æ¥å¬
        { State::CALLING, EventType::CallAccepted,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallAccepted>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::IN_CALL};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ Executor å‘é€åª’ä½“ Offerï¼šExecOutSendMediaOffer åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendMediaOffer execSendMediaOffer{e->peer};
                    out.push_back(core::ExecOutput{execSendMediaOffer});
                }
                return out;
            },
            State::IN_CALL
        },

        { State::CALLING, EventType::MediaPeer,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InMediaPeer>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::MEDIA_READY};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ Executor åª’ä½“å°±ç»ªï¼ˆé€‰æ‹© IPï¼‰ï¼šExecOutMediaReady åŒ…è£¹è¿› ExecOutput
                    core::ExecOutMediaReady execMediaReady{e->lanIp, e->vpnIp, e->udpPort};
                    out.push_back(core::ExecOutput{execMediaReady});

                    // 3. é€šçŸ¥ Executor å‘é€åª’ä½“ Answerï¼šExecOutSendMediaAnswer åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendMediaAnswer execSendMediaAnswer{e->peer};
                    out.push_back(core::ExecOutput{execSendMediaAnswer});
                }
                return out;
            },
            State::MEDIA_READY
        },

        { State::RINGING, EventType::CallAccepted,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallAccepted>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::IN_CALL};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ Executor å‘é€åª’ä½“ Offerï¼šExecOutSendMediaOffer åŒ…è£¹è¿› ExecOutput
                    core::ExecOutSendMediaOffer execSendMediaOffer{e->peer};
                    out.push_back(core::ExecOutput{execSendMediaOffer});
                }
                return out;
            },
            State::IN_CALL
        },

        // 6. CALLINGçŠ¶æ€ä¸‹æ”¶åˆ°é€šè¯è¢«æ‹’ç»
        { State::CALLING, EventType::CallRejected,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});
                return out;
            },
            State::LoggedIn
        },

        // 7. IN_CALLçŠ¶æ€ä¸‹æ”¶åˆ°åª’ä½“ä¿¡æ¯
        { State::IN_CALL, EventType::MediaPeer,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InMediaPeer>(&ev)) {
                    // 1. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                    core::UiOutStateChanged uiStateChange{cur, State::MEDIA_READY};
                    out.push_back(core::UiOutput{uiStateChange});

                    // 2. é€šçŸ¥ Executor åª’ä½“å°±ç»ªï¼ˆé€‰æ‹© IPï¼‰ï¼šExecOutMediaReady åŒ…è£¹è¿› ExecOutput
                    core::ExecOutMediaReady execMediaReady{e->lanIp, e->vpnIp, e->udpPort};
                    out.push_back(core::ExecOutput{execMediaReady});
                }
                return out;
            },
            State::MEDIA_READY
        },

        // ===== æ–°å¢ï¼šä¸»åŠ¨æŒ‚æ–­ï¼ˆCmdHangupï¼‰=====
        // 1. CALLINGçŠ¶æ€ä¸‹ä¸»åŠ¨æŒ‚æ–­
        { State::CALLING, EventType::CmdHangup,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // 1. é€šçŸ¥ Executor å‘é€æŒ‚æ–­å‘½ä»¤ï¼šExecOutSendHangup åŒ…è£¹è¿› ExecOutput
                core::ExecOutSendHangup execSendHangup;
                out.push_back(core::ExecOutput{execSendHangup});

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                return out;
            },
            State::LoggedIn
        },

        // 2. RINGINGçŠ¶æ€ä¸‹ä¸»åŠ¨æŒ‚æ–­
        { State::RINGING, EventType::CmdHangup,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // 1. é€šçŸ¥ Executor å‘é€æŒ‚æ–­å‘½ä»¤ï¼šExecOutSendHangup åŒ…è£¹è¿› ExecOutput
                core::ExecOutSendHangup execSendHangup;
                out.push_back(core::ExecOutput{execSendHangup});

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                return out;
            },
            State::LoggedIn
        },

        // 3. IN_CALLçŠ¶æ€ä¸‹ä¸»åŠ¨æŒ‚æ–­
        { State::IN_CALL, EventType::CmdHangup,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // 1. é€šçŸ¥ Executor å‘é€æŒ‚æ–­å‘½ä»¤ï¼šExecOutSendHangup åŒ…è£¹è¿› ExecOutput
                core::ExecOutSendHangup execSendHangup;
                out.push_back(core::ExecOutput{execSendHangup});

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                return out;
            },
            State::LoggedIn
        },

        // 4. MEDIA_READYçŠ¶æ€ä¸‹ä¸»åŠ¨æŒ‚æ–­ï¼ˆæ ¸å¿ƒï¼Œå½“å‰é€šè¯çš„æœ€ç»ˆçŠ¶æ€ï¼‰
        { State::MEDIA_READY, EventType::CmdHangup,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                // 1. é€šçŸ¥ Executor å‘é€æŒ‚æ–­å‘½ä»¤ï¼šExecOutSendHangup åŒ…è£¹è¿› ExecOutput
                core::ExecOutSendHangup execSendHangup;
                out.push_back(core::ExecOutput{execSendHangup});

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                return out;
            },
            State::LoggedIn
        },

        // ===== æ–°å¢ï¼šè¢«åŠ¨æŒ‚æ–­ï¼ˆCallEndedï¼Œæ”¶åˆ°æœåŠ¡ç«¯é€šçŸ¥ï¼‰=====
        // 1. CALLINGçŠ¶æ€ä¸‹æ”¶åˆ°è¢«åŠ¨æŒ‚æ–­
        { State::CALLING, EventType::CallEnded,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                auto& e = std::get<core::InCallEnded>(ev);

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                // // 3. é€šçŸ¥ UI é€šè¯ç»“æŸï¼šUiOutCallEnded åŒ…è£¹è¿› UiOutput
                // core::UiOutCallEnded uiCallEnded{e.peer, e.reason};
                // out.push_back(core::UiOutput{uiCallEnded});

                return out;
            },
            State::LoggedIn
        },

        // 2. RINGINGçŠ¶æ€ä¸‹æ”¶åˆ°è¢«åŠ¨æŒ‚æ–­
        { State::RINGING, EventType::CallEnded,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                auto& e = std::get<core::InCallEnded>(ev);

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                // // 3. é€šçŸ¥ UI é€šè¯ç»“æŸï¼šUiOutCallEnded åŒ…è£¹è¿› UiOutput
                // core::UiOutCallEnded uiCallEnded{e.peer, e.reason};
                // out.push_back(core::UiOutput{uiCallEnded});

                return out;
            },
            State::LoggedIn
        },

        // 3. IN_CALLçŠ¶æ€ä¸‹æ”¶åˆ°è¢«åŠ¨æŒ‚æ–­
        { State::IN_CALL, EventType::CallEnded,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                auto& e = std::get<core::InCallEnded>(ev);

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                // // 3. é€šçŸ¥ UI é€šè¯ç»“æŸï¼šUiOutCallEnded åŒ…è£¹è¿› UiOutput
                // core::UiOutCallEnded uiCallEnded{e.peer, e.reason};
                // out.push_back(core::UiOutput{uiCallEnded});

                return out;
            },
            State::LoggedIn
        },

        // 4. MEDIA_READYçŠ¶æ€ä¸‹æ”¶åˆ°è¢«åŠ¨æŒ‚æ–­ï¼ˆæ ¸å¿ƒï¼‰
        { State::MEDIA_READY, EventType::CallEnded,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                auto& e = std::get<core::InCallEnded>(ev);

                // 2. çŠ¶æ€å˜æ›´ï¼šUiOutStateChanged åŒ…è£¹è¿› UiOutput
                core::UiOutStateChanged uiStateChange{cur, State::LoggedIn};
                out.push_back(core::UiOutput{uiStateChange});

                // // 3. é€šçŸ¥ UI é€šè¯ç»“æŸï¼šUiOutCallEnded åŒ…è£¹è¿› UiOutput
                // core::UiOutCallEnded uiCallEnded{e.peer, e.reason};
                // out.push_back(core::UiOutput{uiCallEnded});

                return out;
            },
            State::LoggedIn
        }

    };
}

========== ./core/ClientCore.h ==========
Lines: 106

//core/ClientCore.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "FSM.h"
#include "ClientState.h"
#include "CoreExecutor.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <memory>
#include "ICoreListener.h"
#include <vector>
#include <atomic> // è¡¥å…… atomic å¤´æ–‡ä»¶ï¼Œæ”¯æŒ std::atomic
#include "CallSession.h"
#include <optional> // ç”¨äº optional<CallSession>

enum class CallEndReason {
    UserHangup,        // ç”¨æˆ·ä¸»åŠ¨æŒ‚æ–­
    UserReject,        // ç”¨æˆ·æ‹’ç»é€šè¯
    PeerHangup,        // å¯¹ç«¯æŒ‚æ–­
    NetworkError,      // ç½‘ç»œé”™è¯¯
    MediaError,        // åª’ä½“é”™è¯¯
    ServerTimeout,     // æœåŠ¡ç«¯è¶…æ—¶
    Unknown            // æœªçŸ¥åŸå› 
};

// è¾…åŠ©å‡½æ•°ï¼šæšä¸¾è½¬å­—ç¬¦ä¸²ï¼ˆæ–¹ä¾¿æ—¥å¿—ï¼‰
inline std::string callEndReasonToString(CallEndReason reason) {
    switch (reason) {
    case CallEndReason::UserHangup: return "UserHangup";
    case CallEndReason::UserReject: return "UserReject";
    case CallEndReason::PeerHangup: return "PeerHangup";
    case CallEndReason::NetworkError: return "NetworkError";
    case CallEndReason::MediaError: return "MediaError";
    case CallEndReason::ServerTimeout: return "ServerTimeout";
    default: return "Unknown";
    }
}

class ClientCore {
public:
    ClientCore();
    ~ClientCore();

    // çº¿ç¨‹å®‰å…¨æ¥å£ï¼ˆå¯¹å¤–æš´éœ²ï¼‰
    void postInput(core::CoreInput ev);
    void stop();
    // ç›‘å¬è€…ç®¡ç†ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
    void addListener(core::ICoreListener* listener);   // æ–°å¢
    void removeListener(core::ICoreListener* listener);// æ–°å¢

    int getMediaPort() const {
        return executor_->getMediaPort();
    }

private:
    FSM fsm_;
    State state_ = State::Disconnected;
    std::unique_ptr<CoreExecutor> executor_;

    // çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ï¼ˆä»…ä¿ç•™è¾“å…¥é˜Ÿåˆ—ï¼Œè¾“å‡ºé˜Ÿåˆ—åºŸå¼ƒç§»é™¤ï¼‰
    std::queue<core::CoreInput>  inputQueue_;
    std::mutex mtx_;
    std::condition_variable cv_;

    // ç›‘å¬è€…ç®¡ç†ï¼ˆæ–°å¢ï¼‰
    std::vector<core::ICoreListener*> listeners_;
    std::mutex listener_mtx_;  // ç›‘å¬è€…æ“ä½œçš„çº¿ç¨‹å®‰å…¨é”

    std::optional<CallSession> current_call_session_;

    // é€šè¯ç›¸å…³æˆå‘˜å˜é‡ï¼ˆä»…ä½œä¸ºCallSessionçš„é•œåƒï¼Œç¦æ­¢ç›´æ¥å†™å…¥ï¼Œä»…ä»SessionåŒæ­¥ï¼‰    std::string peer_;          // é€šè¯å¯¹æ–¹ç”¨æˆ·å
    std::string peer_;          // é€šè¯å¯¹æ–¹ç”¨æˆ·å
    std::string peerIp_;        // å¯¹æ–¹åª’ä½“IP
    int peerPort_ = 0;          // å¯¹æ–¹åª’ä½“ç«¯å£
    bool isCaller_ = false;     // æ˜¯å¦ä¸ºä¸»åŠ¨å‘¼å«æ–¹

    // æ ¸å¿ƒæ–¹æ³•ï¼ˆé€‚é…æ–°è¯­ä¹‰ç±»å‹ï¼‰
    void processEvents();
    void handleOutput(core::CoreOutput&& o); // æ€»è¾“å‡ºå¤„ç†å…¥å£
    void handleExecOutput(core::ExecOutput&& out); // å¤„ç† Executor è¾“å‡ºï¼ˆIO å‘½ä»¤ï¼‰
    void broadcastUiOutput(const core::UiOutput& out); // å¹¿æ’­ UI è¾“å‡ºï¼ˆçŠ¶æ€é€šçŸ¥ï¼‰


    void endCurrentSession(CallEndReason reason = CallEndReason::Unknown);
    // æ–°çš„ execute é‡è½½å‡½æ•°ï¼ˆé€‚é… ExecOutXXX ç±»å‹ï¼‰
    void execute(const core::ExecOutConnect& e);
    void execute(const core::ExecOutSendLogin& e);
    void execute(const core::ExecOutSendPing& e);
    void execute(const core::ExecOutSelectLan& e);
    void execute(const core::ExecOutSelectVpn& e);
    void execute(const core::ExecOutLoginOk& e);
    void execute(const core::ExecOutSendText& e);
    void execute(const core::ExecOutSendCall& e);
    void execute(const core::ExecOutSendAcceptCall& e);
    void execute(const core::ExecOutSendRejectCall& e);
    void execute(const core::ExecOutSendMediaOffer& e);
    void execute(const core::ExecOutSendMediaAnswer& e);
    void execute(const core::ExecOutMediaReady& e);
    void execute(const core::ExecOutSendHangup& e);

    // åŸå­å˜é‡ï¼šæ§åˆ¶äº‹ä»¶å¤„ç†çº¿ç¨‹è¿è¡ŒçŠ¶æ€
    std::atomic<bool> is_running_{true};
};

========== ./core/CoreExecutor.cpp ==========
Lines: 217

//CoreExecutor.cpp
#include "CoreExecutor.h"
#include "ClientEventFactory.h"
#include <thread>
#include <iostream>
#include "./util/GetLocalIP.h"
#include "./util/PortUtils.h"

CoreExecutor::CoreExecutor(InputCallback cb)
    : postInput_(std::move(cb)) {
    initSocketCallbacks();
    heartbeatThread_ = std::thread(&CoreExecutor::heartbeatLoop, this);
}

CoreExecutor::~CoreExecutor() {
    stop();
}

void CoreExecutor::initSocketCallbacks() {
    // 1. è¿æ¥æˆåŠŸå›è°ƒï¼šæ¨é€ InTcpConnected åˆ° Core
    socket_.setConnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpConnected{}); // æ›¿æ¢ä¸º InTcpConnected
            std::cout << "[Executor] Socket connected, push InTcpConnected to Core" << std::endl;
        }
    });

    // 2. æ–­å¼€è¿æ¥å›è°ƒï¼šæ¨é€ InTcpDisconnected åˆ° Core
    socket_.setDisconnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Socket disconnected, push InTcpDisconnected to Core" << std::endl;
        }
    });

    // 3. æ¶ˆæ¯æ¥æ”¶å›è°ƒï¼šè§£ææ¶ˆæ¯å¹¶æ¨é€å¯¹åº” CoreInput åˆ° Core
    socket_.setMessageCallback([this](const std::string& msg) {
        if (!isRunning_) return;

        ClientEvent event = ClientEventFactory::makeEvent(msg);
        std::visit([this](auto&& e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, ProtoEvtLoginOk>) {
                postInput_(core::InLoginOk{});
            } else if constexpr (std::is_same_v<T, ProtoEvtLoginFail>) {
                postInput_(core::InLoginFail{e.resp.message});
            } else if constexpr (std::is_same_v<T, ProtoEvtOnlineUsers>) {
                core::InOnlineUsers in;

                for (const auto& u : (e.users.users)) {
                    in.users.push_back(core::OnlineUser{
                        .name = u.username,
                        .privilege = u.privilege
                    });
                }

                postInput_(std::move(in));
            }
            else if constexpr (std::is_same_v<T, ProtoEvHeartbeatAck>) {
                postInput_(core::InHeartbeatOk{});
            }
            else if constexpr (std::is_same_v<T, ProtoEvtForwardText>) {
                postInput_(core::InForwardText{e.from_user, e.content});
            }

            else if constexpr (std::is_same_v<T, ProtoEvtCallIncoming>)
                postInput_(core::InCallIncoming{e.from});
            else if constexpr (std::is_same_v<T, ProtoEvtCallAccepted>)
                postInput_(core::InCallAccepted{e.peer});
            else if constexpr (std::is_same_v<T, ProtoEvtCallRejected>)
                postInput_(core::InCallRejected{e.peer});
            else if constexpr (std::is_same_v<T, ProtoEvtMediaPeer>)
                postInput_(core::InMediaPeer{e.peer, e.lanIp, e.vpnIp, e.udpPort});

            else if constexpr (std::is_same_v<T, ProtoEvtCallEnded>) {
                postInput_(core::InCallEnded{e.peer, e.reason});
                std::cout << "[Executor] Push InCallEnded to Core (peer: " << e.peer << ", reason: " << e.reason << ")" << std::endl;
            }

            else {
                postInput_(core::InUnknow{});
            }

        }, event);
    });
}

void CoreExecutor::connectToServer(const std::string& host, int port) {
    // å¼‚æ­¥æ‰§è¡Œè¿æ¥
    std::thread([this, host, port]() {
        if (!socket_.connectToServer(host, port)) {
            // è¿æ¥å¤±è´¥ï¼šæ¨é€ InTcpDisconnected
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Connect to " << host << ":" << port << " failed" << std::endl;
        }
        else {
            std::cout << "[Executor] Successfully connected to server: " << host << ":" << port << std::endl;
        }
    }).detach();
}

void CoreExecutor::sendHangup() {
    std::string hangupMsg = proto::makeCallHangup();
    socket_.sendMessage(hangupMsg);
    std::cout << "[Executor] Send CALL_HANGUP to server" << std::endl;
}

void CoreExecutor::sendLoginRequest(const std::string& user, const std::string& pass) {
    std::string loginMsg = proto::makeLoginRequest(user, pass);
    socket_.sendMessage(loginMsg);
    std::cout << "[Executor] Send login request for user: " << user << std::endl;
}

void CoreExecutor::heartbeatLoop() {
    while (isRunning_) {
        std::this_thread::sleep_for(std::chrono::seconds(5));

        if (!isRunning_) break;

        // æ¨é€ HeartbeatTick ç»™ Core
        postInput_(core::InHeartbeatTick{});
        std::cout << "[Executor] push InHeartbeatTick" << std::endl;
    }
}


void CoreExecutor::sendPing() {
    std::string ping = proto::makeHeartbeat();
    socket_.sendMessage(ping);
    std::cout << "[Executor] Send PING" << std::endl;
}


void CoreExecutor::stop() {
    isRunning_ = false;
    socket_.stop();
}

void CoreExecutor::setLanMode() {
    mode_ = NetMode::LAN;
    std::cout << "[Executor] Switched to LAN mode\n";
}

void CoreExecutor::setVpnMode() {
    mode_ = NetMode::VPN;
    std::cout << "[Executor] Switched to VPN mode\n";
}

std::string CoreExecutor::selectPeerIp(
    const std::string& lanIp,
    const std::string& vpnIp) const
{
    if (mode_ == NetMode::VPN && !vpnIp.empty())
        return vpnIp;

    return lanIp;
}

void CoreExecutor::sendLocalIP() {
    std::string lanIp = getLocalLanIP();
    std::string vpnIp = getVpnIp();

    // æ ¸å¿ƒä¿®æ”¹ï¼šè‡ªåŠ¨æŸ¥æ‰¾å¯ç”¨ç«¯å£ï¼Œæ›¿æ¢ç¡¬ç¼–ç çš„5001
    int port = findAvailableUdpPort(5000, 6000);
    if (port == -1) {
        // å¼‚å¸¸å¤„ç†ï¼šæ— å¯ç”¨ç«¯å£æ—¶æç¤ºå¹¶è¿”å›
        std::cerr << "[Executor] No available UDP port found, cannot register peer info" << std::endl;
        return;
    }
    mediaPort_ = port; // ä¿å­˜é€‰æ‹©çš„ç«¯å£ï¼Œä¾›VideoReceiverä½¿ç”¨

    // å‘é€æ³¨å†Œæ¶ˆæ¯ï¼ˆä½¿ç”¨è‡ªåŠ¨é€‰æ‹©çš„ç«¯å£ï¼‰
    std::string msg = proto::makeRegisterPeerMsg(lanIp, vpnIp, port);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send Local IP and port: lan=" << lanIp << ", vpn=" << vpnIp << ", port=" << port << std::endl;
}

void CoreExecutor::sendTextMsg(const std::string& target_user, const std::string& content) {
    std::string textMsg = proto::makeSendTextMsg(target_user, content);
    socket_.sendMessage(textMsg);
    std::cout << "[Executor] Send text msg to " << target_user << ": " << content << std::endl;
}

// å‘é€CALLè¯·æ±‚
void CoreExecutor::sendCallRequest(const std::string& target_user) {
    std::string msg = proto::makeCallRequest(target_user);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL request to: " << target_user << std::endl;
}

// å‘é€CALL_ACCEPT
void CoreExecutor::sendAcceptCall() {
    std::string msg = proto::makeAcceptCallRequest();
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL_ACCEPT" << std::endl;
}

// å‘é€CALL_REJECT
void CoreExecutor::sendRejectCall() {
    std::string msg = proto::makeRejectCallRequest();
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL_REJECT" << std::endl;
}

// å‘é€MEDIA_OFFER
void CoreExecutor::sendMediaOffer(const std::string& peer) {
    std::string msg = proto::makeMediaOfferRequest(peer);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send MEDIA_OFFER to: " << peer << std::endl;
}

// å‘é€MEDIA_ANSWER
void CoreExecutor::sendMediaAnswer(const std::string& peer) {
    std::string msg = proto::makeMediaAnswerRequest(peer);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send MEDIA_ANSWER to: " << peer << std::endl;
}

========== ./core/CallSession.h ==========
Lines: 57

// core/CallSession.h
#pragma once
#include <string>
#include <cstdint>
#include "ClientState.h" // å¼•å…¥æ—§ State ç”¨äºæ˜ å°„

// æœ€å°ç‰ˆ CallStateï¼šä»…æ˜ å°„æ—§ State ä¸­çš„é€šè¯çŠ¶æ€ï¼Œä¸æ–°å¢ Ending/MediaReady
enum class CallState {
    Idle,        // å¯¹åº”æ—§ State::LoggedInï¼ˆæ— é€šè¯ï¼‰
    Calling,     // å¯¹åº”æ—§ State::CALLING
    Ringing,     // å¯¹åº”æ—§ State::RINGING
    InCall,      // å¯¹åº”æ—§ State::IN_CALL
    MediaReady,  // å¯¹åº”æ—§ State::MEDIA_READY
    Ending       // æ–°å¢ï¼šæ ‡è®°ä¼šè¯æ­£åœ¨ç»“æŸï¼Œé˜²é‡å¤è°ƒç”¨
};

// ç”Ÿæˆå”¯ä¸€ SessionIdï¼ˆæç®€ç‰ˆï¼šè‡ªå¢æ•´æ•°ï¼Œçº¿ç¨‹å®‰å…¨ï¼‰
static std::atomic<uint64_t> g_next_session_id = 1;
inline uint64_t generateUniqueSessionId() {
    return g_next_session_id.fetch_add(1);
}

// æœ€å°ç‰ˆ CallSessionï¼šä»…åŒ…å«åŸºç¡€å­—æ®µï¼Œæ— ä»»ä½•ä¸šåŠ¡é€»è¾‘
struct CallSession {
    uint64_t sessionId;          // å”¯ä¸€æ ‡è¯†
    std::string peerName;        // å¯¹åº”æ—§ peer_
    std::string peerIp;          // å¯¹åº”æ—§ peerIp_
    int peerPort = 0;            // å¯¹åº”æ—§ peerPort_
    bool isCaller = false;       // å¯¹åº”æ—§ isCaller_
    CallState currentCallState;  // æ˜ å°„æ—§ State çš„é€šè¯çŠ¶æ€

    // æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–åŸºç¡€å­—æ®µ
    CallSession() : sessionId(generateUniqueSessionId()), currentCallState(CallState::Idle) {}

    // è¾…åŠ©ï¼šCallState è½¬æ—§ Stateï¼ˆç”¨äºå…¼å®¹ï¼Œä¸ä¿®æ”¹æ—§é€»è¾‘ï¼‰
    State toOldState() const {
        switch (currentCallState) {
        case CallState::Calling: return State::CALLING;
        case CallState::Ringing: return State::RINGING;
        case CallState::InCall: return State::IN_CALL;
        case CallState::MediaReady: return State::MEDIA_READY;
        case CallState::Ending: return State::LoggedIn; // æ–°å¢
        default: return State::LoggedIn;
        }
    }
};

// è¾…åŠ©ï¼šæ—§ State è½¬ CallStateï¼ˆç”¨äºåˆå§‹åŒ– Sessionï¼‰
inline CallState fromOldState(State oldState) {
    switch (oldState) {
    case State::CALLING: return CallState::Calling;
    case State::RINGING: return CallState::Ringing;
    case State::IN_CALL: return CallState::InCall;
    case State::MEDIA_READY: return CallState::MediaReady;
    default: return CallState::Idle;
    }
}

========== ./core/ClientState.h ==========
Lines: 32

// ClientState.h
#pragma once

#include <string>

enum class State {
    Disconnected,
    Connecting,
    Connected,
    LoggingIn,
    LoggedIn,
    CALLING,    // å‘èµ·å‘¼å«ä¸­
    RINGING,    // æ”¶åˆ°æ¥ç”µå“é“ƒä¸­
    IN_CALL,    // ä¿¡ä»¤æ¥é€š
    MEDIA_READY // åª’ä½“ä¿¡æ¯å°±ç»ª
};

// å°† State è½¬æ¢ä¸ºå­—ç¬¦ä¸²
inline std::string stateToString(State s) {
    switch (s) {
    case State::Disconnected: return "Disconnected";
    case State::Connecting:   return "Connecting";
    case State::Connected:    return "Connected";
    case State::LoggingIn:    return "LoggingIn";
    case State::LoggedIn:     return "LoggedIn";
    case State::CALLING:    return "CALLING";
    case State::RINGING:    return "RINGING";
    case State::IN_CALL:    return "IN_CALL";
    case State::MEDIA_READY:return "MEDIA_READY";
    default:                  return "Unknown";
    }
}

========== ./core/CoreExecutor.h ==========
Lines: 56

//CoreExecutor.h
#pragma once
#include "CoreInput.h"
#include "CommandSocket.h"
#include "protocol_text.h"
#include "ClientEventFactory.h"
#include <functional>
#include <memory>

// å®šä¹‰å›è°ƒç±»å‹ï¼šExecutor æ‰§è¡Œ IO åï¼Œé€šè¿‡è¯¥å›è°ƒå‘ ClientCore æ¨é€ CoreInput
using InputCallback = std::function<void(core::CoreInput)>;
enum class NetMode { LAN, VPN };

class CoreExecutor {
public:
    // æ„é€ å‡½æ•°ï¼šæ¥æ”¶å›è°ƒå‡½æ•°ï¼ˆç”¨äºå‘ Core æ¨é€è¾“å…¥äº‹ä»¶ï¼‰
    explicit CoreExecutor(InputCallback cb);
    ~CoreExecutor();

    // å¯¹å¤–æš´éœ²çš„ IO æ“ä½œæ¥å£ï¼ˆè¯­ä¹‰åŒ–å‘½åï¼‰
    void connectToServer(const std::string& host, int port);
    void sendLoginRequest(const std::string& user, const std::string& pass);
    void sendPing();
    void stop(); // èµ„æºé‡Šæ”¾æ¥å£
    void setLanMode() ;
    void setVpnMode() ;
    std::string selectPeerIp(const std::string& lanIp,
                             const std::string& vpnIp) const;
    void sendLocalIP();
    void sendTextMsg(const std::string& target_user, const std::string& content);
    void sendCallRequest(const std::string& target_user);
    void sendAcceptCall();
    void sendRejectCall();
    void sendMediaOffer(const std::string& peer);
    void sendMediaAnswer(const std::string& peer);
    int getMediaPort() const { return mediaPort_; }
    void sendHangup();
private:
    // å°è£…çš„ socket å®ä¾‹ï¼ˆExecutor å”¯ä¸€æŒæœ‰ï¼‰
    CommandSocket socket_;
    // å‘ Core æ¨é€äº‹ä»¶çš„å›è°ƒ
    InputCallback postInput_;
    // çº¿ç¨‹å®‰å…¨æ ‡è®°
    std::atomic<bool> isRunning_{true};

    // åˆå§‹åŒ– socket å›è°ƒï¼ˆå†…éƒ¨ç§æœ‰ï¼‰
    void initSocketCallbacks();

    std::thread heartbeatThread_;
    void heartbeatLoop();   // æ–°å¢


    std::atomic<NetMode> mode_{NetMode::LAN};
    std::atomic<int> mediaPort_{0}; // åˆå§‹å€¼0è¡¨ç¤ºæœªé€‰æ‹©

};

========== ./core/CallManager.h ==========
Lines: 0


========== ./core/ICoreListener.h ==========
Lines: 16

// core/ICoreListener.h
#pragma once
#include "CoreOutput.h"

namespace core {

class ICoreListener {
public:
    virtual ~ICoreListener() = default;

    // ========== å…³é”®ä¿®æ”¹ï¼šå°† onCoreOutput æ”¹ä¸º onUiOutputï¼Œå‚æ•°æ”¹ä¸º UiOutput ==========
    // UI å±‚ä»…èƒ½æ¥æ”¶ UiOutputï¼Œæ— æ³•è®¿é—®ä»»ä½• Executor ç›¸å…³ç±»å‹
    virtual void onUiOutput(const UiOutput& out) = 0;
};

} // namespace core

========== ./core/CoreOutput.h ==========
Lines: 95

// core/CoreOutput.h
#pragma once
#include <variant>
#include "ClientState.h"
#include "vector"
#include "CoreInput.h"
// è¾“å‡ºå±‚äº‹ä»¶å…¨éƒ¨çº³å…¥ core å‘½åç©ºé—´
namespace core {

// ========== ç¬¬ä¸€æ­¥ï¼šæ˜ç¡®åˆ†ç±»ï¼Œæ‹†åˆ†å‡º 3 ç§è¯­ä¹‰ç±»å‹ ==========
// 1. UI ä¸“å±è¾“å‡ºï¼ˆä»…ç”¨äºé€šçŸ¥ UI æ›´æ–°çŠ¶æ€/æ‰§è¡Œç•Œé¢æ“ä½œï¼Œæ—  IO é€»è¾‘ï¼‰
struct UiOutStateChanged {
    State from;
    State to;
};
struct UiOutLoginOk {};
struct UiOutLoginFail { std::string msg; };
struct UiOutDisconnected {};
struct UiOutOnlineUsers { std::vector<OnlineUser> list; };
struct UiOutForwardText { std::string from_user; std::string content; };
struct UiOutMediaReadyFinal {
    std::string peerIp;
    int peerPort;
};
struct UiOutShowIncomingCall { std::string from; };
struct UiOutCallEnded {
    std::string peer;
    std::string reason;
};
struct UiOutStopMedia {}; // é€šçŸ¥ UI åœæ­¢åª’ä½“å±‚ï¼Œå±äº UI èŒè´£

// 2. Executor ä¸“å±è¾“å‡ºï¼ˆä»…ç”¨äºå‘ Executor ä¸‹è¾¾ IO å‘½ä»¤ï¼Œæ—  UI é€»è¾‘ï¼‰
struct ExecOutConnect { std::string host; int port; };
struct ExecOutSendLogin { std::string user; std::string pass; };
struct ExecOutSendPing {};
struct ExecOutSelectLan {};
struct ExecOutSelectVpn {};
struct ExecOutSendText { std::string target_user; std::string content; };
struct ExecOutSendCall { std::string target_user; };
struct ExecOutSendAcceptCall {};
struct ExecOutSendRejectCall {};
struct ExecOutSendMediaOffer { std::string peer; };
struct ExecOutSendMediaAnswer { std::string peer; };
struct ExecOutSendHangup {};
struct ExecOutLoginOk {}; // ä»…ç”¨äºé€šçŸ¥ Executor å‘é€æœ¬åœ° IPï¼Œå±äº IO èŒè´£
struct ExecOutMediaReady { // ä»…ç”¨äº Executor é€‰æ‹© IPï¼Œä¸ç›´æ¥æš´éœ²ç»™ UI
    std::string lanIp;
    std::string vpnIp;
    int peerPort;
};

// 3. å†…éƒ¨è¾…åŠ©ç±»å‹ï¼ˆä»… Core å†…éƒ¨ä½¿ç”¨ï¼Œä¸æš´éœ²ç»™ä»»ä½•ä¸Šå±‚ï¼‰
struct InternalOutUpdateAlive {};

// ========== ç¬¬äºŒæ­¥ï¼šå®šä¹‰è¯­ä¹‰åŒ–çš„èšåˆç±»å‹ ==========
// UI å±‚ä»…èƒ½è®¿é—®æ­¤ç±»å‹
using UiOutput = std::variant<
    UiOutStateChanged,
    UiOutLoginOk,
    UiOutLoginFail,
    UiOutDisconnected,
    UiOutOnlineUsers,
    UiOutForwardText,
    UiOutShowIncomingCall,
    UiOutMediaReadyFinal,
    UiOutCallEnded,
    UiOutStopMedia
    >;

// Executor å±‚ä»…èƒ½è®¿é—®æ­¤ç±»å‹ï¼ˆCore å†…éƒ¨ä¼ é€’ç»™ Executorï¼‰
using ExecOutput = std::variant<
    ExecOutConnect,
    ExecOutSendLogin,
    ExecOutSendPing,
    ExecOutSelectLan,
    ExecOutSelectVpn,
    ExecOutSendText,
    ExecOutSendCall,
    ExecOutSendAcceptCall,
    ExecOutSendRejectCall,
    ExecOutSendMediaOffer,
    ExecOutSendMediaAnswer,
    ExecOutSendHangup,
    ExecOutLoginOk,
    ExecOutMediaReady
    >;

// Core å†…éƒ¨ç»Ÿä¸€ DSLï¼ˆä»…åœ¨ ClientCoreã€FSM å†…éƒ¨ä½¿ç”¨ï¼Œä¸æš´éœ²ç»™ä¸Šå±‚ï¼‰
using CoreOutput = std::variant<
    UiOutput,
    ExecOutput,
    InternalOutUpdateAlive
    >;

} // namespace core

========== ./core/CallManager.cpp ==========
Lines: 0


========== ./net/PacketCodec.h ==========
Lines: 39

//PacketCodec.h
#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 48

//CommandSocket.h
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <vector>
#include "PacketCodec.h"

class CommandSocket {
public:
    using MessageCallback = std::function<void(const std::string&)>;
    using ConnectCallback = std::function<void()>;
    using DisconnectCallback = std::function<void()>;

    CommandSocket();
    ~CommandSocket();

    void setConnectCallback(ConnectCallback cb);
    void setDisconnectCallback(DisconnectCallback cb);
    // TCP å®¢æˆ·ç«¯
    bool connectToServer(const std::string& host, int port);

    // TCP æœåŠ¡å™¨
    bool startServer(int port);

    void setMessageCallback(MessageCallback cb);

    // å‘é€æ•°æ®
    void sendMessage(const std::string& msg);

    // åœæ­¢
    void stop();

private:
    void clientThreadFunc();
    void serverThreadFunc();
    void sendPacket(int fd, const std::string& payload);
    int sockfd_ = -1;
    int clientfd_ = -1;  // å¯¹äºæœåŠ¡å™¨ç«¯ä¿å­˜å®¢æˆ·ç«¯è¿æ¥
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    MessageCallback callback_;

    ConnectCallback onConnect_;
    DisconnectCallback onDisconnect_;

};

========== ./net/CommandSocket.cpp ==========
Lines: 141

//CommandSocket.cpp
#include "CommandSocket.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

CommandSocket::CommandSocket() {}

CommandSocket::~CommandSocket() {
    stop();
}

void CommandSocket::setMessageCallback(MessageCallback cb) {
    callback_ = std::move(cb);
}

void CommandSocket::setConnectCallback(ConnectCallback cb) {
    onConnect_ = std::move(cb);
}

void CommandSocket::setDisconnectCallback(DisconnectCallback cb) {
    onDisconnect_ = std::move(cb);
}


void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


bool CommandSocket::connectToServer(const std::string& host, int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &serv_addr.sin_addr);

    if (connect(sockfd_, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sockfd_);
        sockfd_ = -1;
        return false;
    }

    if (onConnect_) onConnect_();   // â­ TCPçœŸæ­£å»ºç«‹
    // std::thread([this]{
    //     if (onConnect_) onConnect_();
    // }).detach();

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::clientThreadFunc, this);
    return true;
}

bool CommandSocket::startServer(int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(sockfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(sockfd_, 1) < 0) return false;

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::serverThreadFunc, this);
    return true;
}

void CommandSocket::sendMessage(const std::string& msg) {
    int fd = (clientfd_ >= 0) ? clientfd_ : sockfd_;
    sendPacket(fd,msg);
}

void CommandSocket::stop() {
    running_ = false;
    if (workerThread_.joinable())
        workerThread_.join();
    if (sockfd_ >= 0) close(sockfd_);
    if (clientfd_ >= 0) close(clientfd_);
    sockfd_ = -1;
    clientfd_ = -1;
}

void CommandSocket::clientThreadFunc() {
    std::vector<char> recvBuffer;
    char temp[1024];

    while (running_) {
        int n = recv(sockfd_, temp, sizeof(temp), 0);
        if (n > 0) {

            // 1ï¸âƒ£ æŠŠæ”¶åˆ°çš„å­—èŠ‚å¡è¿›ç¼“å­˜
            std::cout << "[CommandSocket] Received data, length: " << n << " bytes" << std::endl;
            recvBuffer.insert(recvBuffer.end(), temp, temp + n);

            // 2ï¸âƒ£ å°è¯•ä»ç¼“å­˜ä¸­æ‹†å®Œæ•´åŒ…
            std::string payload;
            while (PacketCodec::tryDecode(recvBuffer, payload)) {

                // 3ï¸âƒ£ æ¯ä¸€ä¸ª payload = ä¸€æ¡å®Œæ•´â€œåº”ç”¨å±‚æ¶ˆæ¯â€
                if (callback_) {
                    callback_(payload);
                }
            }

        } else if (n <= 0) {
            std::cout << "[CommandSocket] Server disconnected (recv return <=0)" << std::endl;
            if (onDisconnect_) onDisconnect_();  // â­ TCPæ–­çº¿
            break; // æœåŠ¡å™¨æ­£å¸¸æ–­å¼€
        }
    }
}

void CommandSocket::serverThreadFunc() {
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    clientfd_ = accept(sockfd_, (sockaddr*)&client_addr, &client_len);
    if (clientfd_ < 0) return;

    char buffer[1024];
    while (running_) {
        int n = recv(clientfd_, buffer, sizeof(buffer) - 1, 0);
        if (n > 0) {
            buffer[n] = '\0';
            if (callback_) callback_(std::string(buffer));
        } else if (n == 0) {
            break; // å®¢æˆ·ç«¯æ–­å¼€
        }
    }
}

========== ./ui/VideoWidget.cpp ==========
Lines: 35

//VideoWidget.cpp
#include "VideoWidget.h"
#include <QPainter>
#include <QDebug>
VideoWidget::VideoWidget(QWidget *parent)
    : QWidget(parent) {
    setMinimumSize(640, 480);
}

void VideoWidget::setFrame(const QImage &img) {
    frame_ = img;
    update();
}

void VideoWidget::paintEvent(QPaintEvent *) {
    QPainter p(this);
    p.fillRect(rect(), Qt::black);

    if (frame_.isNull())
        return;

    QSize imgSize = frame_.size();
    imgSize.scale(size(), Qt::KeepAspectRatio);

    QRect targetRect(
        (width()  - imgSize.width())  / 2,
        (height() - imgSize.height()) / 2,
        imgSize.width(),
        imgSize.height()
        );
    //qDebug() << "widget size:" << size();

    p.drawImage(targetRect, frame_);
}


========== ./ui/widget.cpp ==========
Lines: 243

// ui/widget.cppï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#include "widget.h"
#include "./ui_widget.h"
#include <QDebug>
#include "ClientCore.h" // åŒ…å«Coreå¤´æ–‡ä»¶
#include "ClientState.h" // åŒ…å«çŠ¶æ€è½¬æ¢å‡½æ•°
#include <QMessageBox>
Widget::Widget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
    , core_(core)  // åˆå§‹åŒ–CoreæŒ‡é’ˆ
{
    ui->setupUi(this);
    video_ = new VideoWidget(ui->videoContainer);
    adapter_ = new QtCameraAdapter(video_, this);

    // å…³é”®ä¿®å¤ï¼šç»‘å®šæ‘„åƒå¤´å›è°ƒåˆ°Qtç•Œé¢
    camera_.setFrameCallback([this](const Frame& f) {
        // è·¨çº¿ç¨‹å®‰å…¨è°ƒç”¨ï¼ˆCameraManageråœ¨å­çº¿ç¨‹ï¼ŒUIåœ¨ä¸»çº¿ç¨‹ï¼‰
        QMetaObject::invokeMethod(adapter_, "onFrame", Qt::QueuedConnection, Q_ARG(Frame, f));
    });

    // è¿œç«¯è§†é¢‘åˆå§‹åŒ–ï¼ˆå’Œæœ¬åœ°å®Œå…¨å¯¹ç§°ï¼‰
    remote_video_ = new VideoWidget(ui->remoteVideoContainer); // éœ€åœ¨UIè®¾è®¡å¸ˆä¸­æ·»åŠ remoteVideoContaineræ§ä»¶
    remote_adapter_ = new QtCameraAdapter(remote_video_, this);
    receiver_.setFrameCallback([this](const Frame& f) {
        // è·¨çº¿ç¨‹è°ƒç”¨ï¼ˆæ¥æ”¶ç«¯åœ¨GStreamerçº¿ç¨‹ï¼ŒUIåœ¨ä¸»çº¿ç¨‹ï¼‰
        QMetaObject::invokeMethod(remote_adapter_, "onFrame", Qt::QueuedConnection, Q_ARG(Frame, f));
    });

    if (core_) {
        core_->addListener(this);
    }

    // å…³é”®ä¿®å¤ï¼šç»‘å®šCoreäº‹ä»¶çš„è·¨çº¿ç¨‹å¤„ç†
    connect(this, &Widget::coreOutputReceived,
            this, &Widget::handleCoreOutput,
            Qt::QueuedConnection);
}

Widget::~Widget()
{
    // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„ç§»é™¤ç›‘å¬è€…æ–¹æ³•
    if (core_) {
        core_->removeListener(this);
    }
    // åœæ­¢æ¥æ”¶ç«¯
    receiver_.stop();
    // åœæ­¢å‘é€ç«¯ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
    camera_.stop();
    delete ui;
}

// æ–°æ¥å£å®ç°ï¼šåªè½¬å‘ä¿¡å·
void Widget::onUiOutput(const core::UiOutput& out)
{
    qDebug() << "Main UI received core ui output, type index:" << out.index();
    emit coreOutputReceived(out);
}
void Widget::handleCoreOutput(const core::UiOutput& out)
{
    std::visit([this, &out](auto&& e) {
        using T = std::decay_t<decltype(e)>; // è·å–ç§»é™¤å¼•ç”¨/const åçš„åŸå§‹ç±»å‹
        // åŒ¹é… Widget å…³å¿ƒçš„æ‰€æœ‰ç±»å‹
        if constexpr (std::is_same_v<T, core::UiOutStateChanged>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutLoginOk>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutLoginFail>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutDisconnected>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutOnlineUsers>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutForwardText>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutShowIncomingCall>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutMediaReadyFinal>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutCallEnded>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutStopMedia>) {
            handle(e);
        }
        // å…œåº•ï¼šæœªå¤„ç†çš„ UiOutput ç±»å‹ï¼Œæ‰“å°æ—¥å¿—ï¼ˆé¿å…æ½œåœ¨é—®é¢˜ï¼Œæ–¹ä¾¿åç»­è°ƒè¯•ï¼‰
        else {
            std::cerr << "[Widget] Unhandled UiOutput type, index: " << out.index() << std::endl;
        }
    }, out);
}

void Widget::on_Bt_video_on_off_clicked()
{
    qDebug("Button clicked!");
    //camera_.start("/dev/video0");
}

void Widget::on_Bt_video_off_clicked()
{
    qDebug("Button clicked!");
    camera_.stop();
}

void Widget::on_Bt_tcp_send_clicked() {
    // è·å–ç›®æ ‡ç”¨æˆ·åå’Œæ¶ˆæ¯å†…å®¹
    QString target_user = ui->lineEdit_target_user->text();
    QString content = ui->lineEdit_msg->text();
    if (target_user.isEmpty() || content.isEmpty()) {
        std::cout << "can not be empty" << std::endl;
        return;
    }
    // å‘é€åˆ°Coreå±‚
    core_->postInput(core::InCmdSendText{
        target_user.toStdString(),
        content.toStdString()
    });
    // æ¸…ç©ºè¾“å…¥æ¡†
    ui->lineEdit_msg->clear();
}





void Widget::on_Bt_Call_clicked()
{
    QString targetUser = ui->lineEdit_CallTarget->text();
    core_->postInput(core::InCmdCall{targetUser.toStdString()});
}


void Widget::on_Bt_AcceptCall_clicked()
{
    core_->postInput(core::InCmdAcceptCall{});
}


void Widget::on_Bt_RejectCall_clicked()
{
    core_->postInput(core::InCmdRejectCall{});
}


void Widget::on_Bt_set_lan_clicked()
{
    core_->postInput(core::InSelectLan{}); // è§¦å‘LANæ¨¡å¼
}


void Widget::on_Bt_sen_vpn_clicked()
{
    core_->postInput(core::InSelectVpn{}); // è§¦å‘VPNæ¨¡å¼
}


void Widget::on_Bt_Hangup_clicked()
{
    core_->postInput(core::InCmdHangup{});
}


// åªä¿ç•™ UiOutXXX ç›¸å…³ handle
void Widget::handle(const core::UiOutStateChanged& e) {
    std::cout << "[Widget] FSM:"
              << stateToString(e.from)
              << "â†’"
              << stateToString(e.to) << std::endl;
}

void Widget::handle(const core::UiOutLoginOk&) {
    std::cout << "[Widget] UiOutLoginOk" << std::endl;
}

void Widget::handle(const core::UiOutLoginFail& e) {
    std::cout << "[Widget] UiOutLoginFail: " << e.msg << std::endl;
    QMessageBox::warning(this, "Login Failed", QString::fromStdString(e.msg));
}

void Widget::handle(const core::UiOutDisconnected&) {
    std::cout << "[Widget] UiOutDisconnected" << std::endl;
    QMessageBox::information(this, "Info", "Disconnected from server");
}

void Widget::handle(const core::UiOutOnlineUsers& e) {
    std::cout << "[UI] UiOutOnlineUsers" << std::endl;
    QString text;
    for (const auto& u : e.list) {
        text += QString("%1 (priv=%2)\n")
                    .arg(QString::fromStdString(u.name))
                    .arg(u.privilege);
    }
    ui->text_onlineUsers->setPlainText(text);
}

void Widget::handle(const core::UiOutForwardText& e) {
    std::cout << "[Widget] recev from " << e.from_user << " msg: " << e.content << std::endl;
    QString text = ui->PTE_recv->toPlainText();
    text += QString("[%1]: %2\n").arg(QString::fromStdString(e.from_user)).arg(QString::fromStdString(e.content));
    ui->PTE_recv->setPlainText(text);
}

void Widget::handle(const core::UiOutShowIncomingCall& e) {
    QMessageBox msgBox;
    msgBox.setWindowTitle("Incoming");
    msgBox.setText(QString("User %1 is calling you").arg(QString::fromStdString(e.from)));
    msgBox.addButton("Accept", QMessageBox::AcceptRole);
    msgBox.addButton("Reject", QMessageBox::RejectRole);
    int ret = msgBox.exec();
    if (ret == QMessageBox::AcceptRole) {
        core_->postInput(core::InCmdAcceptCall{});
    } else {
        core_->postInput(core::InCmdRejectCall{});
    }
}

void Widget::handle(const core::UiOutMediaReadyFinal& e) {
    std::cout << "[Widget] UiOutMediaReadyFinal" << std::endl;
    std::cout << "[UI] Media ready, peer IP: " << e.peerIp << ", port: " << e.peerPort << std::endl;

    int mediaPort = core_->getMediaPort();
    if (mediaPort <= 0) {
        std::cerr << "[Widget] Invalid media port: " << mediaPort << std::endl;
        QMessageBox::warning(this, "Error", "No available UDP port found!");
        return;
    }

    camera_.start("/dev/video0", e.peerIp, e.peerPort);
    receiver_.start(mediaPort);
}

void Widget::handle(const core::UiOutCallEnded& e) {
    std::cout << "[Widget] Call ended: peer=" << e.peer << ", reason=" << e.reason << std::endl;
    ui->lineEdit_CallTarget->clear();
}

void Widget::handle(const core::UiOutStopMedia&) {
    std::cout << "[Widget] Stop media" << std::endl;
    camera_.stop();
    receiver_.stop();
    video_->setFrame(QImage());
    remote_video_->setFrame(QImage());
}

========== ./ui/QtCameraAdapter.cpp ==========
Lines: 18

//QtCameraAdapter.cpp
#include "QtCameraAdapter.h"
#include <QImage>

QtCameraAdapter::QtCameraAdapter(VideoWidget* view, QObject* parent)
    : QObject(parent), view_(view) {}

void QtCameraAdapter::onFrame(Frame f) {
    QImage img(
        f.data.data(),
        f.width,
        f.height,
        f.stride,
        QImage::Format_RGB888
        );

    view_->setFrame(img.copy());
}

========== ./ui/LoginWidget.h ==========
Lines: 50

//LoginWidget.h
#ifndef LOGINWIDGET_H
#define LOGINWIDGET_H

#include <QWidget>

#include "core/ICoreListener.h"  // å®ç°æŠ½è±¡æ¥å£
#include "core/CoreOutput.h"     // Core è¾“å‡ºäº‹ä»¶

class ClientCore;

namespace Ui {
class LoginWidget;
}

class LoginWidget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit LoginWidget(ClientCore* core, QWidget* parent = nullptr);
    ~LoginWidget() override;

    void onUiOutput(const core::UiOutput& out) override;

signals:
    void loginSuccess();
    void coreOutputReceived(const core::UiOutput& out);

private slots:
    void on_Bt_Jump_Test_clicked();
    void on_Bt_ConnectToServer_clicked();
    void on_Bt_tcp_test_send_clicked();
    void on_Bt_Login_clicked();
    void handleCoreOutput(const core::UiOutput& out);

private:
    Ui::LoginWidget *ui;
    ClientCore* core_;

    void handle(const core::UiOutStateChanged& e);
    void handle(const core::UiOutLoginOk&);
    void handle(const core::UiOutLoginFail& e);
    void handle(const core::UiOutDisconnected&);
    void handle(const core::UiOutOnlineUsers&);
    void handle(const core::UiOutForwardText& e);

};

#endif // LOGINWIDGET_H

========== ./ui/AppWindow.cpp ==========
Lines: 38

// ui/AppWindow.cpp
#include "AppWindow.h"
#include "LoginWidget.h"
#include "widget.h"
#include "core/ClientCore.h"  // åŒ…å« Core å¤´æ–‡ä»¶
#include <QVBoxLayout>

AppWindow::AppWindow(QWidget *parent)
    : QWidget(parent)
{
    resize(900, 600);
    stack = new QStackedWidget(this);

    // æ ¸å¿ƒï¼šåˆ›å»ºå”¯ä¸€çš„ ClientCore å®ä¾‹ï¼ˆçº¯ C++ï¼Œæ—  Qt ä¾èµ–ï¼‰
    core_ = std::make_unique<ClientCore>();

    // ä¼ é€’ Core æŒ‡é’ˆç»™å­çª—å£
    loginPage = new LoginWidget(core_.get(), this);
    mainPage  = new Widget(core_.get(), this);

    stack->addWidget(loginPage); // index 0
    stack->addWidget(mainPage);  // index 1

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(stack);
    setLayout(layout);

    // ç™»å½•æˆåŠŸ â†’ åˆ‡æ¢é¡µé¢
    connect(loginPage, &LoginWidget::loginSuccess, this, [=](){
        stack->setCurrentIndex(PAGE_MAIN);
    });

    // åˆå§‹é¡µé¢
    stack->setCurrentIndex(PAGE_LOGIN);
}

// ææ„ï¼šæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ Core
AppWindow::~AppWindow() = default;

========== ./ui/VideoWidget.h ==========
Lines: 17

//VideoWidget.h
#pragma once
#include <QWidget>
#include <QImage>

class VideoWidget : public QWidget {
    Q_OBJECT
public:
    explicit VideoWidget(QWidget *parent = nullptr);
    void setFrame(const QImage &img);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QImage frame_;
};

========== ./ui/QtCameraAdapter.h ==========
Lines: 17

//QtCameraAdapter.h
#pragma once
#include <QObject>
#include "Frame.h"
#include "VideoWidget.h"

class QtCameraAdapter : public QObject {
    Q_OBJECT
public:
    explicit QtCameraAdapter(VideoWidget* view, QObject* parent = nullptr);

public slots:
    void onFrame(Frame frame);

private:
    VideoWidget* view_;
};

========== ./ui/LoginWidget.cpp ==========
Lines: 132

//LoginWidget.cpp
#include "LoginWidget.h"
#include "./ui_LoginWidget.h"
#include <QMessageBox>
#include <QMetaObject>
#include <QDebug>
#include "ClientCore.h"



LoginWidget::LoginWidget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::LoginWidget)
    , core_(core)  // æ¥æ”¶ AppWindow ä¼ å…¥çš„ Core å®ä¾‹
{
    ui->setupUi(this);

    // æ³¨å†Œä¸º Core çš„ç›‘å¬è€…
    core_->addListener(this);

    // å…³é”®ï¼šè·¨çº¿ç¨‹ä¿¡å·æ§½ï¼ˆå¼ºåˆ¶ QueuedConnectionï¼Œç¡®ä¿ UI çº¿ç¨‹æ‰§è¡Œï¼‰
    connect(this, &LoginWidget::coreOutputReceived,
            this, &LoginWidget::handleCoreOutput,
            Qt::QueuedConnection);


}

LoginWidget::~LoginWidget() {
    // ææ„æ—¶ç§»é™¤ç›‘å¬è€…ï¼ˆé¿å…é‡æŒ‡é’ˆï¼‰
    if (core_) {
        core_->removeListener(this);
    }
    delete ui;
}


// æ–°æ¥å£å®ç°
void LoginWidget::onUiOutput(const core::UiOutput& out) {
    emit coreOutputReceived(out);
}

// UI çº¿ç¨‹å¤„ç† Core äº‹ä»¶ï¼ˆå®‰å…¨æ“ä½œ UIï¼‰- å·²æ·»åŠ å…œåº•å¤„ç†
void LoginWidget::handleCoreOutput(const core::UiOutput& out) {
    std::visit([this, &out](auto&& e) {
        using T = std::decay_t<decltype(e)>; // è·å–ç§»é™¤å¼•ç”¨/const åçš„åŸå§‹ç±»å‹
        // åŒ¹é… LoginWidget å…³å¿ƒçš„æ‰€æœ‰ç±»å‹
        if constexpr (std::is_same_v<T, core::UiOutStateChanged>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutLoginOk>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutLoginFail>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutDisconnected>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutOnlineUsers>) {
            handle(e);
        } else if constexpr (std::is_same_v<T, core::UiOutForwardText>) {
            handle(e);
        }
        // å…œåº•ï¼šæœªå¤„ç†çš„ UiOutput ç±»å‹ï¼Œæ‰“å°æ—¥å¿—ï¼ˆé¿å…æ½œåœ¨é—®é¢˜ï¼Œæ–¹ä¾¿åç»­è°ƒè¯•ï¼‰
        else {
            std::cerr << "[LoginWidget] Unhandled UiOutput type, index: " << out.index() << std::endl;
        }
    }, out);
}

void LoginWidget::on_Bt_Jump_Test_clicked()
{
    emit loginSuccess();
}

void LoginWidget::on_Bt_ConnectToServer_clicked()
{
    //qDebug() << "current thread:" << QThread::currentThread();
    //qDebug() << "ui thread:" << qApp->thread();

    ui->TextEdit_tcp_test_recv->setPlainText("Connecting\n");
    // æ›¿æ¢ä¸º InCmdConnect
    core_->postInput(core::InCmdConnect{"192.168.6.64",6001});
}

void LoginWidget::on_Bt_tcp_test_send_clicked()
{
    QString qmsg = ui->LE_tcp_send_test->text();
    std::string msg = qmsg.toStdString();
}



void LoginWidget::on_Bt_Login_clicked()
{
    QString qstr_user_name = ui->LE_UserName->text();
    std::string msg_user_name = qstr_user_name.toStdString();

    QString qstr_user_pass = ui->LE_UserPass->text();
    std::string msg_user_pass = qstr_user_pass.toStdString();

    // æ›¿æ¢ä¸º InCmdLogin
    core_->postInput(core::InCmdLogin{msg_user_name, msg_user_pass});
}

// åªä¿ç•™ç™»å½•ç•Œé¢å…³å¿ƒçš„äº‹ä»¶
void LoginWidget::handle(const core::UiOutStateChanged& e) {
    std::cout << "[UI] State: " << stateToString(e.from) << " â†’ " << stateToString(e.to) << std::endl;
    ui->TextEdit_FSM_State->setPlainText(QString::fromStdString(stateToString(e.to)));
}

void LoginWidget::handle(const core::UiOutLoginOk&) {
    std::cout << "[UI] Login success" << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login success");
    emit loginSuccess();
}

void LoginWidget::handle(const core::UiOutLoginFail& e) {
    std::cout << "[UI] Login failed: " << e.msg << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login failed: " + QString::fromStdString(e.msg));
}

void LoginWidget::handle(const core::UiOutDisconnected&) {
    std::cout << "[UI] Disconnected" << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Disconnected");
}

void LoginWidget::handle(const core::UiOutOnlineUsers&) {
    // ç™»å½•ç•Œé¢ä¸éœ€è¦å¤„ç†åœ¨çº¿ç”¨æˆ·ï¼Œç©ºå®ç°å³å¯
}

void LoginWidget::handle(const core::UiOutForwardText&) {
    // ç™»å½•ç•Œé¢ä¸éœ€è¦å¤„ç†æ¶ˆæ¯
}


========== ./ui/AppWindow.h ==========
Lines: 30

//AppWindow.h
#pragma once
#include <QWidget>
#include <QStackedWidget>
#include "memory"
#include "LoginWidget.h"
#include "widget.h"
#include "memory"

class ClientCore;

class AppWindow : public QWidget
{
    Q_OBJECT
public:
    explicit AppWindow(QWidget *parent = nullptr);
    ~AppWindow() override;
private:
    QStackedWidget *stack;
    LoginWidget *loginPage;
    Widget *mainPage;

    // æ ¸å¿ƒï¼šAppWindow å”¯ä¸€æŒæœ‰ ClientCore å®ä¾‹
    std::unique_ptr<ClientCore> core_;

    enum PageIndex {
        PAGE_LOGIN = 0,
        PAGE_MAIN
    };
};

========== ./ui/widget.h ==========
Lines: 74

// ui/widget.hï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "QtCameraAdapter.h"
#include "CameraManager.h"
#include "core/ICoreListener.h"
#include "core/CoreOutput.h"
#include "media/VideoReceiver.h"
// å‰ç½®å£°æ˜ï¼ˆå‡å°‘è€¦åˆï¼‰
class ClientCore;

QT_BEGIN_NAMESPACE
namespace Ui {
class Widget;
}
QT_END_NAMESPACE

class Widget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit Widget(ClientCore* core, QWidget *parent = nullptr);
    ~Widget() override;

    // ä»…å®ç°ICoreListenerè¦æ±‚çš„çº¯è™šå‡½æ•°
    void onUiOutput(const core::UiOutput& out) override;

signals:
    void coreOutputReceived(const core::UiOutput& out);

private slots:
    void on_Bt_video_on_off_clicked();
    void on_Bt_video_off_clicked();
    void on_Bt_tcp_send_clicked();
    void handleCoreOutput(const core::UiOutput& out); // æ§½å‡½æ•°å£°æ˜

    void on_Bt_Call_clicked();

    void on_Bt_AcceptCall_clicked();

    void on_Bt_RejectCall_clicked();

    void on_Bt_set_lan_clicked();

    void on_Bt_sen_vpn_clicked();

    void on_Bt_Hangup_clicked();

private:
    Ui::Widget *ui;
    ClientCore* core_; // æ–°å¢ï¼šCoreæŒ‡é’ˆæˆå‘˜
    VideoWidget *video_;
    CameraManager camera_;
    QtCameraAdapter* adapter_;
    VideoWidget *remote_video_;
    VideoReceiver receiver_;
    QtCameraAdapter* remote_adapter_;

    void handle(const core::UiOutStateChanged&);
    void handle(const core::UiOutLoginOk&);
    void handle(const core::UiOutLoginFail&);
    void handle(const core::UiOutDisconnected&);
    void handle(const core::UiOutOnlineUsers&);
    void handle(const core::UiOutForwardText& e);
    void handle(const core::UiOutShowIncomingCall& e);
    void handle(const core::UiOutMediaReadyFinal& e);
    void handle(const core::UiOutCallEnded& e);
    void handle(const core::UiOutStopMedia&);

};
#endif // WIDGET_H

========== ./protocol/protocol_types.h ==========
Lines: 63

//protocol_types.h
#pragma once
#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct Unknown {
    std::string message;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

// æ–‡æœ¬æ¶ˆæ¯ç»“æ„ä½“ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
struct SendTextMsg {
    std::string target_user;  // ç›®æ ‡ç”¨æˆ·å
    std::string content;      // æ¶ˆæ¯å†…å®¹
    std::string from_user;    // å‘é€è€…ç”¨æˆ·åï¼ˆæœåŠ¡å™¨å¡«å……ï¼‰
};

// è½¬å‘æ–‡æœ¬æ¶ˆæ¯ç»“æ„ä½“ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
struct ForwardTextMsg {
    std::string from_user;    // å‘é€è€…ç”¨æˆ·å
    std::string content;      // æ¶ˆæ¯å†…å®¹
};

// æ¥ç”µé€šçŸ¥ç»“æ„ä½“
struct CallIncoming {
    std::string from; // æ¥ç”µæ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ¥å¬ç»“æ„ä½“
struct CallAccepted {
    std::string peer; // é€šè¯å¯¹æ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ‹’ç»ç»“æ„ä½“
struct CallRejected {
    std::string peer; // æ‹’ç»æ–¹ç”¨æˆ·å
};

// åª’ä½“åå•†å“åº”ç»“æ„ä½“
struct MediaPeerResp {
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    std::string lanIp;   // å¯¹æ–¹å±€åŸŸç½‘IP
    std::string vpnIp;   // å¯¹æ–¹VPN IP
    int udpPort;         // å¯¹æ–¹åª’ä½“UDPç«¯å£
};

}

========== ./protocol/protocol_text.h ==========
Lines: 39

//protocol_text.h
#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);
std::string makeHeartbeat();
std::string makeRegisterPeerMsg(const std::string& lan,const std::string& vpn,int port);
std::string makeSendTextMsg(const std::string& target_user, const std::string& content);
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content);
std::string makeCallRequest(const std::string& target_user);
std::string makeAcceptCallRequest();
std::string makeRejectCallRequest();
std::string makeMediaOfferRequest(const std::string& peer);
std::string makeMediaAnswerRequest(const std::string& peer);
// å®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šæ„å»ºä¸»åŠ¨æŒ‚æ–­è¯·æ±‚
std::string makeCallHangup();
// æœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šæ„å»ºæŒ‚æ–­é€šçŸ¥ï¼ˆæºå¸¦åŸå› ï¼‰
std::string makeCallEnded(const std::string& peer, const std::string& reason);
// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);
bool parseHeartbeatAck(const std::string& msg);
bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content);
bool parseForwardTextMsg(const std::string& msg, std::string& from_user, std::string& content);
bool parseCallIncoming(const std::string& msg, CallIncoming& out);
bool parseCallAccepted(const std::string& msg, CallAccepted& out);
bool parseCallRejected(const std::string& msg, CallRejected& out);
bool parseMediaPeerResp(const std::string& msg, MediaPeerResp& out);
// å®¢æˆ·ç«¯è§£ææœåŠ¡ç«¯çš„æŒ‚æ–­é€šçŸ¥
bool parseCallEnded(const std::string& msg, std::string& peer, std::string& reason);
}

========== ./protocol/protocol_text.cpp ==========
Lines: 289

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

std::string makeCallHangup() {
    return CMD_CALL_HANGUP; // ä¸»åŠ¨æŒ‚æ–­æ— éœ€é¢å¤–å‚æ•°ï¼Œç›´æ¥è¿”å›å‘½ä»¤
}

std::string makeCallEnded(const std::string& peer, const std::string& reason) {
    std::ostringstream oss;
    oss << CMD_CALL_ENDED << " " << peer << " " << reason;
    return oss.str();
}

std::string makeCallRequest(const std::string& target_user) {
    std::ostringstream oss;
    oss << CMD_CALL << " " << target_user;
    return oss.str();
}

std::string makeAcceptCallRequest() {
    return CMD_CALL_ACCEPT;
}

std::string makeRejectCallRequest() {
    return CMD_CALL_REJECT;
}

std::string makeMediaOfferRequest(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_MEDIA_OFFER << " " << peer;
    return oss.str();
}

std::string makeMediaAnswerRequest(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_MEDIA_ANSWER << " " << peer;
    return oss.str();
}

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    oss ;
    return oss.str();
}

std::string makeHeartbeat() {
    return CMD_HEARTBEAT;
}

std::string makeRegisterPeerMsg(
    const std::string& lan,
    const std::string& vpn,
    int port)
{
    std::ostringstream oss;
    oss << CMD_REGISTER_PEER << " "
        << lan << " "
        << vpn << " "
        << port;
    return oss.str();
}

// ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
std::string makeSendTextMsg(const std::string& target_user, const std::string& content) {
    std::ostringstream oss;
    // æ ¼å¼ï¼šSEND_TEXT ç›®æ ‡ç”¨æˆ·å æ¶ˆæ¯å†…å®¹ï¼ˆå†…å®¹å«ç©ºæ ¼éœ€ä¿ç•™ï¼Œç”¨å¼•å·æˆ–ç›´æ¥æ‹¼æ¥ï¼Œè¿™é‡Œç”¨ç©ºæ ¼åˆ†éš”åæ‹¼æ¥ï¼‰
    oss << CMD_SEND_TEXT << " " << target_user << " " << content;
    return oss.str();
}

// ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content) {
    std::ostringstream oss;
    oss << CMD_FORWARD_TEXT << " " << from_user << " " << content;
    return oss.str();
}


/* ================= parse ================= */

bool parseCallEnded(const std::string& msg, std::string& peer, std::string& reason) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_ENDED) return false;
    iss >> peer >> reason;
    return !peer.empty() && !reason.empty();
}

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}


bool parseHeartbeatAck(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_HEARTBEAT_ACK;   // "PONG"
}

// è§£æå‘é€æ–‡æœ¬æ¶ˆæ¯ï¼ˆæœåŠ¡å™¨ç”¨ï¼‰
bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_SEND_TEXT) return false;

    // è¯»å–ç›®æ ‡ç”¨æˆ·å
    iss >> target_user;
    // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯ï¼ˆå¤„ç†å«ç©ºæ ¼çš„æƒ…å†µï¼‰
    std::getline(iss >> std::ws, content);
    return !target_user.empty() && !content.empty();
}

// è§£æè½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆå®¢æˆ·ç«¯ç”¨ï¼‰
bool parseForwardTextMsg(const std::string& msg, std::string& from_user, std::string& content) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_FORWARD_TEXT) return false;

    // è¯»å–å‘é€è€…ç”¨æˆ·å
    iss >> from_user;
    // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯
    std::getline(iss >> std::ws, content);
    return !from_user.empty() && !content.empty();
}

// è§£ææ¥ç”µé€šçŸ¥ï¼ˆCMD_CALL_INCOMINGï¼‰
bool parseCallIncoming(const std::string& msg, CallIncoming& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_INCOMING) return false;
    iss >> out.from;
    return !out.from.empty();
}

// è§£æé€šè¯è¢«æ¥å¬ï¼ˆCMD_CALL_ACCEPTEDï¼‰
bool parseCallAccepted(const std::string& msg, CallAccepted& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_ACCEPTED) return false;
    iss >> out.peer;
    return !out.peer.empty();
}

// è§£æé€šè¯è¢«æ‹’ç»ï¼ˆCMD_CALL_REJECTEDï¼‰
bool parseCallRejected(const std::string& msg, CallRejected& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_REJECTED) return false;
    iss >> out.peer;
    return !out.peer.empty();
}

// è§£æåª’ä½“Offer/Answerå“åº”ï¼ˆCMD_MEDIA_OFFER_RESP/CMD_MEDIA_ANSWER_RESPï¼‰
bool parseMediaPeerResp(const std::string& msg, MediaPeerResp& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_MEDIA_OFFER_RESP && cmd != CMD_MEDIA_ANSWER_RESP) return false;
    iss >> out.peer >> out.lanIp >> out.vpnIp >> out.udpPort;

    // åŸºç¡€æ ¡éªŒï¼šç”¨æˆ·åå’Œç«¯å£ä¸èƒ½ä¸ºç©º/æ— æ•ˆ
    return !out.peer.empty() && out.udpPort > 0;
}



} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 38

//protocol_common.h
#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN         = "LOGIN";
constexpr const char* CMD_LOGIN_OK      = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL    = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS  = "ONLINE_USERS";
constexpr const char* CMD_HEARTBEAT     = "PING";
constexpr const char* CMD_HEARTBEAT_ACK = "PONG";
constexpr const char* CMD_REGISTER_PEER = "REGISTER_PEER";
constexpr const char* CMD_SEND_TEXT     = "SEND_TEXT";
constexpr const char* CMD_FORWARD_TEXT  = "FORWARD_TEXT";
// é€šè¯ç›¸å…³CMD
constexpr const char* CMD_CALL               = "CALL";
constexpr const char* CMD_CALL_INCOMING      = "CALL_INCOMING";
constexpr const char* CMD_CALL_ACCEPT        = "CALL_ACCEPT";
constexpr const char* CMD_CALL_REJECT        = "CALL_REJECT";
constexpr const char* CMD_CALL_ACCEPTED      = "CALL_ACCEPTED";
constexpr const char* CMD_CALL_REJECTED      = "CALL_REJECTED";
constexpr const char* CMD_MEDIA_OFFER        = "MEDIA_OFFER";
constexpr const char* CMD_MEDIA_OFFER_RESP   = "MEDIA_OFFER_RESP";
constexpr const char* CMD_MEDIA_ANSWER       = "MEDIA_ANSWER";
constexpr const char* CMD_MEDIA_ANSWER_RESP  = "MEDIA_ANSWER_RESP";
// åœ¨é€šè¯ç›¸å…³CMDåæ–°å¢
constexpr const char* CMD_CALL_HANGUP    = "CALL_HANGUP";    // å®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šä¸»åŠ¨æŒ‚æ–­è¯·æ±‚
constexpr const char* CMD_CALL_ENDED     = "CALL_ENDED";     // æœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šé€šçŸ¥å¯¹ç«¯æŒ‚æ–­ï¼ˆæºå¸¦åŸå› ï¼‰
// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}

========== ./app/ClientEvent.h ==========
Lines: 83

//ClientEvent.h
#pragma once

#include <string>
#include "protocol_types.h"
#include <variant>

// åè®®å±‚äº‹ä»¶ç»Ÿä¸€å‰ç¼€ï¼šProtoEvt
struct ProtoEvtTcpConnected {};
struct ProtoEvtTcpDisconnected {};
struct ProtoEvtLoginOk    { proto::LoginResponse resp; };
struct ProtoEvtLoginFail { proto::LoginResponse resp; };
struct ProtoEvtOnlineUsers { proto::OnlineUsers users; };
struct ProtoEvtUnknow { proto::Unknown error_msg; };
struct ProtoEvtCmdConnect {
    std::string host;
    int port;
};
struct ProtoEvtCmdDisconnect {};
struct ProtoEvtCmdLogin {
    std::string user;
    std::string pass;
};
struct ProtoEvHeartbeatAck{};

// è½¬å‘æ–‡æœ¬æ¶ˆæ¯äº‹ä»¶ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
struct ProtoEvtForwardText {
    std::string from_user;  // å‘é€è€…ç”¨æˆ·å
    std::string content;    // æ¶ˆæ¯å†…å®¹
};

// æ¥ç”µäº‹ä»¶
struct ProtoEvtCallIncoming {
    std::string from; // æ¥ç”µæ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ¥å¬äº‹ä»¶
struct ProtoEvtCallAccepted {
    std::string peer; // é€šè¯å¯¹æ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ‹’ç»äº‹ä»¶
struct ProtoEvtCallRejected {
    std::string peer; // æ‹’ç»æ–¹ç”¨æˆ·å
};

// åª’ä½“åå•†å“åº”äº‹ä»¶
struct ProtoEvtMediaPeer {
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    std::string lanIp;   // å¯¹æ–¹å±€åŸŸç½‘IP
    std::string vpnIp;   // å¯¹æ–¹VPN IP
    int udpPort;         // å¯¹æ–¹åª’ä½“UDPç«¯å£
};

// è§£ææœåŠ¡ç«¯çš„CALL_ENDEDé€šçŸ¥
struct ProtoEvtCallEnded {
    std::string peer;
    std::string reason;
};

using ClientEvent = std::variant<
    // UI è§¦å‘çš„åè®®å‘½ä»¤
    ProtoEvtCmdConnect,
    ProtoEvtCmdDisconnect,
    ProtoEvtCmdLogin,

    // TCP åº•å±‚äº‹ä»¶
    ProtoEvtTcpConnected,
    ProtoEvtTcpDisconnected,

    // åè®®è§£æåçš„ä¸šåŠ¡äº‹ä»¶
    ProtoEvtLoginOk,
    ProtoEvtLoginFail,
    ProtoEvtOnlineUsers,
    ProtoEvtUnknow,
    ProtoEvHeartbeatAck,
    ProtoEvtForwardText,
    ProtoEvtCallIncoming,
    ProtoEvtCallAccepted,
    ProtoEvtCallRejected,
    ProtoEvtMediaPeer,
    ProtoEvtCallEnded
    >;

========== ./app/ClientEventFactory.h ==========
Lines: 18

//ClientEventFactory.h
#ifndef CLIENTEVENTFACTORY_H
#define CLIENTEVENTFACTORY_H

#include "protocol_types.h"
#include "ClientEvent.h"
class ClientEventFactory
{
public:
    ClientEventFactory();
    static ClientEvent makeEvent(const std::string& msg);

private:


};

#endif // CLIENTEVENTFACTORY_H

========== ./app/ClientEventFactory.cpp ==========
Lines: 69

//ClientEventFactory.cpp
#include "ClientEventFactory.h"

// åªåœ¨ cpp ä¸­ include è§£æå‡½æ•°
#include "protocol_text.h"

ClientEventFactory::ClientEventFactory() {}

ClientEvent ClientEventFactory::makeEvent(const std::string& msg)
{
    proto::LoginResponse login;
    if (proto::parseLoginResponse(msg, login)) {
        if (login.success)
            return ProtoEvtLoginOk{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
        else
            return ProtoEvtLoginFail{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    proto::OnlineUsers users;
    if (proto::parseOnlineUsers(msg, users)) {
        return ProtoEvtOnlineUsers{users}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    if (proto::parseHeartbeatAck(msg)) {
        return ProtoEvHeartbeatAck{}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    // è§£æè½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆCMD_FORWARD_TEXTï¼‰
    std::string from_user, content;
    if (proto::parseForwardTextMsg(msg, from_user, content)) {
        return ProtoEvtForwardText{from_user, content};
    }

    // =====è°ƒç”¨é€šè¯ç›¸å…³è§£æå‡½æ•° =====
    proto::CallIncoming callIn;
    if (proto::parseCallIncoming(msg, callIn)) {
        return ProtoEvtCallIncoming{callIn.from};
    }

    proto::CallAccepted callAc;
    if (proto::parseCallAccepted(msg, callAc)) {
        return ProtoEvtCallAccepted{callAc.peer};
    }

    proto::CallRejected callRe;
    if (proto::parseCallRejected(msg, callRe)) {
        return ProtoEvtCallRejected{callRe.peer};
    }

    proto::MediaPeerResp mediaPeer;
    if (proto::parseMediaPeerResp(msg, mediaPeer)) {
        return ProtoEvtMediaPeer{
            mediaPeer.peer,
            mediaPeer.lanIp,
            mediaPeer.vpnIp,
            mediaPeer.udpPort
        };
    }

    // è§£æCALL_ENDEDé€šçŸ¥
    std::string peer, reason;
    if (proto::parseCallEnded(msg, peer, reason)) {
        return ProtoEvtCallEnded{peer, reason};
    }

    proto::Unknown req_error;
    req_error.message = msg;
    return ProtoEvtUnknow{req_error}; // æ”¹ä¸º ProtoEvt å‰ç¼€
}

========== ./app/ClientEventEnum.h ==========
Lines: 77

//ClientEventEnum.h
#pragma once
#include <string>

enum class EventType {
    // ===== UI å‘½ä»¤ =====
    CmdConnect,
    CmdDisconnect,
    CmdLogin,

    // ===== TCP =====
    TcpConnected,
    TcpDisconnected,

    // ===== åè®® =====
    LoginOk,
    LoginFail,
    OnlineUsers,
    Unknow,

    HeartbeatOk,
    HeartbeatTimeout,
    HeartbeatTick,

    SelectLan,
    SelectVpn,
    CmdSendText,
    ForwardText,
    CmdCall,
    CallIncoming,
    CallAccepted,
    CallRejected,
    CmdAcceptCall,
    CmdRejectCall,
    MediaPeer,
    CmdHangup,
    CallEnded
    // CallIncoming,    // æ”¶åˆ°æ¥ç”µ
    // CallAccepted,    // é€šè¯è¢«æ¥å¬
    // CallRejected,    // é€šè¯è¢«æ‹’ç»
    // MediaOfferResp,  // åª’ä½“Offerå“åº”
    // MediaAnswerResp  // åª’ä½“Answerå“åº”
};


inline std::string EventTypeToString(EventType type) {
    // ä½¿ç”¨switch-caseç²¾å‡†æ˜ å°„æ¯ä¸ªæšä¸¾å€¼
    switch (type) {
    case EventType::CmdConnect:        return "InCmdConnect";
    case EventType::CmdDisconnect:     return "InCmdDisconnect";
    case EventType::CmdLogin:          return "InCmdLogin";
    case EventType::TcpConnected:      return "InTcpConnected";
    case EventType::TcpDisconnected:   return "InTcpDisconnected";
    case EventType::LoginOk:           return "InLoginOk";
    case EventType::LoginFail:         return "InLoginFail";
    case EventType::OnlineUsers:       return "InOnlineUsers";
    case EventType::Unknow:            return "InUnknow";
    case EventType::HeartbeatOk:       return "InHeartbeatOk";
    case EventType::HeartbeatTimeout:  return "InHeartbeatTimeout";
    case EventType::HeartbeatTick:     return "InHeartbeatTick";
    case EventType::SelectLan:         return "InSelectLan";
    case EventType::SelectVpn:         return "InSelectVpn";
    case EventType::CmdSendText:       return "InCmdSendText";
    case EventType::ForwardText:       return "InForwardText";
    case EventType::CmdCall:           return "InCmdCall";
    case EventType::CallIncoming:      return "InCallIncoming";
    case EventType::CallAccepted:      return "InCallAccepted";
    case EventType::CallRejected:      return "InCallRejected";
    case EventType::CmdAcceptCall:     return "InCmdAcceptCall";
    case EventType::CmdRejectCall:     return "InCmdRejectCall";
    case EventType::MediaPeer:         return "InMediaPeer";
    case EventType::CmdHangup:         return "InCmdHangup";
    case EventType::CallEnded:         return "InCallEnded";
    // å¤„ç†æœªåŒ¹é…åˆ°çš„æšä¸¾å€¼ï¼ˆå¥å£®æ€§ä¿éšœï¼‰
    default: return "InUnknownEventType";
    }
}

========== ./media/VideoReceiver.h ==========
Lines: 33

//VideoReceiver.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

// å’ŒCameraManagerå®Œå…¨å¯¹ç§°çš„æ¥æ”¶ç±»
class VideoReceiver {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    VideoReceiver();
    ~VideoReceiver();

    // è®¾ç½®å¸§å›è°ƒï¼ˆæ¨ç»™Qt UIï¼‰
    void setFrameCallback(FrameCallback cb);
    // å¯åŠ¨æ¥æ”¶ï¼ˆç›‘å¬æŒ‡å®šUDPç«¯å£ï¼‰
    bool start(int listenPort);
    // åœæ­¢æ¥æ”¶
    void stop();

private:
    // appsinkå›è°ƒå‡½æ•°ï¼ˆå¤ç”¨CameraManagerçš„é€»è¾‘ï¼‰
    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);

private:
    GstElement* pipeline_ = nullptr;  // æ¥æ”¶ç«¯ç‹¬ç«‹pipeline
    GstElement* appsink_  = nullptr;  // æ¥æ”¶ç«¯appsink
    FrameCallback callback_;          // å¸§å›è°ƒ
};

========== ./media/CameraManager.cpp ==========
Lines: 111

//CameraManager.cpp
#include "CameraManager.h"
#include <iostream>
#include <cstring>

CameraManager::CameraManager() {
    gst_init(nullptr, nullptr);
}

CameraManager::~CameraManager() {
    stop();
}

void CameraManager::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool CameraManager::start(const std::string& device, const std::string& udpHost, int udpPort) {
    // æ–°å¢ï¼šå‚æ•°åˆæ³•æ€§æ ¡éªŒï¼ˆé¿å…æ— æ•ˆé…ç½®å¯¼è‡´æ¨æµå¤±è´¥ï¼‰
    if (udpHost.empty()) {
        std::cout << "[CameraManager] Error: UDP host IP cannot be empty\n";
        return false;
    }
    if ( (udpPort < 1) || (udpPort > 65535) ) {
        std::cout << "[CameraManager] Error: UDP port must be between 1 and 65535 (got: " << udpPort << ")\n";
        return false;
    }

    if (pipeline_) return true;
    std::cout << "[CameraManager] Attempting to start camera: " << device << std::endl;
    // æ ¸å¿ƒä¿®æ”¹ï¼šç”¨è¾“å…¥å‚æ•°udpHostã€udpPortæ›¿æ¢ç¡¬ç¼–ç çš„192.168.6.15å’Œ5000
    std::string pipelineStr =
        "v4l2src device=" + device +
        " ! video/x-raw,format=YUY2,width=640,height=480,framerate=30/1 "
        " ! videoconvert "
        " ! openh264enc bitrate=2000000 "
        " ! h264parse "
        " ! tee name=t "
        " t. ! queue "
        "     ! avdec_h264 "
        "     ! videoconvert "
        "     ! video/x-raw,format=RGB "
        "     ! appsink name=sink "
        " t. ! queue "
        "     ! rtph264pay pt=96 config-interval=1 "
        // å…³é”®æ›¿æ¢ï¼šhost=${udpHost} port=${udpPort}
        "     ! udpsink host=" + udpHost + " port=" + std::to_string(udpPort) + " sync=false async=false";

    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "Failed to create pipeline\n";
        return false;
    }

    /* appsink ç”¨äº Qt æ˜¾ç¤º */
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "sink");

    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1);

    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    std::cout << "[CameraManager] Camera started successfully: " << device
              << " | UDP push to: " << udpHost << ":" << udpPort << std::endl;
    return true;
}
void CameraManager::stop() {
    if (!pipeline_) return;

    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn CameraManager::onNewSample(GstAppSink* sink, gpointer user_data) {
    auto* self = static_cast<CameraManager*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3;
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    self->callback_(frame);

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

========== ./media/CameraManager.h ==========
Lines: 29

//CameraManager.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

class CameraManager {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    CameraManager();
    ~CameraManager();

    bool start(const std::string& device, const std::string& udpHost, int udpPort);
    void stop();

    void setFrameCallback(FrameCallback cb);

private:
    GstElement* pipeline_ = nullptr;
    GstElement* appsink_  = nullptr;

    FrameCallback callback_;

    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);
};

========== ./media/Frame.h ==========
Lines: 19

//Frame.h
#pragma once
#include <vector>
#include <cstdint>
#include <QMetaType>   // âš ï¸ å¿…é¡»åŠ è¿™ä¸€è¡Œ
enum class PixelFormat {
    RGB888
};

struct Frame {
    std::vector<uint8_t> data; // è¿ç»­å†…å­˜
    int width = 0;
    int height = 0;
    int stride = 0;
    PixelFormat format;
    uint64_t timestamp = 0;
};

Q_DECLARE_METATYPE(Frame)

========== ./media/VideoReceiver.cpp ==========
Lines: 107

//VideoReceiver.cpp
#include "VideoReceiver.h"
#include <iostream>
#include <cstring>

VideoReceiver::VideoReceiver() {
    // åˆå§‹åŒ–GStreamerï¼ˆå’ŒCameraManagerä¿æŒä¸€è‡´ï¼‰
    gst_init(nullptr, nullptr);
}

VideoReceiver::~VideoReceiver() {
    stop(); // ææ„æ—¶ç¡®ä¿åœæ­¢pipeline
}

void VideoReceiver::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool VideoReceiver::start(int listenPort) {
    // æ ¡éªŒç«¯å£åˆæ³•æ€§
    if ((listenPort < 1) || (listenPort > 65535)) {
        std::cerr << "[VideoReceiver] Invalid listen port: " << listenPort << std::endl;
        return false;
    }

    if (pipeline_) return true; // é¿å…é‡å¤å¯åŠ¨

    // æ ¸å¿ƒï¼šæ¥æ”¶ç«¯pipelineå­—ç¬¦ä¸²ï¼ˆappsinkç‰ˆï¼Œé€‚é…Qt RGBæ˜¾ç¤ºï¼‰
    std::string pipelineStr =
        "udpsrc port=" + std::to_string(listenPort) +
        " caps=\"application/x-rtp,media=video,encoding-name=H264,payload=96\" "
        " ! rtph264depay "          // RTPè§£åŒ…ï¼ˆå»æ‰RTPå¤´ï¼‰
        " ! h264parse "             // H264è§£æï¼ˆä¿è¯è§£ç å™¨è¾“å…¥ç¨³å®šï¼‰
        " ! avdec_h264 "            // H264è½¯ä»¶è§£ç ï¼ˆå…¼å®¹æ‰€æœ‰å¹³å°ï¼‰
        " ! videoconvert "          // é¢œè‰²ç©ºé—´è½¬æ¢ï¼ˆè§£ç åå¯èƒ½æ˜¯YUVï¼Œè½¬RGBï¼‰
        " ! video/x-raw,format=RGB "// å’ŒQtæ˜¾ç¤ºæ ¼å¼å®Œå…¨ä¸€è‡´ï¼ˆRGB888ï¼‰
        " ! appsink name=recv_sink "; // æ¥æ”¶ç«¯appsinkï¼ˆå‘½åä¸ºrecv_sinkï¼Œé¿å…å’Œå‘é€ç«¯å†²çªï¼‰

    // åˆ›å»ºpipeline
    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "[VideoReceiver] Failed to create pipeline" << std::endl;
        return false;
    }

    // é…ç½®appsinkï¼ˆå’ŒCameraManageré€»è¾‘å®Œå…¨å¤ç”¨ï¼‰
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "recv_sink");
    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1); // åªä¿ç•™æœ€æ–°å¸§ï¼Œé¿å…å¡é¡¿

    // ç»‘å®šnew-sampleä¿¡å·ï¼ˆå¸§å›è°ƒï¼‰
    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    // å¯åŠ¨pipeline
    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    std::cout << "[VideoReceiver] Started successfully, listen on UDP port: " << listenPort << std::endl;
    return true;
}

void VideoReceiver::stop() {
    if (!pipeline_) return;

    // åœæ­¢pipelineå¹¶é‡Šæ”¾èµ„æºï¼ˆGStreameræ ‡å‡†æ“ä½œï¼‰
    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn VideoReceiver::onNewSample(GstAppSink* sink, gpointer user_data) {
    // å®Œå…¨å¤ç”¨CameraManagerçš„å¸§å¤„ç†é€»è¾‘ï¼ˆä¿è¯å’Œå‘é€ç«¯æ ¼å¼ä¸€è‡´ï¼‰
    auto* self = static_cast<VideoReceiver*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3; // RGB888ï¼šæ¯è¡Œå­—èŠ‚æ•°=å®½åº¦Ã—3
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    // è°ƒç”¨å›è°ƒï¼ŒæŠŠå¸§æ¨ç»™Qt UI
    self->callback_(frame);

    // é‡Šæ”¾èµ„æºï¼ˆGStreamerå†…å­˜ç®¡ç†å¿…é¡»åšï¼‰
    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}


=====================================
Total files: 43
Total lines: 3713
