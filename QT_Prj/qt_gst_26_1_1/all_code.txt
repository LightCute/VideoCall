========== å·¥ç¨‹ç›®å½•ç»“æ„ï¼ˆä»…å«.h/.cppï¼‰==========

ğŸ“‚ .:
  â””â”€ main.cpp

ğŸ“‚ ./util:
  â””â”€ GetLocalIP.h

ğŸ“‚ ./core:
  â””â”€ ClientCore.cpp
  â””â”€ ClientCore.h
  â””â”€ ClientState.h
  â””â”€ CoreExecutor.cpp
  â””â”€ CoreExecutor.h
  â””â”€ CoreInput.h
  â””â”€ CoreOutput.h
  â””â”€ FSM.cpp
  â””â”€ FSM.h
  â””â”€ ICoreListener.h

ğŸ“‚ ./net:
  â””â”€ CommandSocket.cpp
  â””â”€ CommandSocket.h
  â””â”€ PacketCodec.h

ğŸ“‚ ./ui:
  â””â”€ AppWindow.cpp
  â””â”€ AppWindow.h
  â””â”€ LoginWidget.cpp
  â””â”€ LoginWidget.h
  â””â”€ QtCameraAdapter.cpp
  â””â”€ QtCameraAdapter.h
  â””â”€ VideoWidget.cpp
  â””â”€ VideoWidget.h
  â””â”€ widget.cpp
  â””â”€ widget.h

ğŸ“‚ ./protocol:
  â””â”€ protocol_common.h
  â””â”€ protocol_text.cpp
  â””â”€ protocol_text.h
  â””â”€ protocol_types.h

ğŸ“‚ ./app:
  â””â”€ ClientEvent.h
  â””â”€ ClientEventEnum.h
  â””â”€ ClientEventFactory.cpp
  â””â”€ ClientEventFactory.h

ğŸ“‚ ./media:
  â””â”€ CameraManager.cpp
  â””â”€ CameraManager.h
  â””â”€ Frame.h
  â””â”€ VideoReceiver.cpp
  â””â”€ VideoReceiver.h

==================================================
========== æ‰€æœ‰.h/.cppæ–‡ä»¶å†…å®¹ ==========


========== ./main.cpp ==========
Lines: 37

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <variant>

#ifdef slots
#undef slots
#endif
#ifdef signals
#undef signals
#endif

#include <QApplication>
#include "widget.h"
#include "LoginWidget.h"
#include "AppWindow.h"
#include "core/CoreOutput.h"
// #include "widget.h"
// #include "LoginWidget.h"
// #include <QApplication>
// #include "AppWindow.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    qRegisterMetaType<Frame>("Frame");
    qRegisterMetaType<core::CoreOutput>("core::CoreOutput");  // æ–°å¢
    AppWindow w;
    //LoginWidget login_W;
    //login_W.show();
    w.show();
    return a.exec();
}

========== ./util/GetLocalIP.h ==========
Lines: 51

#include <arpa/inet.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <netdb.h>
std::string getLocalLanIP()
{
    struct ifaddrs *ifaddr, *ifa;
    char host[NI_MAXHOST];

    // è·å–æ‰€æœ‰ç½‘ç»œæ¥å£ä¿¡æ¯ï¼Œå¤±è´¥åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs failed"); // æ‰“å°é”™è¯¯ä¿¡æ¯
        return "";
    }

    std::string result = "";

    // éå†æ‰€æœ‰ç½‘ç»œæ¥å£
    for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr) continue;

        // ç­›é€‰IPv4åœ°å€ï¼ˆAF_INETï¼‰
        if (ifa->ifa_addr->sa_family == AF_INET) {
            void* addr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
            // å°†äºŒè¿›åˆ¶IPè½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼
            inet_ntop(AF_INET, addr, host, NI_MAXHOST);

            std::string ip = host;

            // è¿‡æ»¤å›ç¯åœ°å€ï¼ˆ127.0.0.1ï¼‰ï¼Œå–ç¬¬ä¸€ä¸ªéå›ç¯çš„LAN IP
            if (ip != "127.0.0.1") {
                result = ip;
                break;
            }
        }
    }

    // é‡Šæ”¾æ¥å£ä¿¡æ¯å†…å­˜
    freeifaddrs(ifaddr);
    return result;
}


std::string getVpnIp()
{
    return "10.0.0.1";
}

========== ./core/ClientCore.cpp ==========
Lines: 251

#include "ClientCore.h"
#include <algorithm>

// æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ– Executorï¼Œè®¾ç½®å›è°ƒ
ClientCore::ClientCore() : fsm_() {
    // åˆå§‹åŒ– Executorï¼šå›è°ƒå‡½æ•°ç”¨äºæ¥æ”¶ Executor æ¨é€çš„ CoreInput
    executor_ = std::make_unique<CoreExecutor>(
        [this](core::CoreInput ev) {
            this->postInput(std::move(ev)); // å°† Executor çš„äº‹ä»¶æ¨å…¥è¾“å…¥é˜Ÿåˆ—
        }
        );
    // å¯åŠ¨äº‹ä»¶å¤„ç†çº¿ç¨‹ï¼ˆä»…è°ƒåº¦ï¼Œæ—  IOï¼‰
    std::thread([this]{ processEvents(); }).detach();
}

ClientCore::~ClientCore() {
    // é‡Šæ”¾ Executor èµ„æº
    stop();
    if (executor_) {
        executor_->stop();
    }
}

void ClientCore::stop() {
    is_running_ = false;
    cv_.notify_one(); // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ï¼Œä½¿å…¶é€€å‡ºå¾ªç¯
}
// åŸ postInput/pollOutput é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::postInput(core::CoreInput ev) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        inputQueue_.push(std::move(ev));
    }
    cv_.notify_one();
}

// æ–°å¢ï¼šæ·»åŠ ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::addListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.push_back(listener);
}

// æ–°å¢ï¼šç§»é™¤ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::removeListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.erase(
        std::remove(listeners_.begin(), listeners_.end(), listener),
        listeners_.end()
        );
}

// æ–°å¢ï¼šå¹¿æ’­è¾“å‡ºäº‹ä»¶ç»™æ‰€æœ‰ç›‘å¬è€…ï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼‰
void ClientCore::broadcastOutput(const core::CoreOutput& out) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    for (auto* listener : listeners_) {
        listener->onCoreOutput(out); // è°ƒç”¨ç›‘å¬è€…çš„å›è°ƒï¼ˆCore çº¿ç¨‹ï¼‰
    }
}


// bool ClientCore::pollOutput(core::CoreOutput& out) { // è¡¥å…… core:: å‰ç¼€
//     std::lock_guard<std::mutex> lock(mtx_);
//     if (outputQueue_.empty()) return false;
//     out = std::move(outputQueue_.front());
//     outputQueue_.pop();
//     return true;
// }

// åŸ processEvents é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::processEvents() {
    while (is_running_) {
        core::CoreInput ev;
        {
            std::unique_lock<std::mutex> lock(mtx_);
            cv_.wait(lock, [this]{ return !inputQueue_.empty(); });
            ev = std::move(inputQueue_.front());
            inputQueue_.pop();
            std::cout << "[ClientCore] Processing Input event, remaining queue size: " << inputQueue_.size()
                      << ", Event type : " <<  core::CoreInputIndexToName(ev.index())  << std::endl;
        }

        auto outputs = fsm_.handle(state_, ev);
        {
            std::lock_guard<std::mutex> lock(mtx_);
            for (auto& o : outputs) {
                handleOutput(std::move(o));
            }
        }
    }
}

// åŸ handleOutput/applyStateChange é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::handleOutput(core::CoreOutput&& o) { // è¡¥å…… core:: å‰ç¼€
    std::visit([this](auto&& e){
        using T = std::decay_t<decltype(e)>;

        if constexpr (std::is_same_v<T, core::OutStateChanged>) { // è¡¥å…… core:: å‰ç¼€
            applyStateChange(e);
            broadcastOutput(e); // Broadcast state change
        }
        else if constexpr (std::is_same_v<T, core::OutConnect>) { // è¡¥å…… core:: å‰ç¼€
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendLogin>) { // è¡¥å…… core:: å‰ç¼€
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendPing>) {
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutUpdateAlive>) {
            execute(e);
            broadcastOutput(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSelectLan>) {
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSelectVpn>) {
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutLoginOk>) {
            execute(e);
            broadcastOutput(e);
        }
        // æ–°å¢ï¼šå¤„ç†å‘é€æ–‡æœ¬æ¶ˆæ¯
        else if constexpr (std::is_same_v<T, core::OutSendText>) {
            execute(e);
        }
        // æ–°å¢ï¼šå¹¿æ’­è½¬å‘æ–‡æœ¬æ¶ˆæ¯ç»™UI
        else if constexpr (std::is_same_v<T, core::OutForwardText>) {
            broadcastOutput(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendCall>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutSendAcceptCall>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutSendRejectCall>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutSendMediaOffer>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutSendMediaAnswer>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutShowIncomingCall>)
            execute(e);
        else if constexpr (std::is_same_v<T, core::OutMediaReady>)
            execute(e);
        else {
            // outputQueue_.push(std::move(e));
            broadcastOutput(e); // å¹¿æ’­å…¶ä»–äº‹ä»¶
        }
    }, std::move(o));
}

void ClientCore::applyStateChange(const core::OutStateChanged& e) { // è¡¥å…… core:: å‰ç¼€
    std::cout << "[Core] State: "
              << stateToString(e.from)
              << " -> "
              << stateToString(e.to)
              << std::endl;

    state_ = e.to;
    //outputQueue_.push(e);
}

// å…³é”®ä¿®æ”¹ï¼šexecute ä»…è°ƒç”¨ Executor æ¥å£ï¼Œæ—  IO é€»è¾‘ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::execute(const core::OutConnect& e) { // è¡¥å…… core:: å‰ç¼€
    // è°ƒåº¦ Executor æ‰§è¡Œè¿æ¥ï¼ˆCore ä»…å‘å‘½ä»¤ï¼Œä¸åšå…·ä½“æ“ä½œï¼‰
    executor_->connectToServer(e.host, e.port);
}

void ClientCore::execute(const core::OutSendLogin& e) { // è¡¥å…… core:: å‰ç¼€
    // è°ƒåº¦ Executor å‘é€ç™»å½•è¯·æ±‚
    executor_->sendLoginRequest(e.user, e.pass);
}

void ClientCore::execute(const core::OutSendPing&) {
    executor_->sendPing();
}

void ClientCore::execute(const core::OutUpdateAlive&) {
    std::cout << "[Executor] Received PONG from server" << std::endl;
}

void ClientCore::execute(const core::OutSelectLan&) {
    std::cout << "[Executor] Select LAN" << std::endl;
    executor_->setLanMode();
}

void ClientCore::execute(const core::OutSelectVpn&) {
    std::cout << "[Executor] Select VPN" << std::endl;
    executor_->setVpnMode();
}

void ClientCore::execute(const core::OutLoginOk&) {
    std::cout << "[Executor] OutLoginOk" << std::endl;
    executor_->sendLocalIP();
}

void ClientCore::execute(const core::OutSendText& e) {
    executor_->sendTextMsg(e.target_user, e.content);
}

void ClientCore::execute(const core::OutForwardText&) {
    std::cout << "[Executor] OutForwardText" << std::endl;
}

// å‘é€å‘¼å«è¯·æ±‚
void ClientCore::execute(const core::OutSendCall& e) {
    isCaller_ = true;
    executor_->sendCallRequest(e.target_user);
}

// å‘é€æ¥å¬è¯·æ±‚
void ClientCore::execute(const core::OutSendAcceptCall& e) {
    executor_->sendAcceptCall();
}

// å‘é€æ‹’ç»è¯·æ±‚
void ClientCore::execute(const core::OutSendRejectCall& e) {
    executor_->sendRejectCall();
}

// å‘é€åª’ä½“Offer
void ClientCore::execute(const core::OutSendMediaOffer& e) {
    executor_->sendMediaOffer(e.peer);
}

// å‘é€åª’ä½“Answer
void ClientCore::execute(const core::OutSendMediaAnswer& e) {
    executor_->sendMediaAnswer(e.peer);
}

// é€šçŸ¥UIå¼¹å‡ºæ¥ç”µ
void ClientCore::execute(const core::OutShowIncomingCall& e) {
    broadcastOutput(e); // å¹¿æ’­ç»™UIç›‘å¬è€…
}

// åª’ä½“ä¿¡æ¯å°±ç»ªï¼Œå¯åŠ¨UDP
void ClientCore::execute(const core::OutMediaReady& e) {
    // æ ¸å¿ƒï¼šç”¨CoreExecutorçš„mode_é€‰æ‹©æœ€ç»ˆIP
    peerIp_ = executor_->selectPeerIp(e.lanIp, e.vpnIp);
    peerPort_ = e.peerPort;

    std::cout << "[ClientCore] MediaReady -> use IP: " << peerIp_ << ":" << peerPort_ << std::endl;

    // å¹¿æ’­æœ€ç»ˆIPï¼ˆè€Œéå€™é€‰IPï¼‰ç»™åª’ä½“å±‚
    broadcastOutput(core::OutMediaReadyFinal{peerIp_, peerPort_});
}

// åºŸå¼ƒåŸ socket æ“ä½œæ¥å£ï¼ˆå¯ç›´æ¥åˆ é™¤ï¼‰
// bool ClientCore::connectToServer(const std::string& host, int port) { ... }
// void ClientCore::sendLogin(const std::string& user, const std::string& pass) { ... }

========== ./core/FSM.h ==========
Lines: 36

// core/FSM.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "ClientState.h"
#include <vector>
#include <functional>
#include "ClientEventEnum.h"
#include <variant>
#include <iostream>

struct FSMEntry {
    State current_state;
    EventType event_type;
    // è¡¥å…… core:: å‰ç¼€
    std::function<std::vector<core::CoreOutput>(
        State current,
        const core::CoreInput&
        )> action;
    State next_state;
};

class FSM {
public:
    FSM();

    // è¡¥å…… core:: å‰ç¼€
    std::vector<core::CoreOutput>
    handle(State current, const core::CoreInput& ev);

private:
    EventType eventTypeFromInput(const core::CoreInput& ev);
    bool isOnlineState(State s);
    std::vector<FSMEntry> table_;
    void initTable();
};

========== ./core/CoreInput.h ==========
Lines: 117

// core/CoreInput.h
#pragma once
#include <variant>
#include <string>
#include <vector>
namespace core {

struct OnlineUser {
    std::string name;
    int privilege;

    std::string lan_ip;   // å±€åŸŸç½‘ IP
    std::string vpn_ip;   // VPN IPï¼ˆæœªæ¥å¯ç”¨ï¼‰
    int media_port;       // GStreamer/UDP è§†é¢‘ç«¯å£
};


struct InCmdSendText { std::string target_user; std::string content; };

struct InForwardText { std::string from_user; std::string content; };

// æ‰€æœ‰ Core è¾“å…¥äº‹ä»¶å‰ç¼€æ”¹ä¸º In
struct InCmdConnect { std::string host; int port; };
struct InCmdDisconnect {};
struct InCmdLogin { std::string user; std::string pass; };
struct InTcpConnected {};
struct InTcpDisconnected {};
struct InLoginOk {};
struct InLoginFail { std::string msg; };
struct InOnlineUsers { std::vector<OnlineUser> users; };
struct InUnknow {};
struct InHeartbeatOk {};      // æ”¶åˆ° PONG
struct InHeartbeatTimeout {}; // å¿ƒè·³è¶…æ—¶
struct InHeartbeatTick {};    // Send PING
struct InSelectLan {};
struct InSelectVpn {};

// å‘èµ·å‘¼å«
struct InCmdCall { std::string target_user; };
// æ”¶åˆ°æ¥ç”µ
struct InCallIncoming { std::string from; };
// é€šè¯è¢«æ¥å¬
struct InCallAccepted { std::string peer; };
// é€šè¯è¢«æ‹’ç»
struct InCallRejected { std::string peer; };
// ç”¨æˆ·æ¥å¬/æ‹’ç»é€šè¯
struct InCmdAcceptCall {};
struct InCmdRejectCall {};
// åª’ä½“åå•†å“åº”
struct InMediaPeer {
    std::string peer;
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};



using CoreInput = std::variant<
    InCmdConnect,
    InCmdDisconnect,
    InCmdLogin,
    InTcpConnected,
    InTcpDisconnected,
    InLoginOk,
    InLoginFail,
    InOnlineUsers,
    InUnknow,
    InHeartbeatOk,
    InHeartbeatTimeout,
    InHeartbeatTick,
    InSelectLan,
    InSelectVpn,
    InCmdSendText,
    InForwardText,
    InCmdCall,
    InCallIncoming,
    InCallAccepted,
    InCallRejected,
    InCmdAcceptCall,
    InCmdRejectCall,
    InMediaPeer
    >;


inline std::string CoreInputIndexToName(size_t index) {
    // ä¸¥æ ¼æŒ‰ç…§CoreInput variantçš„ç±»å‹é¡ºåºæ˜ å°„ç´¢å¼•å’Œåç§°
    switch (index) {
    case 0:  return "InCmdConnect";
    case 1:  return "InCmdDisconnect";
    case 2:  return "InCmdLogin";
    case 3:  return "InTcpConnected";
    case 4:  return "InTcpDisconnected";
    case 5:  return "InLoginOk";
    case 6:  return "InLoginFail";
    case 7:  return "InOnlineUsers";
    case 8:  return "InUnknow";
    case 9:  return "InHeartbeatOk";
    case 10: return "InHeartbeatTimeout";
    case 11: return "InHeartbeatTick";
    case 12: return "InSelectLan";
    case 13: return "InSelectVpn";
    case 14: return "InCmdSendText";
    case 15: return "InForwardText";
    case 16: return "InCmdCall";
    case 17: return "InCallIncoming";
    case 18: return "InCallAccepted";
    case 19: return "InCallRejected";
    case 20: return "InCmdAcceptCall";
    case 21: return "InCmdRejectCall";
    case 22: return "InMediaPeer";
    // å…œåº•ï¼šç´¢å¼•è¶…å‡ºèŒƒå›´æ—¶è¿”å›æç¤ºï¼ˆé˜²æ­¢æ–°å¢ç±»å‹æœªæ›´æ–°å‡½æ•°ï¼‰
    default: return "InUnknownCoreInputType";
    }
}

}

========== ./core/FSM.cpp ==========
Lines: 392

// core/FSM.cpp
#include "FSM.h"

FSM::FSM() {
    initTable();
}

bool FSM::isOnlineState(State s) {
    return s != State::Disconnected;
}

// è¡¥å…… core:: å‰ç¼€
std::vector<core::CoreOutput>
FSM::handle(State current, const core::CoreInput& ev)
{
    EventType evType = eventTypeFromInput(ev);
    std::cout << "[FSM] Current state: " << stateToString(current)
              << ", Received event type: " << EventTypeToString(evType) << std::endl;
    if (isOnlineState(current) && evType == EventType::HeartbeatTick) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨
        std::cout << "[FSM] Online state, directly handle HeartbeatTick event" << std::endl;
        return { core::OutSendPing{} };
    }

    else if (isOnlineState(current) && evType == EventType::HeartbeatOk) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨
        return { core::OutUpdateAlive{} };
    }

    for (auto& entry : table_) {
        if (entry.current_state == current &&
            entry.event_type == evType) {

            auto outputs = entry.action(current, ev);
            return outputs;
        }
    }
    return {};
}

EventType FSM::eventTypeFromInput(const core::CoreInput& ev) {
    EventType evType = EventType::Unknow;
    std::visit([&evType](auto&& e){
        using T = std::decay_t<decltype(e)>;
        // å…¨éƒ¨æ›¿æ¢ä¸º InXXX å‰ç¼€
        if constexpr (std::is_same_v<T, core::InCmdConnect>)      evType = EventType::CmdConnect;
        else if constexpr (std::is_same_v<T, core::InCmdDisconnect>) evType = EventType::CmdDisconnect;
        else if constexpr (std::is_same_v<T, core::InCmdLogin>)   evType = EventType::CmdLogin;

        else if constexpr (std::is_same_v<T, core::InTcpConnected>)    evType = EventType::TcpConnected;
        else if constexpr (std::is_same_v<T, core::InTcpDisconnected>) evType = EventType::TcpDisconnected;

        else if constexpr (std::is_same_v<T, core::InLoginOk>)   evType = EventType::LoginOk;
        else if constexpr (std::is_same_v<T, core::InLoginFail>) evType = EventType::LoginFail;
        else if constexpr (std::is_same_v<T, core::InOnlineUsers>) evType = EventType::OnlineUsers;

        else if constexpr (std::is_same_v<T, core::InHeartbeatOk>)
            evType = EventType::HeartbeatOk;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTimeout>)
            evType = EventType::HeartbeatTimeout;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTick>)
            evType = EventType::HeartbeatTick;

        else if constexpr (std::is_same_v<T, core::InSelectLan>)
            evType = EventType::SelectLan;

        else if constexpr (std::is_same_v<T, core::InSelectVpn>)
            evType = EventType::SelectVpn;

        else if constexpr (std::is_same_v<T, core::InCmdSendText>)
            evType = EventType::CmdSendText;

        else if constexpr (std::is_same_v<T, core::InForwardText>)
            evType = EventType::ForwardText;

        else if constexpr (std::is_same_v<T, core::InCmdCall>)
            evType = EventType::CmdCall;
        else if constexpr (std::is_same_v<T, core::InCallIncoming>)
            evType = EventType::CallIncoming;
        else if constexpr (std::is_same_v<T, core::InCallAccepted>)
            evType = EventType::CallAccepted;
        else if constexpr (std::is_same_v<T, core::InCallRejected>)
            evType = EventType::CallRejected;
        else if constexpr (std::is_same_v<T, core::InCmdAcceptCall>)
            evType = EventType::CmdAcceptCall;
        else if constexpr (std::is_same_v<T, core::InCmdRejectCall>)
            evType = EventType::CmdRejectCall;
        else if constexpr (std::is_same_v<T, core::InMediaPeer>)
            evType = EventType::MediaPeer;

        else evType = EventType::Unknow;
    }, ev);
    return evType;
}

void FSM::initTable() {
    table_ = {
          // ===== æ–­å¼€æ€ =====
          { State::Disconnected, EventType::CmdConnect,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InCmdConnect
                  if (auto e = std::get_if<core::InCmdConnect>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::Connecting}); // è¡¥å…… core::
                      out.push_back(core::OutConnect{e->host, e->port}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connecting
          },

          // ===== æ­£åœ¨è¿æ¥ =====
          { State::Connecting, EventType::TcpConnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InTcpConnected
                  if (auto e = std::get_if<core::InTcpConnected>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::Connected}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connected
          },

          { State::Connecting, EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){ return std::vector<core::CoreOutput>{}; },
              State::Disconnected
          },

          // ===== å·²è¿æ¥ =====
          { State::Connected, EventType::CmdLogin,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InCmdLogin
                  if (auto e = std::get_if<core::InCmdLogin>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::LoggingIn}); // è¡¥å…… core::
                      out.push_back(core::OutSendLogin{e->user, e->pass}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::LoggingIn
          },

          // ===== æ­£åœ¨ç™»å½• =====
          { State::LoggingIn, EventType::LoginOk ,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InLoginOk
                  if (auto e = std::get_if<core::InLoginOk>(&ev)) {
                      out.push_back(core::OutLoginOk{}); // è¡¥å…… core::
                      out.push_back(core::OutStateChanged{cur, State::LoggedIn}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::LoggedIn
          },

          { State::LoggingIn, EventType::LoginFail ,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InLoginFail
                  if (auto e = std::get_if<core::InLoginFail>(&ev)) {
                      out.push_back(core::OutLoginFail{e->msg}); // è¡¥å…… core::
                      out.push_back(core::OutStateChanged{cur, State::Connected}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connected
          },

          // ===== ä»»ä½•åœ¨çº¿çŠ¶æ€æ–­çº¿ =====
          { State::Connected,  EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },
          { State::LoggingIn,  EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },
          { State::LoggedIn,   EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },

        { State::LoggedIn, EventType::OnlineUsers,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;

                if (auto e = std::get_if<core::InOnlineUsers>(&ev)) {
                    out.push_back(core::OutOnlineUsers{e->users});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::SelectLan,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;

                if (auto e = std::get_if<core::InSelectLan>(&ev)) {
                    out.push_back(core::OutSelectLan{});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::SelectVpn,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;

                if (auto e = std::get_if<core::InSelectVpn>(&ev)) {
                    out.push_back(core::OutSelectVpn{});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::CmdSendText,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdSendText>(&ev)) {
                    out.push_back(core::OutSendText{e->target_user, e->content});
                }
                return out;
            },
            State::LoggedIn
        },

        { State::LoggedIn, EventType::ForwardText,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InForwardText>(&ev)) {
                    out.push_back(core::OutForwardText{e->from_user, e->content});
                }
                return out;
            },
            State::LoggedIn
        },

        // 1. LoggedInçŠ¶æ€ä¸‹å‘èµ·å‘¼å«
        { State::LoggedIn, EventType::CmdCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCmdCall>(&ev)) {
                    out.push_back(core::OutStateChanged{cur, State::CALLING});
                    out.push_back(core::OutSendCall{e->target_user});
                }
                return out;
            },
            State::CALLING
        },

        // 2. LoggedInçŠ¶æ€ä¸‹æ”¶åˆ°æ¥ç”µ
        { State::LoggedIn, EventType::CallIncoming,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallIncoming>(&ev)) {
                    out.push_back(core::OutStateChanged{cur, State::RINGING});
                    out.push_back(core::OutShowIncomingCall{e->from});
                }
                return out;
            },
            State::RINGING
        },

        // 3. RINGINGçŠ¶æ€ä¸‹ç”¨æˆ·æ¥å¬
        { State::RINGING, EventType::CmdAcceptCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
             if (auto e = std::get_if<core::InCmdAcceptCall>(&ev))
             {
                 out.push_back(core::OutSendAcceptCall{});
                 //out.push_back(core::OutSendMediaOffer{e->peer});
             }
                return out;
            },
            State::RINGING
        },

        // 4. RINGINGçŠ¶æ€ä¸‹ç”¨æˆ·æ‹’ç»
        { State::RINGING, EventType::CmdRejectCall,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
             if (auto e = std::get_if<core::InCmdRejectCall>(&ev))
                {
                    out.push_back(core::OutSendRejectCall{});
                    out.push_back(core::OutStateChanged{cur, State::LoggedIn});
                }
                return out;
            },
            State::LoggedIn
        },

        // 5. CALLING/RINGINGçŠ¶æ€ä¸‹æ”¶åˆ°é€šè¯è¢«æ¥å¬
        { State::CALLING, EventType::CallAccepted,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallAccepted>(&ev)) {
                    out.push_back(core::OutStateChanged{cur, State::IN_CALL});
                    out.push_back(core::OutSendMediaOffer{e->peer});
                }
                return out;
            },
            State::IN_CALL
        },

        { State::CALLING, EventType::MediaPeer,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InMediaPeer>(&ev)) {
                    //std::string peerIp = !e->vpnIp.empty() ? e->vpnIp : e->lanIp;
                    std::string peerIp = e->lanIp;
                    out.push_back(core::OutStateChanged{cur, State::MEDIA_READY});
                    out.push_back(core::OutMediaReady{e->lanIp, e->vpnIp, e->udpPort});
                    // CALLING çŠ¶æ€ä¸‹æ”¶åˆ° MediaPeerï¼Œè¯´æ˜æ˜¯è¢«åŠ¨æ–¹æ”¶åˆ° OFFER_RESPï¼Œéœ€è¦å‘é€ ANSWER
                    out.push_back(core::OutSendMediaAnswer{e->peer});
                }
                return out;
            },
            State::MEDIA_READY
        },

        { State::RINGING, EventType::CallAccepted,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InCallAccepted>(&ev)) {
                    out.push_back(core::OutStateChanged{cur, State::IN_CALL});
                     out.push_back(core::OutSendMediaOffer{e->peer});
                }
                return out;
            },
            State::IN_CALL
        },

        // 6. CALLINGçŠ¶æ€ä¸‹æ”¶åˆ°é€šè¯è¢«æ‹’ç»
        { State::CALLING, EventType::CallRejected,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                out.push_back(core::OutStateChanged{cur, State::LoggedIn});
                return out;
            },
            State::LoggedIn
        },

        // 7. IN_CALLçŠ¶æ€ä¸‹æ”¶åˆ°åª’ä½“ä¿¡æ¯
        { State::IN_CALL, EventType::MediaPeer,
            [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                std::vector<core::CoreOutput> out;
                if (auto e = std::get_if<core::InMediaPeer>(&ev)) {
                    //std::string peerIp = !e->vpnIp.empty() ? e->vpnIp : e->lanIp;
                    std::string peerIp = e->lanIp;
                    out.push_back(core::OutStateChanged{cur, State::MEDIA_READY});
                    out.push_back(core::OutMediaReady{e->lanIp, e->vpnIp, e->udpPort});

                }
                return out;
            },
            State::MEDIA_READY
        },


    };
}

========== ./core/ClientCore.h ==========
Lines: 69

#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "FSM.h"
#include "ClientState.h"
#include "CoreExecutor.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <memory>
#include "ICoreListener.h"
#include <vector>

class ClientCore {
public:
    ClientCore();
    ~ClientCore();

    // çº¿ç¨‹å®‰å…¨æ¥å£ï¼ˆå¯¹å¤–æš´éœ²ï¼‰
    void postInput(core::CoreInput ev);
    // bool pollOutput(core::CoreOutput& out); // è¡¥å…… core:: å‰ç¼€
    void stop();
    // ç›‘å¬è€…ç®¡ç†ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
    void addListener(core::ICoreListener* listener);   // æ–°å¢
    void removeListener(core::ICoreListener* listener);// æ–°å¢

private:
    FSM fsm_;
    State state_ = State::Disconnected;
    std::unique_ptr<CoreExecutor> executor_;

    // çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
    std::queue<core::CoreInput>  inputQueue_;
    std::queue<core::CoreOutput> outputQueue_; // è¡¥å…… core:: å‰ç¼€
    std::mutex mtx_;
    std::condition_variable cv_;

    // ç›‘å¬è€…ç®¡ç†ï¼ˆæ–°å¢ï¼‰
    std::vector<core::ICoreListener*> listeners_;
    std::mutex listener_mtx_;  // ç›‘å¬è€…æ“ä½œçš„çº¿ç¨‹å®‰å…¨é”

    std::string peer_;          // é€šè¯å¯¹æ–¹ç”¨æˆ·å
    std::string peerIp_;        // å¯¹æ–¹åª’ä½“IP
    int peerPort_ = 0;          // å¯¹æ–¹åª’ä½“ç«¯å£
    bool isCaller_ = false;     // æ˜¯å¦ä¸ºä¸»åŠ¨å‘¼å«æ–¹
    // æ ¸å¿ƒæ–¹æ³•ï¼ˆå‚æ•°è¡¥å…… core:: å‰ç¼€ï¼‰
    void processEvents();
    void applyStateChange(const core::OutStateChanged& e); // è¡¥å…… core:: å‰ç¼€
    void handleOutput(core::CoreOutput&& o); // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutConnect& e) ; // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutSendLogin& e) ; // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutSendPing& e);
    void execute(const core::OutUpdateAlive&);
    void execute(const core::OutSelectLan&);
    void execute(const core::OutSelectVpn&) ;
    void execute(const core::OutLoginOk&);
    void execute(const core::OutSendText& e);
    void execute(const core::OutForwardText&);
    void execute(const core::OutSendCall& e);
    void execute(const core::OutSendAcceptCall& e);
    void execute(const core::OutSendRejectCall& e);
    void execute(const core::OutSendMediaOffer& e);
    void execute(const core::OutSendMediaAnswer& e);
    void execute(const core::OutShowIncomingCall& e);
    void execute(const core::OutMediaReady& e);
    void broadcastOutput(const core::CoreOutput& out);
    std::atomic<bool> is_running_{true};
};

========== ./core/CoreExecutor.cpp ==========
Lines: 198

//CoreExecutor.cpp
#include "CoreExecutor.h"
#include "ClientEventFactory.h"
#include <thread>
#include <iostream>
#include "./util/GetLocalIP.h"

CoreExecutor::CoreExecutor(InputCallback cb)
    : postInput_(std::move(cb)) {
    initSocketCallbacks();
    heartbeatThread_ = std::thread(&CoreExecutor::heartbeatLoop, this);
}

CoreExecutor::~CoreExecutor() {
    stop();
}

void CoreExecutor::initSocketCallbacks() {
    // 1. è¿æ¥æˆåŠŸå›è°ƒï¼šæ¨é€ InTcpConnected åˆ° Core
    socket_.setConnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpConnected{}); // æ›¿æ¢ä¸º InTcpConnected
            std::cout << "[Executor] Socket connected, push InTcpConnected to Core" << std::endl;
        }
    });

    // 2. æ–­å¼€è¿æ¥å›è°ƒï¼šæ¨é€ InTcpDisconnected åˆ° Core
    socket_.setDisconnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Socket disconnected, push InTcpDisconnected to Core" << std::endl;
        }
    });

    // 3. æ¶ˆæ¯æ¥æ”¶å›è°ƒï¼šè§£ææ¶ˆæ¯å¹¶æ¨é€å¯¹åº” CoreInput åˆ° Core
    socket_.setMessageCallback([this](const std::string& msg) {
        if (!isRunning_) return;

        ClientEvent event = ClientEventFactory::makeEvent(msg);
        std::visit([this](auto&& e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, ProtoEvtLoginOk>) {
                postInput_(core::InLoginOk{});
            } else if constexpr (std::is_same_v<T, ProtoEvtLoginFail>) {
                postInput_(core::InLoginFail{e.resp.message});
            } else if constexpr (std::is_same_v<T, ProtoEvtOnlineUsers>) {
                core::InOnlineUsers in;

                for (const auto& u : (e.users.users)) {
                    in.users.push_back(core::OnlineUser{
                        .name = u.username,
                        .privilege = u.privilege
                    });
                }

                postInput_(std::move(in));
            }
            else if constexpr (std::is_same_v<T, ProtoEvHeartbeatAck>) {
                postInput_(core::InHeartbeatOk{});
            }
            else if constexpr (std::is_same_v<T, ProtoEvtForwardText>) {
                postInput_(core::InForwardText{e.from_user, e.content});
            }

            else if constexpr (std::is_same_v<T, ProtoEvtCallIncoming>)
                postInput_(core::InCallIncoming{e.from});
            else if constexpr (std::is_same_v<T, ProtoEvtCallAccepted>)
                postInput_(core::InCallAccepted{e.peer});
            else if constexpr (std::is_same_v<T, ProtoEvtCallRejected>)
                postInput_(core::InCallRejected{e.peer});
            else if constexpr (std::is_same_v<T, ProtoEvtMediaPeer>)
                postInput_(core::InMediaPeer{e.peer, e.lanIp, e.vpnIp, e.udpPort});
            else {
                postInput_(core::InUnknow{});
            }

        }, event);
    });
}

void CoreExecutor::connectToServer(const std::string& host, int port) {
    // å¼‚æ­¥æ‰§è¡Œè¿æ¥
    std::thread([this, host, port]() {
        if (!socket_.connectToServer(host, port)) {
            // è¿æ¥å¤±è´¥ï¼šæ¨é€ InTcpDisconnected
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Connect to " << host << ":" << port << " failed" << std::endl;
        }
        else {
            std::cout << "[Executor] Successfully connected to server: " << host << ":" << port << std::endl;
        }
    }).detach();
}

void CoreExecutor::sendLoginRequest(const std::string& user, const std::string& pass) {
    std::string loginMsg = proto::makeLoginRequest(user, pass);
    socket_.sendMessage(loginMsg);
    std::cout << "[Executor] Send login request for user: " << user << std::endl;
}

void CoreExecutor::heartbeatLoop() {
    while (isRunning_) {
        std::this_thread::sleep_for(std::chrono::seconds(5));

        if (!isRunning_) break;

        // æ¨é€ HeartbeatTick ç»™ Core
        postInput_(core::InHeartbeatTick{});
        std::cout << "[Executor] push InHeartbeatTick" << std::endl;
    }
}


void CoreExecutor::sendPing() {
    std::string ping = proto::makeHeartbeat();
    socket_.sendMessage(ping);
    std::cout << "[Executor] Send PING" << std::endl;
}


void CoreExecutor::stop() {
    isRunning_ = false;
    socket_.stop();
}

void CoreExecutor::setLanMode() {
    mode_ = NetMode::LAN;
    std::cout << "[Executor] Switched to LAN mode\n";
}

void CoreExecutor::setVpnMode() {
    mode_ = NetMode::VPN;
    std::cout << "[Executor] Switched to VPN mode\n";
}

std::string CoreExecutor::selectPeerIp(
    const std::string& lanIp,
    const std::string& vpnIp) const
{
    if (mode_ == NetMode::VPN && !vpnIp.empty())
        return vpnIp;

    return lanIp;
}

void CoreExecutor::sendLocalIP() {
    // std::string ping = proto::makeHeartbeat();
    // socket_.sendMessage(ping);
    std::string lanIp = getLocalLanIP();   // ä½ éœ€è¦å®ç°
    std::string vpnIp = getVpnIp();        // å…ˆè¿”å› ""

    int port = 5001;

    std::string msg = proto::makeRegisterPeerMsg(lanIp, vpnIp, port);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send Local IP" << std::endl;
}

void CoreExecutor::sendTextMsg(const std::string& target_user, const std::string& content) {
    std::string textMsg = proto::makeSendTextMsg(target_user, content);
    socket_.sendMessage(textMsg);
    std::cout << "[Executor] Send text msg to " << target_user << ": " << content << std::endl;
}

// å‘é€CALLè¯·æ±‚
void CoreExecutor::sendCallRequest(const std::string& target_user) {
    std::string msg = proto::makeCallRequest(target_user);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL request to: " << target_user << std::endl;
}

// å‘é€CALL_ACCEPT
void CoreExecutor::sendAcceptCall() {
    std::string msg = proto::makeAcceptCallRequest();
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL_ACCEPT" << std::endl;
}

// å‘é€CALL_REJECT
void CoreExecutor::sendRejectCall() {
    std::string msg = proto::makeRejectCallRequest();
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send CALL_REJECT" << std::endl;
}

// å‘é€MEDIA_OFFER
void CoreExecutor::sendMediaOffer(const std::string& peer) {
    std::string msg = proto::makeMediaOfferRequest(peer);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send MEDIA_OFFER to: " << peer << std::endl;
}

// å‘é€MEDIA_ANSWER
void CoreExecutor::sendMediaAnswer(const std::string& peer) {
    std::string msg = proto::makeMediaAnswerRequest(peer);
    socket_.sendMessage(msg);
    std::cout << "[Executor] Send MEDIA_ANSWER to: " << peer << std::endl;
}

========== ./core/ClientState.h ==========
Lines: 32

// ClientState.h
#pragma once

#include <string>

enum class State {
    Disconnected,
    Connecting,
    Connected,
    LoggingIn,
    LoggedIn,
    CALLING,    // å‘èµ·å‘¼å«ä¸­
    RINGING,    // æ”¶åˆ°æ¥ç”µå“é“ƒä¸­
    IN_CALL,    // ä¿¡ä»¤æ¥é€š
    MEDIA_READY // åª’ä½“ä¿¡æ¯å°±ç»ª
};

// å°† State è½¬æ¢ä¸ºå­—ç¬¦ä¸²
inline std::string stateToString(State s) {
    switch (s) {
    case State::Disconnected: return "Disconnected";
    case State::Connecting:   return "Connecting";
    case State::Connected:    return "Connected";
    case State::LoggingIn:    return "LoggingIn";
    case State::LoggedIn:     return "LoggedIn";
    case State::CALLING:    return "CALLING";
    case State::RINGING:    return "RINGING";
    case State::IN_CALL:    return "IN_CALL";
    case State::MEDIA_READY:return "MEDIA_READY";
    default:                  return "Unknown";
    }
}

========== ./core/CoreExecutor.h ==========
Lines: 53

//CoreExecutor.h
#pragma once
#include "CoreInput.h"
#include "CommandSocket.h"
#include "protocol_text.h"
#include "ClientEventFactory.h"
#include <functional>
#include <memory>

// å®šä¹‰å›è°ƒç±»å‹ï¼šExecutor æ‰§è¡Œ IO åï¼Œé€šè¿‡è¯¥å›è°ƒå‘ ClientCore æ¨é€ CoreInput
using InputCallback = std::function<void(core::CoreInput)>;
enum class NetMode { LAN, VPN };

class CoreExecutor {
public:
    // æ„é€ å‡½æ•°ï¼šæ¥æ”¶å›è°ƒå‡½æ•°ï¼ˆç”¨äºå‘ Core æ¨é€è¾“å…¥äº‹ä»¶ï¼‰
    explicit CoreExecutor(InputCallback cb);
    ~CoreExecutor();

    // å¯¹å¤–æš´éœ²çš„ IO æ“ä½œæ¥å£ï¼ˆè¯­ä¹‰åŒ–å‘½åï¼‰
    void connectToServer(const std::string& host, int port);
    void sendLoginRequest(const std::string& user, const std::string& pass);
    void sendPing();
    void stop(); // èµ„æºé‡Šæ”¾æ¥å£
    void setLanMode() ;
    void setVpnMode() ;
    std::string selectPeerIp(const std::string& lanIp,
                             const std::string& vpnIp) const;
    void sendLocalIP();
    void sendTextMsg(const std::string& target_user, const std::string& content);
    void sendCallRequest(const std::string& target_user);
    void sendAcceptCall();
    void sendRejectCall();
    void sendMediaOffer(const std::string& peer);
    void sendMediaAnswer(const std::string& peer);
private:
    // å°è£…çš„ socket å®ä¾‹ï¼ˆExecutor å”¯ä¸€æŒæœ‰ï¼‰
    CommandSocket socket_;
    // å‘ Core æ¨é€äº‹ä»¶çš„å›è°ƒ
    InputCallback postInput_;
    // çº¿ç¨‹å®‰å…¨æ ‡è®°
    std::atomic<bool> isRunning_{true};

    // åˆå§‹åŒ– socket å›è°ƒï¼ˆå†…éƒ¨ç§æœ‰ï¼‰
    void initSocketCallbacks();

    std::thread heartbeatThread_;
    void heartbeatLoop();   // æ–°å¢


    std::atomic<NetMode> mode_{NetMode::LAN};

};

========== ./core/ICoreListener.h ==========
Lines: 15

// core/ICoreListener.h
#pragma once
#include "CoreOutput.h"

namespace core {

class ICoreListener {
public:
    virtual ~ICoreListener() = default;

    // Core è¾“å‡ºäº‹ä»¶çš„ç»Ÿä¸€å›è°ƒï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼‰
    virtual void onCoreOutput(const CoreOutput& out) = 0;
};

} // namespace core

========== ./core/CoreOutput.h ==========
Lines: 72

// core/CoreOutput.h
#pragma once
#include <variant>
#include "ClientState.h"
#include "vector"
#include "CoreInput.h"
// è¾“å‡ºå±‚äº‹ä»¶å…¨éƒ¨çº³å…¥ core å‘½åç©ºé—´
namespace core {

struct OutStateChanged {
    State from;
    State to;
};
struct OutLoginOk {};
struct OutLoginFail { std::string msg; };
struct OutDisconnected {};
struct OutConnect { std::string host; int port; };
struct OutSendLogin { std::string user; std::string pass; };
struct OutSendPing {};   // Core -> Executorï¼šå‘é€å¿ƒè·³
struct OutUpdateAlive {};
struct OutOnlineUsers { std::vector<OnlineUser> list; };
struct OutSelectLan {};
struct OutSelectVpn {};
struct OutSendText { std::string target_user; std::string content; };
struct OutForwardText { std::string from_user; std::string content; };
// å‘é€å‘¼å«è¯·æ±‚
struct OutSendCall { std::string target_user; };
// å‘é€æ¥å¬/æ‹’ç»è¯·æ±‚
struct OutSendAcceptCall {};
struct OutSendRejectCall {};
// å‘é€åª’ä½“Offer/Answer
struct OutSendMediaOffer { std::string peer; };
struct OutSendMediaAnswer { std::string peer; };
// åª’ä½“ä¿¡æ¯å°±ç»ª
struct OutMediaReady {
    std::string lanIp;
    std::string vpnIp;
    int peerPort;
};
struct OutMediaReadyFinal {
    std::string peerIp;
    int peerPort;
};

// æ¥ç”µé€šçŸ¥UI
struct OutShowIncomingCall { std::string from; };

using CoreOutput = std::variant<
    OutStateChanged,
    OutLoginOk,
    OutLoginFail,
    OutDisconnected,
    OutConnect,
    OutSendLogin,
    OutSendPing,
    OutUpdateAlive,
    OutOnlineUsers,
    OutSelectLan,
    OutSelectVpn,
    OutSendText,
    OutForwardText,
    OutSendCall,
    OutSendAcceptCall,
    OutSendRejectCall,
    OutSendMediaOffer,
    OutSendMediaAnswer,
    OutMediaReady,
    OutShowIncomingCall,
    OutMediaReadyFinal
    >;

} // namespace core

========== ./net/PacketCodec.h ==========
Lines: 39

//PacketCodec.h
#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 48

//CommandSocket.h
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <vector>
#include "PacketCodec.h"

class CommandSocket {
public:
    using MessageCallback = std::function<void(const std::string&)>;
    using ConnectCallback = std::function<void()>;
    using DisconnectCallback = std::function<void()>;

    CommandSocket();
    ~CommandSocket();

    void setConnectCallback(ConnectCallback cb);
    void setDisconnectCallback(DisconnectCallback cb);
    // TCP å®¢æˆ·ç«¯
    bool connectToServer(const std::string& host, int port);

    // TCP æœåŠ¡å™¨
    bool startServer(int port);

    void setMessageCallback(MessageCallback cb);

    // å‘é€æ•°æ®
    void sendMessage(const std::string& msg);

    // åœæ­¢
    void stop();

private:
    void clientThreadFunc();
    void serverThreadFunc();
    void sendPacket(int fd, const std::string& payload);
    int sockfd_ = -1;
    int clientfd_ = -1;  // å¯¹äºæœåŠ¡å™¨ç«¯ä¿å­˜å®¢æˆ·ç«¯è¿æ¥
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    MessageCallback callback_;

    ConnectCallback onConnect_;
    DisconnectCallback onDisconnect_;

};

========== ./net/CommandSocket.cpp ==========
Lines: 141

//CommandSocket.cpp
#include "CommandSocket.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

CommandSocket::CommandSocket() {}

CommandSocket::~CommandSocket() {
    stop();
}

void CommandSocket::setMessageCallback(MessageCallback cb) {
    callback_ = std::move(cb);
}

void CommandSocket::setConnectCallback(ConnectCallback cb) {
    onConnect_ = std::move(cb);
}

void CommandSocket::setDisconnectCallback(DisconnectCallback cb) {
    onDisconnect_ = std::move(cb);
}


void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


bool CommandSocket::connectToServer(const std::string& host, int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &serv_addr.sin_addr);

    if (connect(sockfd_, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sockfd_);
        sockfd_ = -1;
        return false;
    }

    if (onConnect_) onConnect_();   // â­ TCPçœŸæ­£å»ºç«‹
    // std::thread([this]{
    //     if (onConnect_) onConnect_();
    // }).detach();

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::clientThreadFunc, this);
    return true;
}

bool CommandSocket::startServer(int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(sockfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(sockfd_, 1) < 0) return false;

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::serverThreadFunc, this);
    return true;
}

void CommandSocket::sendMessage(const std::string& msg) {
    int fd = (clientfd_ >= 0) ? clientfd_ : sockfd_;
    sendPacket(fd,msg);
}

void CommandSocket::stop() {
    running_ = false;
    if (workerThread_.joinable())
        workerThread_.join();
    if (sockfd_ >= 0) close(sockfd_);
    if (clientfd_ >= 0) close(clientfd_);
    sockfd_ = -1;
    clientfd_ = -1;
}

void CommandSocket::clientThreadFunc() {
    std::vector<char> recvBuffer;
    char temp[1024];

    while (running_) {
        int n = recv(sockfd_, temp, sizeof(temp), 0);
        if (n > 0) {

            // 1ï¸âƒ£ æŠŠæ”¶åˆ°çš„å­—èŠ‚å¡è¿›ç¼“å­˜
            std::cout << "[CommandSocket] Received data, length: " << n << " bytes" << std::endl;
            recvBuffer.insert(recvBuffer.end(), temp, temp + n);

            // 2ï¸âƒ£ å°è¯•ä»ç¼“å­˜ä¸­æ‹†å®Œæ•´åŒ…
            std::string payload;
            while (PacketCodec::tryDecode(recvBuffer, payload)) {

                // 3ï¸âƒ£ æ¯ä¸€ä¸ª payload = ä¸€æ¡å®Œæ•´â€œåº”ç”¨å±‚æ¶ˆæ¯â€
                if (callback_) {
                    callback_(payload);
                }
            }

        } else if (n <= 0) {
            std::cout << "[CommandSocket] Server disconnected (recv return <=0)" << std::endl;
            if (onDisconnect_) onDisconnect_();  // â­ TCPæ–­çº¿
            break; // æœåŠ¡å™¨æ­£å¸¸æ–­å¼€
        }
    }
}

void CommandSocket::serverThreadFunc() {
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    clientfd_ = accept(sockfd_, (sockaddr*)&client_addr, &client_len);
    if (clientfd_ < 0) return;

    char buffer[1024];
    while (running_) {
        int n = recv(clientfd_, buffer, sizeof(buffer) - 1, 0);
        if (n > 0) {
            buffer[n] = '\0';
            if (callback_) callback_(std::string(buffer));
        } else if (n == 0) {
            break; // å®¢æˆ·ç«¯æ–­å¼€
        }
    }
}

========== ./ui/VideoWidget.cpp ==========
Lines: 35

//VideoWidget.cpp
#include "VideoWidget.h"
#include <QPainter>
#include <QDebug>
VideoWidget::VideoWidget(QWidget *parent)
    : QWidget(parent) {
    setMinimumSize(640, 480);
}

void VideoWidget::setFrame(const QImage &img) {
    frame_ = img;
    update();
}

void VideoWidget::paintEvent(QPaintEvent *) {
    QPainter p(this);
    p.fillRect(rect(), Qt::black);

    if (frame_.isNull())
        return;

    QSize imgSize = frame_.size();
    imgSize.scale(size(), Qt::KeepAspectRatio);

    QRect targetRect(
        (width()  - imgSize.width())  / 2,
        (height() - imgSize.height()) / 2,
        imgSize.width(),
        imgSize.height()
        );
    //qDebug() << "widget size:" << size();

    p.drawImage(targetRect, frame_);
}


========== ./ui/widget.cpp ==========
Lines: 262

// ui/widget.cppï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#include "widget.h"
#include "./ui_widget.h"
#include <QDebug>
#include "ClientCore.h" // åŒ…å«Coreå¤´æ–‡ä»¶
#include "ClientState.h" // åŒ…å«çŠ¶æ€è½¬æ¢å‡½æ•°
#include <QMessageBox>
Widget::Widget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
    , core_(core)  // åˆå§‹åŒ–CoreæŒ‡é’ˆ
{
    ui->setupUi(this);
    video_ = new VideoWidget(ui->videoContainer);
    adapter_ = new QtCameraAdapter(video_, this);

    // å…³é”®ä¿®å¤ï¼šç»‘å®šæ‘„åƒå¤´å›è°ƒåˆ°Qtç•Œé¢
    camera_.setFrameCallback([this](const Frame& f) {
        // è·¨çº¿ç¨‹å®‰å…¨è°ƒç”¨ï¼ˆCameraManageråœ¨å­çº¿ç¨‹ï¼ŒUIåœ¨ä¸»çº¿ç¨‹ï¼‰
        QMetaObject::invokeMethod(adapter_, "onFrame", Qt::QueuedConnection, Q_ARG(Frame, f));
    });

    // è¿œç«¯è§†é¢‘åˆå§‹åŒ–ï¼ˆå’Œæœ¬åœ°å®Œå…¨å¯¹ç§°ï¼‰
    remote_video_ = new VideoWidget(ui->remoteVideoContainer); // éœ€åœ¨UIè®¾è®¡å¸ˆä¸­æ·»åŠ remoteVideoContaineræ§ä»¶
    remote_adapter_ = new QtCameraAdapter(remote_video_, this);
    receiver_.setFrameCallback([this](const Frame& f) {
        // è·¨çº¿ç¨‹è°ƒç”¨ï¼ˆæ¥æ”¶ç«¯åœ¨GStreamerçº¿ç¨‹ï¼ŒUIåœ¨ä¸»çº¿ç¨‹ï¼‰
        QMetaObject::invokeMethod(remote_adapter_, "onFrame", Qt::QueuedConnection, Q_ARG(Frame, f));
    });

    if (core_) {
        core_->addListener(this);
    }

    // å…³é”®ä¿®å¤ï¼šç»‘å®šCoreäº‹ä»¶çš„è·¨çº¿ç¨‹å¤„ç†
    connect(this, &Widget::coreOutputReceived,
            this, &Widget::handleCoreOutput,
            Qt::QueuedConnection);
}

Widget::~Widget()
{
    // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„ç§»é™¤ç›‘å¬è€…æ–¹æ³•
    if (core_) {
        core_->removeListener(this);
    }
    // åœæ­¢æ¥æ”¶ç«¯
    receiver_.stop();
    // åœæ­¢å‘é€ç«¯ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
    camera_.stop();
    delete ui;
}

// å®ç°ICoreListeneræ¥å£ï¼šæ¥æ”¶Coreè¾“å‡ºäº‹ä»¶
void Widget::onCoreOutput(const core::CoreOutput& out)
{
    qDebug() << "Main UI received core output, type index:" << out.index();
    // è½¬å‘ä¸ºQtä¿¡å·ï¼ˆç¡®ä¿UIçº¿ç¨‹å¤„ç†ï¼‰
    emit coreOutputReceived(out);
}

void Widget::handleCoreOutput(const core::CoreOutput& out)
{
    std::visit([this](auto&& e) {
        handle(e);   // ğŸ”¥ å’Œ LoginWidget ä¸€æ¨¡ä¸€æ ·çš„åˆ†å‘é£æ ¼
    }, out);
}

void Widget::handle(const core::OutOnlineUsers& e) {
    std::cout << "[UI] OutOnlineUsers" << std::endl;
    QString text;

    for (const auto& u : e.list) {
        text += QString("%1 (priv=%2)\n")
                    .arg(QString::fromStdString(u.name))
                    .arg(u.privilege);
    }

    ui->text_onlineUsers->setPlainText(text);
}
// // å®ç°æ§½å‡½æ•°ï¼šå¤„ç†Coreè¾“å‡ºäº‹ä»¶ï¼ˆUIçº¿ç¨‹ï¼‰
// void Widget::handleCoreOutput(const core::CoreOutput& out)
// {
//     // å¯æ ¹æ®éœ€è¦æ‰©å±•å¤„ç†é€»è¾‘ï¼Œç›®å‰æ‰“å°æ—¥å¿—
//     std::visit([](auto&& e) {
//         using T = std::decay_t<decltype(e)>;
//         if constexpr (std::is_same_v<T, core::OutStateChanged>) {
//             qDebug() << "Main UI state change:" << QString::fromStdString(stateToString(e.from))
//                      << "â†’" << QString::fromStdString(stateToString(e.to));
//         }
//     }, out);
// }

void Widget::on_Bt_video_on_off_clicked()
{
    qDebug("Button clicked!");
    //camera_.start("/dev/video0");
}

void Widget::on_Bt_video_off_clicked()
{
    qDebug("Button clicked!");
    camera_.stop();
}

void Widget::on_Bt_tcp_send_clicked() {
    // è·å–ç›®æ ‡ç”¨æˆ·åå’Œæ¶ˆæ¯å†…å®¹
    QString target_user = ui->lineEdit_target_user->text();
    QString content = ui->lineEdit_msg->text();
    if (target_user.isEmpty() || content.isEmpty()) {
        std::cout << "can not be empty" << std::endl;
        return;
    }
    // å‘é€åˆ°Coreå±‚
    core_->postInput(core::InCmdSendText{
        target_user.toStdString(),
        content.toStdString()
    });
    // æ¸…ç©ºè¾“å…¥æ¡†
    ui->lineEdit_msg->clear();
}

// æ–°å¢ï¼šå¤„ç†å‘é€æ–‡æœ¬æ¶ˆæ¯ï¼ˆä»…æ—¥å¿—ï¼‰
void Widget::handle(const core::OutSendText& e) {
    std::cout << "[Widget] Send text to  " << e.target_user << ": " << e.content << std::endl;
}

// æ–°å¢ï¼šå¤„ç†æ¥æ”¶è½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ˜¾ç¤ºåˆ°UIï¼‰
void Widget::handle(const core::OutForwardText& e) {
    std::cout << "[Widget] recev from " << e.from_user << " msg: " << e.content << std::endl;
    // è¿½åŠ åˆ°æ–‡æœ¬æ¡†
    QString text = ui->PTE_recv->toPlainText();
    text += QString("[%1]: %2\n").arg(QString::fromStdString(e.from_user)).arg(QString::fromStdString(e.content));
    ui->PTE_recv->setPlainText(text);
}

void Widget::handle(const core::OutStateChanged& e) {
    std::cout << "[Widget] FSM:"
             << (stateToString(e.from))
             << "â†’"
             << (stateToString(e.to)) << std::endl;


}

void Widget::handle(const core::OutDisconnected&) {
    std::cout << "[Widget] OutDisconnected" << std::endl;
}

void Widget::handle(const core::OutConnect&) {
    std::cout << "[Widget] Ignore OutConnect (CoreExecutor handles it)" << std::endl;
}

void Widget::handle(const core::OutSendLogin&) {
    std::cout << "[Widget] Ignore OutSendLogin" << std::endl;
}

void Widget::handle(const core::OutSendPing&) {
    std::cout << "[Widget] Ignore OutSendPing" << std::endl;
}

void Widget::handle(const core::OutUpdateAlive&) {
    std::cout << "[Widget] OutUpdateAlive" << std::endl;
}

void Widget::handle(const core::OutLoginOk&) {
    std::cout << "[Widget] OutLoginOk (optional handling)" << std::endl;
}

void Widget::handle(const core::OutLoginFail&) {
    std::cout << "[Widget] OutLoginFail (optional handling)" << std::endl;
}

void Widget::handle(const core::OutSelectLan&) {
    std::cout << "[Widget] OutSelectLan" << std::endl;
}

void Widget::handle(const core::OutSelectVpn&) {
    std::cout << "[Widget] OutSelectVpn)" << std::endl;
}


//**********************
void Widget::handle(const core::OutSendCall&) {
    std::cout << "[Widget] OutSendCall)" << std::endl;
}

void Widget::handle(const core::OutSendAcceptCall&) {
    std::cout << "[Widget] OutSendAcceptCall)" << std::endl;
}

void Widget::handle(const core::OutSendRejectCall&) {
    std::cout << "[Widget] OutSendRejectCall)" << std::endl;
}

void Widget::handle(const core::OutSendMediaOffer&) {
    std::cout << "[Widget] OutSendMediaOffer)" << std::endl;
}

void Widget::handle(const core::OutSendMediaAnswer&) {
    std::cout << "[Widget] OutSendMediaAnswer)" << std::endl;
}

void Widget::handle(const core::OutMediaReady& e) {
    std::cout << "[Widget] OutMediaReady)" << std::endl;
}

void Widget::handle(const core::OutMediaReadyFinal& e) {
    std::cout << "[Widget] OutMediaReadyFinal)" << std::endl;
    std::cout << "[UI] Media ready, peer IP: " << e.peerIp << ", port: " << e.peerPort << std::endl;
    // æ ¸å¿ƒï¼šä½¿ç”¨CoreExecutoré€‰æ‹©åçš„æœ€ç»ˆIPå¯åŠ¨æ¨æµ
    camera_.start("/dev/video0", e.peerIp, e.peerPort);
    receiver_.start(5001);
}

void Widget::handle(const core::OutShowIncomingCall& e) {
    // å¼¹å‡ºæ¥ç”µå¯¹è¯æ¡†
    QMessageBox msgBox;
    msgBox.setWindowTitle("Incoming");
    msgBox.setText(QString("User %1 is calling you").arg(QString::fromStdString(e.from)));
    msgBox.addButton("Accept", QMessageBox::AcceptRole);
    msgBox.addButton("Reject", QMessageBox::RejectRole);
    int ret = msgBox.exec();
    if (ret == QMessageBox::AcceptRole) {
        core_->postInput(core::InCmdAcceptCall{});
    } else {
        core_->postInput(core::InCmdRejectCall{});
    }
}



void Widget::on_Bt_Call_clicked()
{
    QString targetUser = ui->lineEdit_CallTarget->text();
    core_->postInput(core::InCmdCall{targetUser.toStdString()});
}


void Widget::on_Bt_AcceptCall_clicked()
{
    core_->postInput(core::InCmdAcceptCall{});
}


void Widget::on_Bt_RejectCall_clicked()
{
    core_->postInput(core::InCmdRejectCall{});
}


void Widget::on_Bt_set_lan_clicked()
{
    core_->postInput(core::InSelectLan{}); // è§¦å‘LANæ¨¡å¼
}


void Widget::on_Bt_sen_vpn_clicked()
{
    core_->postInput(core::InSelectVpn{}); // è§¦å‘VPNæ¨¡å¼
}


========== ./ui/QtCameraAdapter.cpp ==========
Lines: 18

//QtCameraAdapter.cpp
#include "QtCameraAdapter.h"
#include <QImage>

QtCameraAdapter::QtCameraAdapter(VideoWidget* view, QObject* parent)
    : QObject(parent), view_(view) {}

void QtCameraAdapter::onFrame(Frame f) {
    QImage img(
        f.data.data(),
        f.width,
        f.height,
        f.stride,
        QImage::Format_RGB888
        );

    view_->setFrame(img.copy());
}

========== ./ui/LoginWidget.h ==========
Lines: 77

//LoginWidget.h
#ifndef LOGINWIDGET_H
#define LOGINWIDGET_H

#include <QWidget>

#include "core/ICoreListener.h"  // å®ç°æŠ½è±¡æ¥å£
#include "core/CoreOutput.h"     // Core è¾“å‡ºäº‹ä»¶

class ClientCore;

namespace Ui {
class LoginWidget;
}

class LoginWidget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit LoginWidget(ClientCore* core, QWidget* parent = nullptr);
    ~LoginWidget() override;

    void onCoreOutput(const core::CoreOutput& out) override;

signals:
    void loginSuccess();
    void coreOutputReceived(const core::CoreOutput& out);

private slots:
    void on_Bt_Jump_Test_clicked();
    void on_Bt_ConnectToServer_clicked();
    void on_Bt_tcp_test_send_clicked();
    void on_Bt_Login_clicked();
    void handleCoreOutput(const core::CoreOutput& out);

private:
    Ui::LoginWidget *ui;
    ClientCore* core_;
    // æ–°å¢ï¼šUI çº¿ç¨‹å¤„ç† Core äº‹ä»¶
    // æ‰€æœ‰å‚æ•°è¡¥å…… core:: å‰ç¼€
    void handle(const core::OutLoginFail&);
    void handle(const core::OutDisconnected&) ;
    void handle(const core::OutLoginOk&) ;
    void handle(const core::OutStateChanged& e) ;
    void handle(const core::OutConnect&);       // æ–°å¢
    void handle(const core::OutSendLogin&);     // æ–°å¢

    void handle(const core::OutSendPing&);

    void handle(const core::OutUpdateAlive&);
    void handle(const core::OutOnlineUsers&);
    void handle(const core::OutSelectLan&) ;

    void handle(const core::OutSelectVpn&) ;
    void handle(const core::OutSendText& e) ;

    void handle(const core::OutForwardText& e) ;

    void handle(const core::OutSendCall&);

    void handle(const core::OutSendAcceptCall&) ;

    void handle(const core::OutSendRejectCall&) ;

    void handle(const core::OutSendMediaOffer&) ;

    void handle(const core::OutSendMediaAnswer&) ;

    void handle(const core::OutMediaReady&) ;

    void handle(const core::OutShowIncomingCall&) ;

    void handle(const core::OutMediaReadyFinal& e);
};

#endif // LOGINWIDGET_H

========== ./ui/AppWindow.cpp ==========
Lines: 38

// ui/AppWindow.cpp
#include "AppWindow.h"
#include "LoginWidget.h"
#include "widget.h"
#include "core/ClientCore.h"  // åŒ…å« Core å¤´æ–‡ä»¶
#include <QVBoxLayout>

AppWindow::AppWindow(QWidget *parent)
    : QWidget(parent)
{
    resize(900, 600);
    stack = new QStackedWidget(this);

    // æ ¸å¿ƒï¼šåˆ›å»ºå”¯ä¸€çš„ ClientCore å®ä¾‹ï¼ˆçº¯ C++ï¼Œæ—  Qt ä¾èµ–ï¼‰
    core_ = std::make_unique<ClientCore>();

    // ä¼ é€’ Core æŒ‡é’ˆç»™å­çª—å£
    loginPage = new LoginWidget(core_.get(), this);
    mainPage  = new Widget(core_.get(), this);

    stack->addWidget(loginPage); // index 0
    stack->addWidget(mainPage);  // index 1

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(stack);
    setLayout(layout);

    // ç™»å½•æˆåŠŸ â†’ åˆ‡æ¢é¡µé¢
    connect(loginPage, &LoginWidget::loginSuccess, this, [=](){
        stack->setCurrentIndex(PAGE_MAIN);
    });

    // åˆå§‹é¡µé¢
    stack->setCurrentIndex(PAGE_LOGIN);
}

// ææ„ï¼šæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ Core
AppWindow::~AppWindow() = default;

========== ./ui/VideoWidget.h ==========
Lines: 17

//VideoWidget.h
#pragma once
#include <QWidget>
#include <QImage>

class VideoWidget : public QWidget {
    Q_OBJECT
public:
    explicit VideoWidget(QWidget *parent = nullptr);
    void setFrame(const QImage &img);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QImage frame_;
};

========== ./ui/QtCameraAdapter.h ==========
Lines: 17

//QtCameraAdapter.h
#pragma once
#include <QObject>
#include "Frame.h"
#include "VideoWidget.h"

class QtCameraAdapter : public QObject {
    Q_OBJECT
public:
    explicit QtCameraAdapter(VideoWidget* view, QObject* parent = nullptr);

public slots:
    void onFrame(Frame frame);

private:
    VideoWidget* view_;
};

========== ./ui/LoginWidget.cpp ==========
Lines: 179

//LoginWidget.cpp
#include "LoginWidget.h"
#include "./ui_LoginWidget.h"
#include <QMessageBox>
#include <QMetaObject>
#include <QDebug>
#include "ClientCore.h"



LoginWidget::LoginWidget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::LoginWidget)
    , core_(core)  // æ¥æ”¶ AppWindow ä¼ å…¥çš„ Core å®ä¾‹
{
    ui->setupUi(this);

    // æ³¨å†Œä¸º Core çš„ç›‘å¬è€…
    core_->addListener(this);

    // å…³é”®ï¼šè·¨çº¿ç¨‹ä¿¡å·æ§½ï¼ˆå¼ºåˆ¶ QueuedConnectionï¼Œç¡®ä¿ UI çº¿ç¨‹æ‰§è¡Œï¼‰
    connect(this, &LoginWidget::coreOutputReceived,
            this, &LoginWidget::handleCoreOutput,
            Qt::QueuedConnection);

    // ç§»é™¤ï¼šåˆ é™¤ QTimer è½®è¯¢é€»è¾‘
    // QTimer* timer = new QTimer(this);
    // connect(timer, &QTimer::timeout, this, [this]{ ... });
    // timer->start(10);
}

LoginWidget::~LoginWidget() {
    // ææ„æ—¶ç§»é™¤ç›‘å¬è€…ï¼ˆé¿å…é‡æŒ‡é’ˆï¼‰
    if (core_) {
        core_->removeListener(this);
    }
    delete ui;
}


// å®ç° ICoreListener æ¥å£ï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼Œç»ä¸æ“ä½œ UIï¼‰
void LoginWidget::onCoreOutput(const core::CoreOutput& out) {
    // ä»…è½¬å‘ä¸º Qt ä¿¡å·ï¼Œäº¤ç»™ UI çº¿ç¨‹å¤„ç†
    emit coreOutputReceived(out);
}

// UI çº¿ç¨‹å¤„ç† Core äº‹ä»¶ï¼ˆå®‰å…¨æ“ä½œ UIï¼‰
void LoginWidget::handleCoreOutput(const core::CoreOutput& out) {
    std::visit([this](auto&& e) {
        handle(e);
    }, out);
}

void LoginWidget::on_Bt_Jump_Test_clicked()
{
    emit loginSuccess();
}

void LoginWidget::on_Bt_ConnectToServer_clicked()
{
    //qDebug() << "current thread:" << QThread::currentThread();
    //qDebug() << "ui thread:" << qApp->thread();

    ui->TextEdit_tcp_test_recv->setPlainText("Connecting\n");
    // æ›¿æ¢ä¸º InCmdConnect
    core_->postInput(core::InCmdConnect{"192.168.6.64",6001});
}

void LoginWidget::on_Bt_tcp_test_send_clicked()
{
    QString qmsg = ui->LE_tcp_send_test->text();
    std::string msg = qmsg.toStdString();
}

// æ‰€æœ‰ handle å‡½æ•°å‚æ•°è¡¥å…… core:: å‰ç¼€
void LoginWidget::handle(const core::OutLoginFail&) {
    std::cout << "[UI] handle OutLoginFail: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login failed");
}

void LoginWidget::handle(const core::OutDisconnected&) {
    std::cout << "[UI] handle OutDisconnected: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutDisconnected");
}

void LoginWidget::handle(const core::OutLoginOk&) {
    std::cout << "[UI] handle OutLoginOk: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login success");
    emit loginSuccess();
}

void LoginWidget::handle(const core::OutStateChanged& e) {
    std::cout << "[UI] handle OutStateChanged: " << stateToString(e.from) << " to " << stateToString(e.to) << std::endl;
    ui->TextEdit_FSM_State->setPlainText(QString::fromStdString(stateToString(e.to)));
}

void LoginWidget::handle(const core::OutConnect&) {
    std::cout << "[UI] Ignore OutConnect (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutSendLogin&) {
    std::cout << "[UI] Ignore OutSendLogin (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutSendPing&) {
    std::cout << "[UI] Ignore OutSendPing (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutUpdateAlive&) {
    std::cout << "[UI] Ignore OutUpdateAlive" << std::endl;
}

void LoginWidget::handle(const core::OutOnlineUsers&) {
    std::cout << "[UI] OutOnlineUsers" << std::endl;
}

void LoginWidget::handle(const core::OutSelectLan&) {
    std::cout << "[UI] OutSelectLan" << std::endl;
}

void LoginWidget::handle(const core::OutSelectVpn&) {
    std::cout << "[UI] OutSelectVpn" << std::endl;
}

void LoginWidget::handle(const core::OutSendText& e) {
    std::cout << "[UI] OutSendText  "  << std::endl;
}

// æ–°å¢ï¼šå¤„ç†æ¥æ”¶è½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ˜¾ç¤ºåˆ°UIï¼‰
void LoginWidget::handle(const core::OutForwardText& e) {
    std::cout << "[UI] OutForwardText " << std::endl;

}

void LoginWidget::on_Bt_Login_clicked()
{
    QString qstr_user_name = ui->LE_UserName->text();
    std::string msg_user_name = qstr_user_name.toStdString();

    QString qstr_user_pass = ui->LE_UserPass->text();
    std::string msg_user_pass = qstr_user_pass.toStdString();

    // æ›¿æ¢ä¸º InCmdLogin
    core_->postInput(core::InCmdLogin{msg_user_name, msg_user_pass});
}


//**********************
void LoginWidget::handle(const core::OutSendCall&) {
    std::cout << "[LoginWidget] OutSendCall)" << std::endl;
}

void LoginWidget::handle(const core::OutSendAcceptCall&) {
    std::cout << "[LoginWidget] OutSendAcceptCall)" << std::endl;
}

void LoginWidget::handle(const core::OutSendRejectCall&) {
    std::cout << "[LoginWidget] OutSendRejectCall)" << std::endl;
}

void LoginWidget::handle(const core::OutSendMediaOffer&) {
    std::cout << "[LoginWidget] OutSendMediaOffer)" << std::endl;
}

void LoginWidget::handle(const core::OutSendMediaAnswer&) {
    std::cout << "[LoginWidget] OutSendMediaAnswer)" << std::endl;
}

void LoginWidget::handle(const core::OutMediaReady&) {
    std::cout << "[LoginWidget] OutMediaReady)" << std::endl;
}

void LoginWidget::handle(const core::OutMediaReadyFinal&) {
    std::cout << "[LoginWidget] OutMediaReadyFinal)" << std::endl;
}

void LoginWidget::handle(const core::OutShowIncomingCall&) {
    std::cout << "[LoginWidget] OutShowIncomingCall)" << std::endl;
}

========== ./ui/AppWindow.h ==========
Lines: 30

//AppWindow.h
#pragma once
#include <QWidget>
#include <QStackedWidget>
#include "memory"
#include "LoginWidget.h"
#include "widget.h"
#include "memory"

class ClientCore;

class AppWindow : public QWidget
{
    Q_OBJECT
public:
    explicit AppWindow(QWidget *parent = nullptr);
    ~AppWindow() override;
private:
    QStackedWidget *stack;
    LoginWidget *loginPage;
    Widget *mainPage;

    // æ ¸å¿ƒï¼šAppWindow å”¯ä¸€æŒæœ‰ ClientCore å®ä¾‹
    std::unique_ptr<ClientCore> core_;

    enum PageIndex {
        PAGE_LOGIN = 0,
        PAGE_MAIN
    };
};

========== ./ui/widget.h ==========
Lines: 102

// ui/widget.hï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "QtCameraAdapter.h"
#include "CameraManager.h"
#include "core/ICoreListener.h"
#include "core/CoreOutput.h"
#include "media/VideoReceiver.h"
// å‰ç½®å£°æ˜ï¼ˆå‡å°‘è€¦åˆï¼‰
class ClientCore;

QT_BEGIN_NAMESPACE
namespace Ui {
class Widget;
}
QT_END_NAMESPACE

class Widget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit Widget(ClientCore* core, QWidget *parent = nullptr);
    ~Widget() override;

    // ä»…å®ç°ICoreListenerè¦æ±‚çš„çº¯è™šå‡½æ•°
    void onCoreOutput(const core::CoreOutput& out) override;

signals:
    void coreOutputReceived(const core::CoreOutput& out);

private slots:
    void on_Bt_video_on_off_clicked();
    void on_Bt_video_off_clicked();
    void on_Bt_tcp_send_clicked();
    void handleCoreOutput(const core::CoreOutput& out); // æ§½å‡½æ•°å£°æ˜

    void on_Bt_Call_clicked();

    void on_Bt_AcceptCall_clicked();

    void on_Bt_RejectCall_clicked();

    void on_Bt_set_lan_clicked();

    void on_Bt_sen_vpn_clicked();

private:
    Ui::Widget *ui;
    ClientCore* core_; // æ–°å¢ï¼šCoreæŒ‡é’ˆæˆå‘˜
    VideoWidget *video_;
    CameraManager camera_;
    QtCameraAdapter* adapter_;
    VideoWidget *remote_video_;
    VideoReceiver receiver_;
    QtCameraAdapter* remote_adapter_;

    void handle(const core::OutDisconnected&);

    void handle(const core::OutConnect&);

    void handle(const core::OutSendLogin&);

    void handle(const core::OutSendPing&);

    void handle(const core::OutUpdateAlive&);

    void handle(const core::OutLoginOk&);

    void handle(const core::OutLoginFail&);

    void handle(const core::OutOnlineUsers&);

    void handle(const core::OutStateChanged&);

    void handle(const core::OutSelectLan&) ;

    void handle(const core::OutSelectVpn&) ;
    void handle(const core::OutSendText& e) ;

    void handle(const core::OutForwardText& e) ;

    void handle(const core::OutSendCall&);

    void handle(const core::OutSendAcceptCall&) ;

    void handle(const core::OutSendRejectCall&) ;

    void handle(const core::OutSendMediaOffer&) ;

    void handle(const core::OutSendMediaAnswer&) ;

    void handle(const core::OutMediaReady& e) ;

    void handle(const core::OutShowIncomingCall& e) ;

    void handle(const core::OutMediaReadyFinal& e);

};
#endif // WIDGET_H

========== ./protocol/protocol_types.h ==========
Lines: 63

//protocol_types.h
#pragma once
#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct Unknown {
    std::string message;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

// æ–‡æœ¬æ¶ˆæ¯ç»“æ„ä½“ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
struct SendTextMsg {
    std::string target_user;  // ç›®æ ‡ç”¨æˆ·å
    std::string content;      // æ¶ˆæ¯å†…å®¹
    std::string from_user;    // å‘é€è€…ç”¨æˆ·åï¼ˆæœåŠ¡å™¨å¡«å……ï¼‰
};

// è½¬å‘æ–‡æœ¬æ¶ˆæ¯ç»“æ„ä½“ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
struct ForwardTextMsg {
    std::string from_user;    // å‘é€è€…ç”¨æˆ·å
    std::string content;      // æ¶ˆæ¯å†…å®¹
};

// æ¥ç”µé€šçŸ¥ç»“æ„ä½“
struct CallIncoming {
    std::string from; // æ¥ç”µæ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ¥å¬ç»“æ„ä½“
struct CallAccepted {
    std::string peer; // é€šè¯å¯¹æ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ‹’ç»ç»“æ„ä½“
struct CallRejected {
    std::string peer; // æ‹’ç»æ–¹ç”¨æˆ·å
};

// åª’ä½“åå•†å“åº”ç»“æ„ä½“
struct MediaPeerResp {
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    std::string lanIp;   // å¯¹æ–¹å±€åŸŸç½‘IP
    std::string vpnIp;   // å¯¹æ–¹VPN IP
    int udpPort;         // å¯¹æ–¹åª’ä½“UDPç«¯å£
};

}

========== ./protocol/protocol_text.h ==========
Lines: 34

//protocol_text.h
#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);
std::string makeHeartbeat();
std::string makeRegisterPeerMsg(const std::string& lan,const std::string& vpn,int port);
std::string makeSendTextMsg(const std::string& target_user, const std::string& content);
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content);
std::string makeCallRequest(const std::string& target_user);
std::string makeAcceptCallRequest();
std::string makeRejectCallRequest();
std::string makeMediaOfferRequest(const std::string& peer);
std::string makeMediaAnswerRequest(const std::string& peer);

// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);
bool parseHeartbeatAck(const std::string& msg);
bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content);
bool parseForwardTextMsg(const std::string& msg, std::string& from_user, std::string& content);
bool parseCallIncoming(const std::string& msg, CallIncoming& out);
bool parseCallAccepted(const std::string& msg, CallAccepted& out);
bool parseCallRejected(const std::string& msg, CallRejected& out);
bool parseMediaPeerResp(const std::string& msg, MediaPeerResp& out);
}

========== ./protocol/protocol_text.cpp ==========
Lines: 269

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

std::string makeCallRequest(const std::string& target_user) {
    std::ostringstream oss;
    oss << CMD_CALL << " " << target_user;
    return oss.str();
}

std::string makeAcceptCallRequest() {
    return CMD_CALL_ACCEPT;
}

std::string makeRejectCallRequest() {
    return CMD_CALL_REJECT;
}

std::string makeMediaOfferRequest(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_MEDIA_OFFER << " " << peer;
    return oss.str();
}

std::string makeMediaAnswerRequest(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_MEDIA_ANSWER << " " << peer;
    return oss.str();
}

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    oss ;
    return oss.str();
}

std::string makeHeartbeat() {
    return CMD_HEARTBEAT;
}

std::string makeRegisterPeerMsg(
    const std::string& lan,
    const std::string& vpn,
    int port)
{
    std::ostringstream oss;
    oss << CMD_REGISTER_PEER << " "
        << lan << " "
        << vpn << " "
        << port;
    return oss.str();
}

// ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
std::string makeSendTextMsg(const std::string& target_user, const std::string& content) {
    std::ostringstream oss;
    // æ ¼å¼ï¼šSEND_TEXT ç›®æ ‡ç”¨æˆ·å æ¶ˆæ¯å†…å®¹ï¼ˆå†…å®¹å«ç©ºæ ¼éœ€ä¿ç•™ï¼Œç”¨å¼•å·æˆ–ç›´æ¥æ‹¼æ¥ï¼Œè¿™é‡Œç”¨ç©ºæ ¼åˆ†éš”åæ‹¼æ¥ï¼‰
    oss << CMD_SEND_TEXT << " " << target_user << " " << content;
    return oss.str();
}

// ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content) {
    std::ostringstream oss;
    oss << CMD_FORWARD_TEXT << " " << from_user << " " << content;
    return oss.str();
}


/* ================= parse ================= */

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}


bool parseHeartbeatAck(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_HEARTBEAT_ACK;   // "PONG"
}

// è§£æå‘é€æ–‡æœ¬æ¶ˆæ¯ï¼ˆæœåŠ¡å™¨ç”¨ï¼‰
bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_SEND_TEXT) return false;

    // è¯»å–ç›®æ ‡ç”¨æˆ·å
    iss >> target_user;
    // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯ï¼ˆå¤„ç†å«ç©ºæ ¼çš„æƒ…å†µï¼‰
    std::getline(iss >> std::ws, content);
    return !target_user.empty() && !content.empty();
}

// è§£æè½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆå®¢æˆ·ç«¯ç”¨ï¼‰
bool parseForwardTextMsg(const std::string& msg, std::string& from_user, std::string& content) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_FORWARD_TEXT) return false;

    // è¯»å–å‘é€è€…ç”¨æˆ·å
    iss >> from_user;
    // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯
    std::getline(iss >> std::ws, content);
    return !from_user.empty() && !content.empty();
}

// è§£ææ¥ç”µé€šçŸ¥ï¼ˆCMD_CALL_INCOMINGï¼‰
bool parseCallIncoming(const std::string& msg, CallIncoming& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_INCOMING) return false;
    iss >> out.from;
    return !out.from.empty();
}

// è§£æé€šè¯è¢«æ¥å¬ï¼ˆCMD_CALL_ACCEPTEDï¼‰
bool parseCallAccepted(const std::string& msg, CallAccepted& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_ACCEPTED) return false;
    iss >> out.peer;
    return !out.peer.empty();
}

// è§£æé€šè¯è¢«æ‹’ç»ï¼ˆCMD_CALL_REJECTEDï¼‰
bool parseCallRejected(const std::string& msg, CallRejected& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_CALL_REJECTED) return false;
    iss >> out.peer;
    return !out.peer.empty();
}

// è§£æåª’ä½“Offer/Answerå“åº”ï¼ˆCMD_MEDIA_OFFER_RESP/CMD_MEDIA_ANSWER_RESPï¼‰
bool parseMediaPeerResp(const std::string& msg, MediaPeerResp& out) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_MEDIA_OFFER_RESP && cmd != CMD_MEDIA_ANSWER_RESP) return false;
    iss >> out.peer >> out.lanIp >> out.vpnIp >> out.udpPort;

    // åŸºç¡€æ ¡éªŒï¼šç”¨æˆ·åå’Œç«¯å£ä¸èƒ½ä¸ºç©º/æ— æ•ˆ
    return !out.peer.empty() && out.udpPort > 0;
}



} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 36

//protocol_common.h
#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN         = "LOGIN";
constexpr const char* CMD_LOGIN_OK      = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL    = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS  = "ONLINE_USERS";
constexpr const char* CMD_HEARTBEAT     = "PING";
constexpr const char* CMD_HEARTBEAT_ACK = "PONG";
constexpr const char* CMD_REGISTER_PEER = "REGISTER_PEER";
constexpr const char* CMD_SEND_TEXT     = "SEND_TEXT";
constexpr const char* CMD_FORWARD_TEXT  = "FORWARD_TEXT";
// é€šè¯ç›¸å…³CMD
constexpr const char* CMD_CALL               = "CALL";
constexpr const char* CMD_CALL_INCOMING      = "CALL_INCOMING";
constexpr const char* CMD_CALL_ACCEPT        = "CALL_ACCEPT";
constexpr const char* CMD_CALL_REJECT        = "CALL_REJECT";
constexpr const char* CMD_CALL_ACCEPTED      = "CALL_ACCEPTED";
constexpr const char* CMD_CALL_REJECTED      = "CALL_REJECTED";
constexpr const char* CMD_MEDIA_OFFER        = "MEDIA_OFFER";
constexpr const char* CMD_MEDIA_OFFER_RESP   = "MEDIA_OFFER_RESP";
constexpr const char* CMD_MEDIA_ANSWER       = "MEDIA_ANSWER";
constexpr const char* CMD_MEDIA_ANSWER_RESP  = "MEDIA_ANSWER_RESP";

// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}

========== ./app/ClientEvent.h ==========
Lines: 76

//ClientEvent.h
#pragma once

#include <string>
#include "protocol_types.h"
#include <variant>

// åè®®å±‚äº‹ä»¶ç»Ÿä¸€å‰ç¼€ï¼šProtoEvt
struct ProtoEvtTcpConnected {};
struct ProtoEvtTcpDisconnected {};
struct ProtoEvtLoginOk    { proto::LoginResponse resp; };
struct ProtoEvtLoginFail { proto::LoginResponse resp; };
struct ProtoEvtOnlineUsers { proto::OnlineUsers users; };
struct ProtoEvtUnknow { proto::Unknown error_msg; };
struct ProtoEvtCmdConnect {
    std::string host;
    int port;
};
struct ProtoEvtCmdDisconnect {};
struct ProtoEvtCmdLogin {
    std::string user;
    std::string pass;
};
struct ProtoEvHeartbeatAck{};

// è½¬å‘æ–‡æœ¬æ¶ˆæ¯äº‹ä»¶ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
struct ProtoEvtForwardText {
    std::string from_user;  // å‘é€è€…ç”¨æˆ·å
    std::string content;    // æ¶ˆæ¯å†…å®¹
};

// æ¥ç”µäº‹ä»¶
struct ProtoEvtCallIncoming {
    std::string from; // æ¥ç”µæ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ¥å¬äº‹ä»¶
struct ProtoEvtCallAccepted {
    std::string peer; // é€šè¯å¯¹æ–¹ç”¨æˆ·å
};

// é€šè¯è¢«æ‹’ç»äº‹ä»¶
struct ProtoEvtCallRejected {
    std::string peer; // æ‹’ç»æ–¹ç”¨æˆ·å
};

// åª’ä½“åå•†å“åº”äº‹ä»¶
struct ProtoEvtMediaPeer {
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    std::string lanIp;   // å¯¹æ–¹å±€åŸŸç½‘IP
    std::string vpnIp;   // å¯¹æ–¹VPN IP
    int udpPort;         // å¯¹æ–¹åª’ä½“UDPç«¯å£
};

using ClientEvent = std::variant<
    // UI è§¦å‘çš„åè®®å‘½ä»¤
    ProtoEvtCmdConnect,
    ProtoEvtCmdDisconnect,
    ProtoEvtCmdLogin,

    // TCP åº•å±‚äº‹ä»¶
    ProtoEvtTcpConnected,
    ProtoEvtTcpDisconnected,

    // åè®®è§£æåçš„ä¸šåŠ¡äº‹ä»¶
    ProtoEvtLoginOk,
    ProtoEvtLoginFail,
    ProtoEvtOnlineUsers,
    ProtoEvtUnknow,
    ProtoEvHeartbeatAck,
    ProtoEvtForwardText,
    ProtoEvtCallIncoming,
    ProtoEvtCallAccepted,
    ProtoEvtCallRejected,
    ProtoEvtMediaPeer
    >;

========== ./app/ClientEventFactory.h ==========
Lines: 18

//ClientEventFactory.h
#ifndef CLIENTEVENTFACTORY_H
#define CLIENTEVENTFACTORY_H

#include "protocol_types.h"
#include "ClientEvent.h"
class ClientEventFactory
{
public:
    ClientEventFactory();
    static ClientEvent makeEvent(const std::string& msg);

private:


};

#endif // CLIENTEVENTFACTORY_H

========== ./app/ClientEventFactory.cpp ==========
Lines: 64

//ClientEventFactory.cpp
#include "ClientEventFactory.h"

// åªåœ¨ cpp ä¸­ include è§£æå‡½æ•°
#include "protocol_text.h"

ClientEventFactory::ClientEventFactory() {}

ClientEvent ClientEventFactory::makeEvent(const std::string& msg)
{
    proto::LoginResponse login;
    if (proto::parseLoginResponse(msg, login)) {
        if (login.success)
            return ProtoEvtLoginOk{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
        else
            return ProtoEvtLoginFail{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    proto::OnlineUsers users;
    if (proto::parseOnlineUsers(msg, users)) {
        return ProtoEvtOnlineUsers{users}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    if (proto::parseHeartbeatAck(msg)) {
        return ProtoEvHeartbeatAck{}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    // è§£æè½¬å‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆCMD_FORWARD_TEXTï¼‰
    std::string from_user, content;
    if (proto::parseForwardTextMsg(msg, from_user, content)) {
        return ProtoEvtForwardText{from_user, content};
    }

    // =====è°ƒç”¨é€šè¯ç›¸å…³è§£æå‡½æ•° =====
    proto::CallIncoming callIn;
    if (proto::parseCallIncoming(msg, callIn)) {
        return ProtoEvtCallIncoming{callIn.from};
    }

    proto::CallAccepted callAc;
    if (proto::parseCallAccepted(msg, callAc)) {
        return ProtoEvtCallAccepted{callAc.peer};
    }

    proto::CallRejected callRe;
    if (proto::parseCallRejected(msg, callRe)) {
        return ProtoEvtCallRejected{callRe.peer};
    }

    proto::MediaPeerResp mediaPeer;
    if (proto::parseMediaPeerResp(msg, mediaPeer)) {
        return ProtoEvtMediaPeer{
            mediaPeer.peer,
            mediaPeer.lanIp,
            mediaPeer.vpnIp,
            mediaPeer.udpPort
        };
    }


    proto::Unknown req_error;
    req_error.message = msg;
    return ProtoEvtUnknow{req_error}; // æ”¹ä¸º ProtoEvt å‰ç¼€
}

========== ./app/ClientEventEnum.h ==========
Lines: 74

//ClientEventEnum.h
#pragma once
#include <string>

enum class EventType {
    // ===== UI å‘½ä»¤ =====
    CmdConnect,
    CmdDisconnect,
    CmdLogin,

    // ===== TCP =====
    TcpConnected,
    TcpDisconnected,

    // ===== åè®® =====
    LoginOk,
    LoginFail,
    OnlineUsers,
    Unknow,

    HeartbeatOk,
    HeartbeatTimeout,
    HeartbeatTick,

    SelectLan,
    SelectVpn,
    CmdSendText,
    ForwardText,
    CmdCall,
    CallIncoming,
    CallAccepted,
    CallRejected,
    CmdAcceptCall,
    CmdRejectCall,
    MediaPeer
    // CallIncoming,    // æ”¶åˆ°æ¥ç”µ
    // CallAccepted,    // é€šè¯è¢«æ¥å¬
    // CallRejected,    // é€šè¯è¢«æ‹’ç»
    // MediaOfferResp,  // åª’ä½“Offerå“åº”
    // MediaAnswerResp  // åª’ä½“Answerå“åº”
};


inline std::string EventTypeToString(EventType type) {
    // ä½¿ç”¨switch-caseç²¾å‡†æ˜ å°„æ¯ä¸ªæšä¸¾å€¼
    switch (type) {
    case EventType::CmdConnect:        return "InCmdConnect";
    case EventType::CmdDisconnect:     return "InCmdDisconnect";
    case EventType::CmdLogin:          return "InCmdLogin";
    case EventType::TcpConnected:      return "InTcpConnected";
    case EventType::TcpDisconnected:   return "InTcpDisconnected";
    case EventType::LoginOk:           return "InLoginOk";
    case EventType::LoginFail:         return "InLoginFail";
    case EventType::OnlineUsers:       return "InOnlineUsers";
    case EventType::Unknow:            return "InUnknow";
    case EventType::HeartbeatOk:       return "InHeartbeatOk";
    case EventType::HeartbeatTimeout:  return "InHeartbeatTimeout";
    case EventType::HeartbeatTick:     return "InHeartbeatTick";
    case EventType::SelectLan:         return "InSelectLan";
    case EventType::SelectVpn:         return "InSelectVpn";
    case EventType::CmdSendText:       return "InCmdSendText";
    case EventType::ForwardText:       return "InForwardText";
    case EventType::CmdCall:           return "InCmdCall";
    case EventType::CallIncoming:      return "InCallIncoming";
    case EventType::CallAccepted:      return "InCallAccepted";
    case EventType::CallRejected:      return "InCallRejected";
    case EventType::CmdAcceptCall:     return "InCmdAcceptCall";
    case EventType::CmdRejectCall:     return "InCmdRejectCall";
    case EventType::MediaPeer:         return "InMediaPeer";

    // å¤„ç†æœªåŒ¹é…åˆ°çš„æšä¸¾å€¼ï¼ˆå¥å£®æ€§ä¿éšœï¼‰
    default: return "InUnknownEventType";
    }
}

========== ./media/VideoReceiver.h ==========
Lines: 33

//VideoReceiver.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

// å’ŒCameraManagerå®Œå…¨å¯¹ç§°çš„æ¥æ”¶ç±»
class VideoReceiver {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    VideoReceiver();
    ~VideoReceiver();

    // è®¾ç½®å¸§å›è°ƒï¼ˆæ¨ç»™Qt UIï¼‰
    void setFrameCallback(FrameCallback cb);
    // å¯åŠ¨æ¥æ”¶ï¼ˆç›‘å¬æŒ‡å®šUDPç«¯å£ï¼‰
    bool start(int listenPort);
    // åœæ­¢æ¥æ”¶
    void stop();

private:
    // appsinkå›è°ƒå‡½æ•°ï¼ˆå¤ç”¨CameraManagerçš„é€»è¾‘ï¼‰
    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);

private:
    GstElement* pipeline_ = nullptr;  // æ¥æ”¶ç«¯ç‹¬ç«‹pipeline
    GstElement* appsink_  = nullptr;  // æ¥æ”¶ç«¯appsink
    FrameCallback callback_;          // å¸§å›è°ƒ
};

========== ./media/CameraManager.cpp ==========
Lines: 111

//CameraManager.cpp
#include "CameraManager.h"
#include <iostream>
#include <cstring>

CameraManager::CameraManager() {
    gst_init(nullptr, nullptr);
}

CameraManager::~CameraManager() {
    stop();
}

void CameraManager::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool CameraManager::start(const std::string& device, const std::string& udpHost, int udpPort) {
    // æ–°å¢ï¼šå‚æ•°åˆæ³•æ€§æ ¡éªŒï¼ˆé¿å…æ— æ•ˆé…ç½®å¯¼è‡´æ¨æµå¤±è´¥ï¼‰
    if (udpHost.empty()) {
        std::cout << "[CameraManager] Error: UDP host IP cannot be empty\n";
        return false;
    }
    if ( (udpPort < 1) || (udpPort > 65535) ) {
        std::cout << "[CameraManager] Error: UDP port must be between 1 and 65535 (got: " << udpPort << ")\n";
        return false;
    }

    if (pipeline_) return true;
    std::cout << "[CameraManager] Attempting to start camera: " << device << std::endl;
    // æ ¸å¿ƒä¿®æ”¹ï¼šç”¨è¾“å…¥å‚æ•°udpHostã€udpPortæ›¿æ¢ç¡¬ç¼–ç çš„192.168.6.15å’Œ5000
    std::string pipelineStr =
        "v4l2src device=" + device +
        " ! video/x-raw,format=YUY2,width=640,height=480,framerate=30/1 "
        " ! videoconvert "
        " ! openh264enc bitrate=2000000 "
        " ! h264parse "
        " ! tee name=t "
        " t. ! queue "
        "     ! avdec_h264 "
        "     ! videoconvert "
        "     ! video/x-raw,format=RGB "
        "     ! appsink name=sink "
        " t. ! queue "
        "     ! rtph264pay pt=96 config-interval=1 "
        // å…³é”®æ›¿æ¢ï¼šhost=${udpHost} port=${udpPort}
        "     ! udpsink host=" + udpHost + " port=" + std::to_string(udpPort) + " sync=false async=false";

    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "Failed to create pipeline\n";
        return false;
    }

    /* appsink ç”¨äº Qt æ˜¾ç¤º */
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "sink");

    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1);

    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    std::cout << "[CameraManager] Camera started successfully: " << device
              << " | UDP push to: " << udpHost << ":" << udpPort << std::endl;
    return true;
}
void CameraManager::stop() {
    if (!pipeline_) return;

    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn CameraManager::onNewSample(GstAppSink* sink, gpointer user_data) {
    auto* self = static_cast<CameraManager*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3;
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    self->callback_(frame);

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

========== ./media/CameraManager.h ==========
Lines: 29

//CameraManager.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

class CameraManager {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    CameraManager();
    ~CameraManager();

    bool start(const std::string& device, const std::string& udpHost, int udpPort);
    void stop();

    void setFrameCallback(FrameCallback cb);

private:
    GstElement* pipeline_ = nullptr;
    GstElement* appsink_  = nullptr;

    FrameCallback callback_;

    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);
};

========== ./media/Frame.h ==========
Lines: 19

//Frame.h
#pragma once
#include <vector>
#include <cstdint>
#include <QMetaType>   // âš ï¸ å¿…é¡»åŠ è¿™ä¸€è¡Œ
enum class PixelFormat {
    RGB888
};

struct Frame {
    std::vector<uint8_t> data; // è¿ç»­å†…å­˜
    int width = 0;
    int height = 0;
    int stride = 0;
    PixelFormat format;
    uint64_t timestamp = 0;
};

Q_DECLARE_METATYPE(Frame)

========== ./media/VideoReceiver.cpp ==========
Lines: 107

//VideoReceiver.cpp
#include "VideoReceiver.h"
#include <iostream>
#include <cstring>

VideoReceiver::VideoReceiver() {
    // åˆå§‹åŒ–GStreamerï¼ˆå’ŒCameraManagerä¿æŒä¸€è‡´ï¼‰
    gst_init(nullptr, nullptr);
}

VideoReceiver::~VideoReceiver() {
    stop(); // ææ„æ—¶ç¡®ä¿åœæ­¢pipeline
}

void VideoReceiver::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool VideoReceiver::start(int listenPort) {
    // æ ¡éªŒç«¯å£åˆæ³•æ€§
    if ((listenPort < 1) || (listenPort > 65535)) {
        std::cerr << "[VideoReceiver] Invalid listen port: " << listenPort << std::endl;
        return false;
    }

    if (pipeline_) return true; // é¿å…é‡å¤å¯åŠ¨

    // æ ¸å¿ƒï¼šæ¥æ”¶ç«¯pipelineå­—ç¬¦ä¸²ï¼ˆappsinkç‰ˆï¼Œé€‚é…Qt RGBæ˜¾ç¤ºï¼‰
    std::string pipelineStr =
        "udpsrc port=" + std::to_string(listenPort) +
        " caps=\"application/x-rtp,media=video,encoding-name=H264,payload=96\" "
        " ! rtph264depay "          // RTPè§£åŒ…ï¼ˆå»æ‰RTPå¤´ï¼‰
        " ! h264parse "             // H264è§£æï¼ˆä¿è¯è§£ç å™¨è¾“å…¥ç¨³å®šï¼‰
        " ! avdec_h264 "            // H264è½¯ä»¶è§£ç ï¼ˆå…¼å®¹æ‰€æœ‰å¹³å°ï¼‰
        " ! videoconvert "          // é¢œè‰²ç©ºé—´è½¬æ¢ï¼ˆè§£ç åå¯èƒ½æ˜¯YUVï¼Œè½¬RGBï¼‰
        " ! video/x-raw,format=RGB "// å’ŒQtæ˜¾ç¤ºæ ¼å¼å®Œå…¨ä¸€è‡´ï¼ˆRGB888ï¼‰
        " ! appsink name=recv_sink "; // æ¥æ”¶ç«¯appsinkï¼ˆå‘½åä¸ºrecv_sinkï¼Œé¿å…å’Œå‘é€ç«¯å†²çªï¼‰

    // åˆ›å»ºpipeline
    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "[VideoReceiver] Failed to create pipeline" << std::endl;
        return false;
    }

    // é…ç½®appsinkï¼ˆå’ŒCameraManageré€»è¾‘å®Œå…¨å¤ç”¨ï¼‰
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "recv_sink");
    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1); // åªä¿ç•™æœ€æ–°å¸§ï¼Œé¿å…å¡é¡¿

    // ç»‘å®šnew-sampleä¿¡å·ï¼ˆå¸§å›è°ƒï¼‰
    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    // å¯åŠ¨pipeline
    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    std::cout << "[VideoReceiver] Started successfully, listen on UDP port: " << listenPort << std::endl;
    return true;
}

void VideoReceiver::stop() {
    if (!pipeline_) return;

    // åœæ­¢pipelineå¹¶é‡Šæ”¾èµ„æºï¼ˆGStreameræ ‡å‡†æ“ä½œï¼‰
    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn VideoReceiver::onNewSample(GstAppSink* sink, gpointer user_data) {
    // å®Œå…¨å¤ç”¨CameraManagerçš„å¸§å¤„ç†é€»è¾‘ï¼ˆä¿è¯å’Œå‘é€ç«¯æ ¼å¼ä¸€è‡´ï¼‰
    auto* self = static_cast<VideoReceiver*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3; // RGB888ï¼šæ¯è¡Œå­—èŠ‚æ•°=å®½åº¦Ã—3
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    // è°ƒç”¨å›è°ƒï¼ŒæŠŠå¸§æ¨ç»™Qt UI
    self->callback_(frame);

    // é‡Šæ”¾èµ„æºï¼ˆGStreamerå†…å­˜ç®¡ç†å¿…é¡»åšï¼‰
    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}


=====================================
Total files: 38
Total lines: 3259
