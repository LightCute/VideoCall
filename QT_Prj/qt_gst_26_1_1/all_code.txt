
========== ./main.cpp ==========
Lines: 36

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <variant>

#ifdef slots
#undef slots
#endif
#ifdef signals
#undef signals
#endif

#include <QApplication>
#include "widget.h"
#include "LoginWidget.h"
#include "AppWindow.h"

// #include "widget.h"
// #include "LoginWidget.h"
// #include <QApplication>
// #include "AppWindow.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    qRegisterMetaType<Frame>("Frame");
    AppWindow w;
    //LoginWidget login_W;
    //login_W.show();
    w.show();
    return a.exec();
}

========== ./core/ClientCore.cpp ==========
Lines: 90

// core/ClientCore.cpp
#include "ClientCore.h"


ClientCore::ClientCore() : fsm_(State::Disconnected) {
    socket_.setMessageCallback([this](const std::string& msg){
        // è½¬æˆ CoreInput
        postInput(core::EvLoginOk{}); // ç¤ºä¾‹
    });

    socket_.setConnectCallback([this]{
        postInput(core::EvTcpConnected{});
    });

    socket_.setDisconnectCallback([this]{
        postInput(core::EvTcpDisconnected{});
    });

    std::thread([this]{ processEvents(); }).detach();
}

ClientCore::~ClientCore() {
    socket_.stop();
}

void ClientCore::postInput(core::CoreInput ev) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        inputQueue_.push(std::move(ev));
    }
    cv_.notify_one();
}

bool ClientCore::pollOutput(CoreOutput& out) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (outputQueue_.empty()) return false;
    out = std::move(outputQueue_.front());
    outputQueue_.pop();
    return true;
}

void ClientCore::processEvents() {
    while (true) {
        core::CoreInput ev;
        {
            std::unique_lock<std::mutex> lock(mtx_);
            cv_.wait(lock, [this]{ return !inputQueue_.empty(); });
            ev = std::move(inputQueue_.front());
            inputQueue_.pop();
        }

        auto outputs = fsm_.handle(std::move(ev));
        {
            std::lock_guard<std::mutex> lock(mtx_);
            for (auto& o : outputs) {
                // ===== ä¿®æ­£åçš„ OutConnect å¤„ç†é€»è¾‘ =====
                if (auto connectEv = std::get_if<OutConnect>(&o)) {
                    // ä¸´æ—¶å˜é‡æ‹·è´ï¼ˆå…¼å®¹C++11ï¼‰
                    std::string host = connectEv->host;
                    int port = connectEv->port;

                    // å¼‚æ­¥æ‰§è¡Œè¿æ¥
                    std::thread connectThread([this, host, port]() {
                        bool connectResult = this->socket_.connectToServer(host, port);
                        if (!connectResult) {
                            this->postInput(core::EvTcpDisconnected{});
                        }
                    });
                    connectThread.detach();
                }
                // ===== OutSendLogin å¤„ç†é€»è¾‘ï¼ˆåŸæœ‰ï¼‰=====
                if (auto loginEv = std::get_if<OutSendLogin>(&o)) {
                    std::string loginMsg = proto::makeLoginRequest(loginEv->user, loginEv->pass);
                    socket_.sendMessage(loginMsg);
                }

                // ğŸ”´ å…³é”®ï¼šå…ˆæŠŠ OutStateChanged å†™å…¥é˜Ÿåˆ—ï¼Œå†å¤„ç†å…¶ä»–é€»è¾‘
                std::cout << "[ClientCore] write outputQueue_, type index: " << o.index() << std::endl;
                outputQueue_.push(std::move(o));
            }
        }
    }
}
bool ClientCore::connectToServer(const std::string& host, int port) {
    return socket_.connectToServer(host, port);
}

void ClientCore::sendLogin(const std::string& user, const std::string& pass) {
    socket_.sendMessage("login"); // ä¼ªç¤ºä¾‹
}

========== ./core/FSM.h ==========
Lines: 34

// core/FSM.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "ClientState.h"
#include <vector>
#include <functional>
#include "ClientEventEnum.h"
#include <variant>
#include <iostream>

struct FSMEntry {
    State current_state;
    EventType event_type; // ç”¨ int æˆ–æšä¸¾
    std::function<std::vector<CoreOutput>(const core::CoreInput&)> action;
    State next_state;
};

class FSM {
public:
    FSM(State init);

    std::vector<CoreOutput> handle(core::CoreInput ev);

    State getState() const { return state_; }

private:

    EventType eventTypeFromInput(const core::CoreInput& ev);

    State state_;
    std::vector<FSMEntry> table_;
    void initTable();
};

========== ./core/CoreInput.h ==========
Lines: 28

// core/CoreInput.h
#pragma once
#include <variant>
#include <string>
namespace core {

struct EvCmdConnect { std::string host; int port; };
struct EvCmdDisconnect {};
struct EvCmdLogin { std::string user; std::string pass; };
struct EvTcpConnected {};
struct EvTcpDisconnected {};
struct EvLoginOk {};
struct EvLoginFail { std::string msg; };
struct EvOnlineUsers { std::string list; };
struct EvUnknow {};

using CoreInput = std::variant<
    EvCmdConnect,
    EvCmdDisconnect,
    EvCmdLogin,
    EvTcpConnected,
    EvTcpDisconnected,
    EvLoginOk,
    EvLoginFail,
    EvOnlineUsers,
    EvUnknow
    >;
}

========== ./core/FSM.cpp ==========
Lines: 138

// core/FSM.cpp
#include "FSM.h"

FSM::FSM(State init) : state_(init) {
    // æ–°å¢ï¼šæ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–çŠ¶æ€è¡¨
    initTable();
}

std::vector<CoreOutput> FSM::handle(core::CoreInput ev) {
    EventType evType = eventTypeFromInput(ev);
    std::cout << "[FSM] event type: " << static_cast<int>(evType) << " current state: " << static_cast<int>(state_) << std::endl;
    for (auto& entry : table_) {
        if (entry.current_state == state_ && entry.event_type == evType) {
            // äº‹ä»¶ç±»å‹åŒ¹é…ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œç”¨ type_index æˆ–è‡ªå®šä¹‰ EventTypeï¼‰
            // å¦‚æœåŒ¹é…ï¼š
            auto outputs = entry.action(ev);
            std::cout << "[FSM] matchedï¼Œoutput num: " << outputs.size() << std::endl;
            state_ = entry.next_state;
            return outputs;
        }
    }
    std::cout << "[FSM] no matched" << std::endl;
    return {};
}

EventType FSM::eventTypeFromInput(const core::CoreInput& ev) {
    EventType evType = EventType::Unknow;
    std::visit([&evType](auto&& e){
        using T = std::decay_t<decltype(e)>;
        if constexpr (std::is_same_v<T, core::EvCmdConnect>)      evType = EventType::CmdConnect;
        else if constexpr (std::is_same_v<T, core::EvCmdDisconnect>) evType = EventType::CmdDisconnect;
        else if constexpr (std::is_same_v<T, core::EvCmdLogin>)   evType = EventType::CmdLogin;

        else if constexpr (std::is_same_v<T, core::EvTcpConnected>)    evType = EventType::TcpConnected;
        else if constexpr (std::is_same_v<T, core::EvTcpDisconnected>) evType = EventType::TcpDisconnected;

        else if constexpr (std::is_same_v<T, core::EvLoginOk>)   evType = EventType::LoginOk;
        else if constexpr (std::is_same_v<T, core::EvLoginFail>) evType = EventType::LoginFail;
        else if constexpr (std::is_same_v<T, core::EvOnlineUsers>) evType = EventType::OnlineUsers;

        else evType = EventType::Unknow;
    }, ev);
    return evType;
}


void FSM::initTable() {
    table_ = {
      // ===== æ–­å¼€æ€ =====
        { State::Disconnected, EventType::CmdConnect,
          [](const core::CoreInput& ev) -> std::vector<CoreOutput> {
              std::vector<CoreOutput> out;
              if (auto e = std::get_if<core::EvCmdConnect>(&ev)) {
                  // åœ¨ FSM é‡Œåªèƒ½è¿”å›è¾“å‡ºï¼Œä¸ç›´æ¥æ“ä½œ Core
                  // å¯ä»¥ç”¨è¾“å‡ºé€šçŸ¥ Core åšè¿æ¥
                  out.push_back(OutStateChanged{State::Connecting});
                  out.push_back(OutConnect{e->host,e->port});
                  // å¯ç”¨ç‰¹æ®Šè¾“å‡ºé€šçŸ¥ Core å» connect
                  // ä¹Ÿå¯ä»¥è®© ClientCore åœ¨ postInput åç«‹å³ connect
              }
              return out;
          },
          State::Connecting
      },

      // ===== æ­£åœ¨è¿æ¥ =====
        { State::Connecting, EventType::TcpConnected,
          [](const core::CoreInput& ev) -> std::vector<CoreOutput> {
              std::vector<CoreOutput> out;
             if (auto e = std::get_if<core::EvTcpConnected>(&ev)) {
                  out.push_back(OutStateChanged{State::Connected});
              }
              return out;
          },
          State::Connected
      },

        { State::Connecting, EventType::TcpDisconnected,
          [](const core::CoreInput&){ return std::vector<CoreOutput>{}; },
          State::Disconnected
      },

      // ===== å·²è¿æ¥ =====
        { State::Connected, EventType::CmdLogin,
          [](const core::CoreInput& ev) -> std::vector<CoreOutput> {
              std::vector<CoreOutput> out;
              if (auto e = std::get_if<core::EvCmdLogin>(&ev)) {
                  // Core ä¼šåœ¨ ClientCore å±‚å¤„ç† sendLogin
                  out.push_back(OutStateChanged{State::LoggingIn});
                  out.push_back(OutSendLogin{e->user, e->pass});
              }
              return out;
          },
          State::LoggingIn
      },

      // ===== æ­£åœ¨ç™»å½• =====
        { State::LoggingIn, EventType::LoginOk ,
         [](const core::CoreInput& ev) -> std::vector<CoreOutput> {
              std::vector<CoreOutput> out;
             if (auto e = std::get_if<core::EvLoginOk>(&ev)) {
                  out.push_back(OutLoginOk{});
                  out.push_back(OutStateChanged{State::LoggedIn});
              }
              return out;
          },
          State::LoggedIn
      },

        { State::LoggingIn, EventType::LoginFail ,
          [](const core::CoreInput& ev) -> std::vector<CoreOutput> {
              std::vector<CoreOutput> out;
              if (auto e = std::get_if<core::EvLoginFail>(&ev)) {
                  out.push_back(OutLoginFail{e->msg});
                  out.push_back(OutStateChanged{State::Connected});
              }
              return out;
          },
          State::Connected
      },

      // ===== ä»»ä½•åœ¨çº¿çŠ¶æ€æ–­çº¿ =====
      { State::Connected,  EventType::TcpDisconnected,
          [](const core::CoreInput&){ return std::vector<CoreOutput>{OutStateChanged{State::Disconnected}, OutDisconnected{}}; },
          State::Disconnected
      },
      { State::LoggingIn,  EventType::TcpDisconnected,
          [](const core::CoreInput&){ return std::vector<CoreOutput>{OutStateChanged{State::Disconnected}, OutDisconnected{}}; },
          State::Disconnected
      },
      { State::LoggedIn,   EventType::TcpDisconnected,
          [](const core::CoreInput&){ return std::vector<CoreOutput>{OutStateChanged{State::Disconnected}, OutDisconnected{}}; },
          State::Disconnected
      },
  };
}



========== ./core/ClientCore.h ==========
Lines: 37

// core/ClientCore.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "FSM.h"
#include "CommandSocket.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include "protocol_text.h"
#include <iostream>

class ClientCore {
public:
    ClientCore();
    ~ClientCore();

    // çº¿ç¨‹å®‰å…¨æ¥å£
    void postInput(core::CoreInput ev);
    bool pollOutput(CoreOutput& out);

    // å¯é€‰æ¥å£
    bool connectToServer(const std::string& host, int port);
    void sendLogin(const std::string& user, const std::string& pass);

private:
    FSM fsm_;
    CommandSocket socket_;

    std::queue<core::CoreInput>  inputQueue_;
    std::queue<CoreOutput> outputQueue_;
    std::mutex mtx_;
    std::condition_variable cv_;

    void processEvents(); // åå°çº¿ç¨‹
};

========== ./core/ClientState.h ==========
Lines: 24

// ClientState.h
#pragma once

#include <string>

enum class State {
    Disconnected,
    Connecting,
    Connected,
    LoggingIn,
    LoggedIn
};

// å°† State è½¬æ¢ä¸ºå­—ç¬¦ä¸²
inline std::string stateToString(State s) {
    switch (s) {
    case State::Disconnected: return "Disconnected";
    case State::Connecting:   return "Connecting";
    case State::Connected:    return "Connected";
    case State::LoggingIn:    return "LoggingIn";
    case State::LoggedIn:     return "LoggedIn";
    default:                  return "Unknown";
    }
}

========== ./core/CoreOutput.h ==========
Lines: 20

// core/CoreOutput.h
#pragma once
#include <variant>
#include "ClientState.h"

struct OutStateChanged { State state; };
struct OutLoginOk {};
struct OutLoginFail { std::string msg; };
struct OutDisconnected {};
struct OutConnect { std::string host; int port; };
struct OutSendLogin { std::string user; std::string pass; };

using CoreOutput = std::variant<
    OutStateChanged,
    OutLoginOk,
    OutLoginFail,
    OutDisconnected,
    OutConnect,
    OutSendLogin
    >;

========== ./net/PacketCodec.h ==========
Lines: 39

//PacketCodec.h
#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 48

//CommandSocket.h
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <vector>
#include "PacketCodec.h"

class CommandSocket {
public:
    using MessageCallback = std::function<void(const std::string&)>;
    using ConnectCallback = std::function<void()>;
    using DisconnectCallback = std::function<void()>;

    CommandSocket();
    ~CommandSocket();

    void setConnectCallback(ConnectCallback cb);
    void setDisconnectCallback(DisconnectCallback cb);
    // TCP å®¢æˆ·ç«¯
    bool connectToServer(const std::string& host, int port);

    // TCP æœåŠ¡å™¨
    bool startServer(int port);

    void setMessageCallback(MessageCallback cb);

    // å‘é€æ•°æ®
    void sendMessage(const std::string& msg);

    // åœæ­¢
    void stop();

private:
    void clientThreadFunc();
    void serverThreadFunc();
    void sendPacket(int fd, const std::string& payload);
    int sockfd_ = -1;
    int clientfd_ = -1;  // å¯¹äºæœåŠ¡å™¨ç«¯ä¿å­˜å®¢æˆ·ç«¯è¿æ¥
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    MessageCallback callback_;

    ConnectCallback onConnect_;
    DisconnectCallback onDisconnect_;

};

========== ./net/CommandSocket.cpp ==========
Lines: 139

//CommandSocket.cpp
#include "CommandSocket.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

CommandSocket::CommandSocket() {}

CommandSocket::~CommandSocket() {
    stop();
}

void CommandSocket::setMessageCallback(MessageCallback cb) {
    callback_ = std::move(cb);
}

void CommandSocket::setConnectCallback(ConnectCallback cb) {
    onConnect_ = std::move(cb);
}

void CommandSocket::setDisconnectCallback(DisconnectCallback cb) {
    onDisconnect_ = std::move(cb);
}


void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


bool CommandSocket::connectToServer(const std::string& host, int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &serv_addr.sin_addr);

    if (connect(sockfd_, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sockfd_);
        sockfd_ = -1;
        return false;
    }

    if (onConnect_) onConnect_();   // â­ TCPçœŸæ­£å»ºç«‹
    // std::thread([this]{
    //     if (onConnect_) onConnect_();
    // }).detach();

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::clientThreadFunc, this);
    return true;
}

bool CommandSocket::startServer(int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(sockfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(sockfd_, 1) < 0) return false;

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::serverThreadFunc, this);
    return true;
}

void CommandSocket::sendMessage(const std::string& msg) {
    int fd = (clientfd_ >= 0) ? clientfd_ : sockfd_;
    sendPacket(fd,msg);
}

void CommandSocket::stop() {
    running_ = false;
    if (workerThread_.joinable())
        workerThread_.join();
    if (sockfd_ >= 0) close(sockfd_);
    if (clientfd_ >= 0) close(clientfd_);
    sockfd_ = -1;
    clientfd_ = -1;
}

void CommandSocket::clientThreadFunc() {
    std::vector<char> recvBuffer;
    char temp[1024];

    while (running_) {
        int n = recv(sockfd_, temp, sizeof(temp), 0);
        if (n > 0) {

            // 1ï¸âƒ£ æŠŠæ”¶åˆ°çš„å­—èŠ‚å¡è¿›ç¼“å­˜
            recvBuffer.insert(recvBuffer.end(), temp, temp + n);

            // 2ï¸âƒ£ å°è¯•ä»ç¼“å­˜ä¸­æ‹†å®Œæ•´åŒ…
            std::string payload;
            while (PacketCodec::tryDecode(recvBuffer, payload)) {

                // 3ï¸âƒ£ æ¯ä¸€ä¸ª payload = ä¸€æ¡å®Œæ•´â€œåº”ç”¨å±‚æ¶ˆæ¯â€
                if (callback_) {
                    callback_(payload);
                }
            }

        } else if (n <= 0) {
            if (onDisconnect_) onDisconnect_();  // â­ TCPæ–­çº¿
            break; // æœåŠ¡å™¨æ­£å¸¸æ–­å¼€
        }
    }
}

void CommandSocket::serverThreadFunc() {
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    clientfd_ = accept(sockfd_, (sockaddr*)&client_addr, &client_len);
    if (clientfd_ < 0) return;

    char buffer[1024];
    while (running_) {
        int n = recv(clientfd_, buffer, sizeof(buffer) - 1, 0);
        if (n > 0) {
            buffer[n] = '\0';
            if (callback_) callback_(std::string(buffer));
        } else if (n == 0) {
            break; // å®¢æˆ·ç«¯æ–­å¼€
        }
    }
}

========== ./ui/VideoWidget.cpp ==========
Lines: 35

//VideoWidget.cpp
#include "VideoWidget.h"
#include <QPainter>
#include <QDebug>
VideoWidget::VideoWidget(QWidget *parent)
    : QWidget(parent) {
    setMinimumSize(640, 480);
}

void VideoWidget::setFrame(const QImage &img) {
    frame_ = img;
    update();
}

void VideoWidget::paintEvent(QPaintEvent *) {
    QPainter p(this);
    p.fillRect(rect(), Qt::black);

    if (frame_.isNull())
        return;

    QSize imgSize = frame_.size();
    imgSize.scale(size(), Qt::KeepAspectRatio);

    QRect targetRect(
        (width()  - imgSize.width())  / 2,
        (height() - imgSize.height()) / 2,
        imgSize.width(),
        imgSize.height()
        );
    //qDebug() << "widget size:" << size();

    p.drawImage(targetRect, frame_);
}


========== ./ui/widget.cpp ==========
Lines: 46

//widget.cpp
#include "widget.h"
#include "./ui_widget.h"
#include <QDebug>

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    video_ = new VideoWidget(ui->videoContainer);
    // video_->setSizePolicy(QSizePolicy::Expanding,
    //                       QSizePolicy::Expanding);
    adapter_ = new QtCameraAdapter(video_, this);


}

Widget::~Widget()
{
    delete ui;
}

void Widget::on_Bt_video_on_off_clicked()
{
    qDebug("Button clicked!");
    camera_.start("/dev/video0");
}


void Widget::on_Bt_video_off_clicked()
{
    qDebug("Button clicked!");
    camera_.stop();
}


void Widget::on_Bt_tcp_send_clicked()
{
}


void Widget::on_Bt_tcp_connect_clicked()
{
}


========== ./ui/QtCameraAdapter.cpp ==========
Lines: 18

//QtCameraAdapter.cpp
#include "QtCameraAdapter.h"
#include <QImage>

QtCameraAdapter::QtCameraAdapter(VideoWidget* view, QObject* parent)
    : QObject(parent), view_(view) {}

void QtCameraAdapter::onFrame(Frame f) {
    QImage img(
        f.data.data(),
        f.width,
        f.height,
        f.stride,
        QImage::Format_RGB888
        );

    view_->setFrame(img.copy());
}

========== ./ui/LoginWidget.h ==========
Lines: 53

//LoginWidget.h
#ifndef LOGINWIDGET_H
#define LOGINWIDGET_H

#include <QWidget>

#include "widget.h"

#include "ClientCore.h"

namespace Ui {
class LoginWidget;
}

class LoginWidget : public QWidget
{
    Q_OBJECT

public:
    explicit LoginWidget(QWidget *parent = nullptr);
    ~LoginWidget();

signals:
    void loginSuccess();

private slots:

    void on_Bt_Jump_Test_clicked();

    void on_Bt_ConnectToServer_clicked();

    void on_Bt_tcp_test_send_clicked();

    void on_Bt_Login_clicked();

private:
    Ui::LoginWidget *ui;
    ClientCore* core_;

    void handle(const OutLoginFail&);

    void handle(const OutDisconnected&) ;

    void handle(const OutLoginOk&) ;

    void handle(const OutStateChanged& e) ;

    void handle(const OutConnect&);       // æ–°å¢
    void handle(const OutSendLogin&);

};

#endif // LOGINWIDGET_H

========== ./ui/AppWindow.cpp ==========
Lines: 30

//AppWindow.cpp
#include "AppWindow.h"
#include "LoginWidget.h"
#include "widget.h"
#include <QVBoxLayout>

AppWindow::AppWindow(QWidget *parent)
    : QWidget(parent)
{
    resize(900, 600);
    stack = new QStackedWidget(this);

    loginPage = new LoginWidget;
    mainPage  = new Widget;

    stack->addWidget(loginPage); // index 0
    stack->addWidget(mainPage);  // index 1

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(stack);
    setLayout(layout);

    // ç™»å½•æˆåŠŸ â†’ åˆ‡æ¢é¡µé¢
    connect(loginPage, &LoginWidget::loginSuccess, this, [=](){
        stack->setCurrentIndex(PAGE_MAIN);
    });

    // åˆå§‹é¡µé¢
    stack->setCurrentIndex(PAGE_LOGIN);
}

========== ./ui/VideoWidget.h ==========
Lines: 17

//VideoWidget.h
#pragma once
#include <QWidget>
#include <QImage>

class VideoWidget : public QWidget {
    Q_OBJECT
public:
    explicit VideoWidget(QWidget *parent = nullptr);
    void setFrame(const QImage &img);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QImage frame_;
};

========== ./ui/QtCameraAdapter.h ==========
Lines: 17

//QtCameraAdapter.h
#pragma once
#include <QObject>
#include "Frame.h"
#include "VideoWidget.h"

class QtCameraAdapter : public QObject {
    Q_OBJECT
public:
    explicit QtCameraAdapter(VideoWidget* view, QObject* parent = nullptr);

public slots:
    void onFrame(Frame frame);

private:
    VideoWidget* view_;
};

========== ./ui/LoginWidget.cpp ==========
Lines: 110

//LoginWidget.cpp
#include "LoginWidget.h"
#include "./ui_LoginWidget.h"
#include <QMessageBox>
#include <QMetaObject>
#include <QDebug>

#include <QThread>
#include <QTimer>

LoginWidget::LoginWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::LoginWidget)
{
    ui->setupUi(this);

    core_ = new ClientCore;

    QTimer* timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, [this]{
        CoreOutput out;
        while (core_->pollOutput(out)) {
            std::cout << "[UI] get output, type index: " << out.index() << std::endl;
            std::visit([this](const auto& e){
                handle(e);
            }, out);
        }
    });
    timer->start(10);


}

LoginWidget::~LoginWidget()
{
    delete ui;
}




void LoginWidget::on_Bt_Jump_Test_clicked()
{
    emit loginSuccess();
}


void LoginWidget::on_Bt_ConnectToServer_clicked()
{
    qDebug() << "current thread:" << QThread::currentThread();
    qDebug() << "ui thread:" << qApp->thread();

    ui->TextEdit_tcp_test_recv->setPlainText("Connecting\n");
    //core_->postEvent(EvCmdConnect{"127.0.0.1", 6001});
    core_->postInput(core::EvCmdConnect{"127.0.0.1",6001});

}


void LoginWidget::on_Bt_tcp_test_send_clicked()
{
    QString qmsg = ui->LE_tcp_send_test->text();
    std::string msg = qmsg.toStdString();
    //core_->sendRaw(msg);
}

void LoginWidget::handle(const OutLoginFail&) {
    std::cout << "[UI] handle OutLoginFail: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login failed");
}

void LoginWidget::handle(const OutDisconnected&) {
    std::cout << "[UI] handle OutDisconnected: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutDisconnected");
}

void LoginWidget::handle(const OutLoginOk&) {
    std::cout << "[UI] handle OutLoginOk: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login success");
}

void LoginWidget::handle(const OutStateChanged& e) {
    std::cout << "[UI] handle OutStateChanged: " << stateToString(e.state) << std::endl;
    ui->TextEdit_FSM_State->setPlainText(QString::fromStdString(stateToString(e.state)));
}

// ui/LoginWidget.cpp ä¸­è¡¥å……ä»¥ä¸‹ handle é‡è½½
void LoginWidget::handle(const OutConnect& e) {
    std::cout << "[UI] handle OutConnect: " << e.host << ":" << e.port << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutConnect");

}

void LoginWidget::handle(const OutSendLogin& e) {
    std::cout << "[UI] handle OutSendLogin: " <<  e.user << ":"  << e.pass << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutSendLogin");
}


void LoginWidget::on_Bt_Login_clicked()
{
    QString qstr_user_name = ui->LE_UserName->text();
    std::string msg_user_name = qstr_user_name.toStdString();

    QString qstr_user_pass = ui->LE_UserPass->text();
    std::string msg_user_pass = qstr_user_pass.toStdString();

    core_->postInput(core::EvCmdLogin{msg_user_name, msg_user_pass});
}


========== ./ui/AppWindow.h ==========
Lines: 23

//AppWindow.h
#pragma once
#include <QWidget>
#include <QStackedWidget>
#include "LoginWidget.h"
#include "widget.h"

class AppWindow : public QWidget
{
    Q_OBJECT
public:
    explicit AppWindow(QWidget *parent = nullptr);

private:
    QStackedWidget *stack;
    LoginWidget *loginPage;
    Widget *mainPage;

    enum PageIndex {
        PAGE_LOGIN = 0,
        PAGE_MAIN
    };
};

========== ./ui/widget.h ==========
Lines: 39

//widget.h
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "QtCameraAdapter.h"
#include "CameraManager.h"


QT_BEGIN_NAMESPACE
namespace Ui {
class Widget;
}
QT_END_NAMESPACE

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

private slots:
    void on_Bt_video_on_off_clicked();

    void on_Bt_video_off_clicked();

    void on_Bt_tcp_send_clicked();

    void on_Bt_tcp_connect_clicked();

private:
    Ui::Widget *ui;
    VideoWidget *video_;
    CameraManager camera_;
    QtCameraAdapter* adapter_;
};
#endif // WIDGET_H

========== ./protocol/protocol_types.h ==========
Lines: 27

//protocol_types.h
#pragma once
#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct Unknown {
    std::string message;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

}

========== ./protocol/protocol_text.h ==========
Lines: 19

//protocol_text.h
#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);

// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);

}

========== ./protocol/protocol_text.cpp ==========
Lines: 126

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    oss ;
    return oss.str();
}

/* ================= parse ================= */

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}

} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 20

//protocol_common.h
#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN        = "LOGIN";
constexpr const char* CMD_LOGIN_OK     = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL   = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS = "ONLINE_USERS";

// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}

========== ./app/ClientEvent.h ==========
Lines: 40

//ClientEvent.h
#pragma once

#include <string>
#include "protocol_types.h"
#include <variant>

struct EvTcpConnected {};
struct EvTcpDisconnected {};
struct EvLoginOk    { proto::LoginResponse resp; };
struct EvLoginFail { proto::LoginResponse resp; };
struct EvOnlineUsers { proto::OnlineUsers users; };
struct EvUnknow { proto::Unknown error_msg; };
struct EvCmdConnect {
    std::string host;
    int port;
};
struct EvCmdDisconnect {};
struct EvCmdLogin {
    std::string user;
    std::string pass;
};

using ClientEvent = std::variant<
    // UI
    EvCmdConnect,
    EvCmdDisconnect,
    EvCmdLogin,

    // TCP
    EvTcpConnected,
    EvTcpDisconnected,

    // åè®®
    EvLoginOk,
    EvLoginFail,
    EvOnlineUsers,
    EvUnknow
>;


========== ./app/ClientEventFactory.h ==========
Lines: 18

//ClientEventFactory.h
#ifndef CLIENTEVENTFACTORY_H
#define CLIENTEVENTFACTORY_H

#include "protocol_types.h"
#include "ClientEvent.h"
class ClientEventFactory
{
public:
    ClientEventFactory();
    static ClientEvent makeEvent(const std::string& msg);

private:


};

#endif // CLIENTEVENTFACTORY_H

========== ./app/ClientEventFactory.cpp ==========
Lines: 28

//ClientEventFactory.cpp
#include "ClientEventFactory.h"

// åªåœ¨ cpp ä¸­ include è§£æå‡½æ•°
#include "protocol_text.h"
// ä¾‹å¦‚ï¼š
// bool parseLoginResponse(const std::string&, LoginResponse&)
// bool parseOnlineUsers(const std::string&, OnlineUsers&)

ClientEvent ClientEventFactory::makeEvent(const std::string& msg)
{
    proto::LoginResponse login;
    if (proto::parseLoginResponse(msg, login)) {
        if (login.success)
            return EvLoginOk{login};
        else
            return EvLoginFail{login};
    }

    proto::OnlineUsers users;
    if (proto::parseOnlineUsers(msg, users)) {
        return EvOnlineUsers{users};
    }

    proto::Unknown req_error;
    req_error.message = msg;
    return EvUnknow{req_error};
}

========== ./app/ClientEventEnum.h ==========
Lines: 20

//ClientEventEnum.h
#pragma once


enum class EventType {
    // ===== UI å‘½ä»¤ =====
    CmdConnect,
    CmdDisconnect,
    CmdLogin,

    // ===== TCP =====
    TcpConnected,
    TcpDisconnected,

    // ===== åè®® =====
    LoginOk,
    LoginFail,
    OnlineUsers,
    Unknow
};

========== ./media/CameraManager.cpp ==========
Lines: 98

//CameraManager.cpp
#include "CameraManager.h"
#include <iostream>
#include <cstring>

CameraManager::CameraManager() {
    gst_init(nullptr, nullptr);
}

CameraManager::~CameraManager() {
    stop();
}

void CameraManager::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool CameraManager::start(const std::string& device) {
    if (pipeline_) return true;

    std::string pipelineStr =
        "v4l2src device=" + device +
        " ! video/x-raw,format=YUY2,width=640,height=480,framerate=30/1 "
        " ! videoconvert "
        " ! openh264enc bitrate=2000000 "
        " ! h264parse "
        " ! tee name=t "
        " t. ! queue "
        "     ! avdec_h264 "
        "     ! videoconvert "
        "     ! video/x-raw,format=RGB "
        "     ! appsink name=sink "
        " t. ! queue "
        "     ! rtph264pay pt=96 config-interval=1 "
        "     ! udpsink host=192.168.6.15 port=5000 sync=false async=false";

    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "Failed to create pipeline\n";
        return false;
    }

    /* appsink ç”¨äº Qt æ˜¾ç¤º */
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "sink");

    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1);
    
    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    return true;
}

void CameraManager::stop() {
    if (!pipeline_) return;

    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn CameraManager::onNewSample(GstAppSink* sink, gpointer user_data) {
    auto* self = static_cast<CameraManager*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3;
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    self->callback_(frame);

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

========== ./media/CameraManager.h ==========
Lines: 29

//CameraManager.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

class CameraManager {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    CameraManager();
    ~CameraManager();

    bool start(const std::string& device);
    void stop();

    void setFrameCallback(FrameCallback cb);

private:
    GstElement* pipeline_ = nullptr;
    GstElement* appsink_  = nullptr;

    FrameCallback callback_;

    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);
};

========== ./media/Frame.h ==========
Lines: 19

//Frame.h
#pragma once
#include <vector>
#include <cstdint>
#include <QMetaType>   // âš ï¸ å¿…é¡»åŠ è¿™ä¸€è¡Œ
enum class PixelFormat {
    RGB888
};

struct Frame {
    std::vector<uint8_t> data; // è¿ç»­å†…å­˜
    int width = 0;
    int height = 0;
    int stride = 0;
    PixelFormat format;
    uint64_t timestamp = 0;
};

Q_DECLARE_METATYPE(Frame)


=====================================
Total files: 32
Total lines: 1465
