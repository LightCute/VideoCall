========== å·¥ç¨‹ç›®å½•ç»“æ„ï¼ˆä»…å«.h/.cppï¼‰==========

ğŸ“‚ .:
  â””â”€ main.cpp

ğŸ“‚ ./core:
  â””â”€ ClientCore.cpp
  â””â”€ ClientCore.h
  â””â”€ ClientState.h
  â””â”€ CoreExecutor.cpp
  â””â”€ CoreExecutor.h
  â””â”€ CoreInput.h
  â””â”€ CoreOutput.h
  â””â”€ FSM.cpp
  â””â”€ FSM.h
  â””â”€ ICoreListener.h

ğŸ“‚ ./net:
  â””â”€ CommandSocket.cpp
  â””â”€ CommandSocket.h
  â””â”€ PacketCodec.h

ğŸ“‚ ./ui:
  â””â”€ AppWindow.cpp
  â””â”€ AppWindow.h
  â””â”€ LoginWidget.cpp
  â””â”€ LoginWidget.h
  â””â”€ QtCameraAdapter.cpp
  â””â”€ QtCameraAdapter.h
  â””â”€ VideoWidget.cpp
  â””â”€ VideoWidget.h
  â””â”€ widget.cpp
  â””â”€ widget.h

ğŸ“‚ ./protocol:
  â””â”€ protocol_common.h
  â””â”€ protocol_text.cpp
  â””â”€ protocol_text.h
  â””â”€ protocol_types.h

ğŸ“‚ ./app:
  â””â”€ ClientEvent.h
  â””â”€ ClientEventEnum.h
  â””â”€ ClientEventFactory.cpp
  â””â”€ ClientEventFactory.h

ğŸ“‚ ./media:
  â””â”€ CameraManager.cpp
  â””â”€ CameraManager.h
  â””â”€ Frame.h

==================================================
========== æ‰€æœ‰.h/.cppæ–‡ä»¶å†…å®¹ ==========


========== ./main.cpp ==========
Lines: 37

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <variant>

#ifdef slots
#undef slots
#endif
#ifdef signals
#undef signals
#endif

#include <QApplication>
#include "widget.h"
#include "LoginWidget.h"
#include "AppWindow.h"
#include "core/CoreOutput.h"
// #include "widget.h"
// #include "LoginWidget.h"
// #include <QApplication>
// #include "AppWindow.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    qRegisterMetaType<Frame>("Frame");
    qRegisterMetaType<core::CoreOutput>("core::CoreOutput");  // æ–°å¢
    AppWindow w;
    //LoginWidget login_W;
    //login_W.show();
    w.show();
    return a.exec();
}

========== ./core/ClientCore.cpp ==========
Lines: 155

#include "ClientCore.h"
#include <algorithm>

// æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ– Executorï¼Œè®¾ç½®å›è°ƒ
ClientCore::ClientCore() : fsm_() {
    // åˆå§‹åŒ– Executorï¼šå›è°ƒå‡½æ•°ç”¨äºæ¥æ”¶ Executor æ¨é€çš„ CoreInput
    executor_ = std::make_unique<CoreExecutor>(
        [this](core::CoreInput ev) {
            this->postInput(std::move(ev)); // å°† Executor çš„äº‹ä»¶æ¨å…¥è¾“å…¥é˜Ÿåˆ—
        }
        );

    // å¯åŠ¨äº‹ä»¶å¤„ç†çº¿ç¨‹ï¼ˆä»…è°ƒåº¦ï¼Œæ—  IOï¼‰
    std::thread([this]{ processEvents(); }).detach();
}

ClientCore::~ClientCore() {
    // é‡Šæ”¾ Executor èµ„æº
    stop();
    if (executor_) {
        executor_->stop();
    }
}

void ClientCore::stop() {
    is_running_ = false;
    cv_.notify_one(); // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ï¼Œä½¿å…¶é€€å‡ºå¾ªç¯
}
// åŸ postInput/pollOutput é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::postInput(core::CoreInput ev) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        inputQueue_.push(std::move(ev));
    }
    cv_.notify_one();
}

// æ–°å¢ï¼šæ·»åŠ ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::addListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.push_back(listener);
}

// æ–°å¢ï¼šç§»é™¤ç›‘å¬è€…ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
void ClientCore::removeListener(core::ICoreListener* listener) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    listeners_.erase(
        std::remove(listeners_.begin(), listeners_.end(), listener),
        listeners_.end()
        );
}

// æ–°å¢ï¼šå¹¿æ’­è¾“å‡ºäº‹ä»¶ç»™æ‰€æœ‰ç›‘å¬è€…ï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼‰
void ClientCore::broadcastOutput(const core::CoreOutput& out) {
    std::lock_guard<std::mutex> lock(listener_mtx_);
    for (auto* listener : listeners_) {
        listener->onCoreOutput(out); // è°ƒç”¨ç›‘å¬è€…çš„å›è°ƒï¼ˆCore çº¿ç¨‹ï¼‰
    }
}


// bool ClientCore::pollOutput(core::CoreOutput& out) { // è¡¥å…… core:: å‰ç¼€
//     std::lock_guard<std::mutex> lock(mtx_);
//     if (outputQueue_.empty()) return false;
//     out = std::move(outputQueue_.front());
//     outputQueue_.pop();
//     return true;
// }

// åŸ processEvents é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::processEvents() {
    while (is_running_) {
        core::CoreInput ev;
        {
            std::unique_lock<std::mutex> lock(mtx_);
            cv_.wait(lock, [this]{ return !inputQueue_.empty(); });
            ev = std::move(inputQueue_.front());
            inputQueue_.pop();
            std::cout << "[ClientCore] Processing Input event, remaining queue size: " << inputQueue_.size()
                      << ", Event type index: " << ev.index() << std::endl;
        }

        auto outputs = fsm_.handle(state_, ev);
        {
            std::lock_guard<std::mutex> lock(mtx_);
            for (auto& o : outputs) {
                handleOutput(std::move(o));
            }
        }
    }
}

// åŸ handleOutput/applyStateChange é€»è¾‘ä¸å˜ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::handleOutput(core::CoreOutput&& o) { // è¡¥å…… core:: å‰ç¼€
    std::visit([this](auto&& e){
        using T = std::decay_t<decltype(e)>;

        if constexpr (std::is_same_v<T, core::OutStateChanged>) { // è¡¥å…… core:: å‰ç¼€
            applyStateChange(e);
            broadcastOutput(e); // Broadcast state change
        }
        else if constexpr (std::is_same_v<T, core::OutConnect>) { // è¡¥å…… core:: å‰ç¼€
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendLogin>) { // è¡¥å…… core:: å‰ç¼€
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutSendPing>) {
            execute(e);
        }
        else if constexpr (std::is_same_v<T, core::OutUpdateAlive>) {
            execute(e);
            broadcastOutput(e);
        }
        else {
            // outputQueue_.push(std::move(e));
            broadcastOutput(e); // å¹¿æ’­å…¶ä»–äº‹ä»¶
        }
    }, std::move(o));
}

void ClientCore::applyStateChange(const core::OutStateChanged& e) { // è¡¥å…… core:: å‰ç¼€
    std::cout << "[Core] State: "
              << stateToString(e.from)
              << " -> "
              << stateToString(e.to)
              << std::endl;

    state_ = e.to;
    //outputQueue_.push(e);
}

// å…³é”®ä¿®æ”¹ï¼šexecute ä»…è°ƒç”¨ Executor æ¥å£ï¼Œæ—  IO é€»è¾‘ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
void ClientCore::execute(const core::OutConnect& e) { // è¡¥å…… core:: å‰ç¼€
    // è°ƒåº¦ Executor æ‰§è¡Œè¿æ¥ï¼ˆCore ä»…å‘å‘½ä»¤ï¼Œä¸åšå…·ä½“æ“ä½œï¼‰
    executor_->connectToServer(e.host, e.port);
}

void ClientCore::execute(const core::OutSendLogin& e) { // è¡¥å…… core:: å‰ç¼€
    // è°ƒåº¦ Executor å‘é€ç™»å½•è¯·æ±‚
    executor_->sendLoginRequest(e.user, e.pass);
}

void ClientCore::execute(const core::OutSendPing&) {
    executor_->sendPing();
}

void ClientCore::execute(const core::OutUpdateAlive&) {
    std::cout << "[Executor] Received PONG from server" << std::endl;
}


// åºŸå¼ƒåŸ socket æ“ä½œæ¥å£ï¼ˆå¯ç›´æ¥åˆ é™¤ï¼‰
// bool ClientCore::connectToServer(const std::string& host, int port) { ... }
// void ClientCore::sendLogin(const std::string& user, const std::string& pass) { ... }

========== ./core/FSM.h ==========
Lines: 36

// core/FSM.h
#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "ClientState.h"
#include <vector>
#include <functional>
#include "ClientEventEnum.h"
#include <variant>
#include <iostream>

struct FSMEntry {
    State current_state;
    EventType event_type;
    // è¡¥å…… core:: å‰ç¼€
    std::function<std::vector<core::CoreOutput>(
        State current,
        const core::CoreInput&
        )> action;
    State next_state;
};

class FSM {
public:
    FSM();

    // è¡¥å…… core:: å‰ç¼€
    std::vector<core::CoreOutput>
    handle(State current, const core::CoreInput& ev);

private:
    EventType eventTypeFromInput(const core::CoreInput& ev);
    bool isOnlineState(State s);
    std::vector<FSMEntry> table_;
    void initTable();
};

========== ./core/CoreInput.h ==========
Lines: 43

// core/CoreInput.h
#pragma once
#include <variant>
#include <string>
#include <vector>
namespace core {

struct OnlineUser {
    std::string name;
    int privilege;
};



// æ‰€æœ‰ Core è¾“å…¥äº‹ä»¶å‰ç¼€æ”¹ä¸º In
struct InCmdConnect { std::string host; int port; };
struct InCmdDisconnect {};
struct InCmdLogin { std::string user; std::string pass; };
struct InTcpConnected {};
struct InTcpDisconnected {};
struct InLoginOk {};
struct InLoginFail { std::string msg; };
struct InOnlineUsers { std::vector<OnlineUser> users; };
struct InUnknow {};
struct InHeartbeatOk {};      // æ”¶åˆ° PONG
struct InHeartbeatTimeout {}; // å¿ƒè·³è¶…æ—¶
struct InHeartbeatTick {};    // Send PING

using CoreInput = std::variant<
    InCmdConnect,
    InCmdDisconnect,
    InCmdLogin,
    InTcpConnected,
    InTcpDisconnected,
    InLoginOk,
    InLoginFail,
    InOnlineUsers,
    InUnknow,
    InHeartbeatOk,
    InHeartbeatTimeout,
    InHeartbeatTick
    >;
}

========== ./core/FSM.cpp ==========
Lines: 184

// core/FSM.cpp
#include "FSM.h"

FSM::FSM() {
    initTable();
}

bool FSM::isOnlineState(State s) {
    return s != State::Disconnected;
}

// è¡¥å…… core:: å‰ç¼€
std::vector<core::CoreOutput>
FSM::handle(State current, const core::CoreInput& ev)
{
    EventType evType = eventTypeFromInput(ev);
    std::cout << "[FSM] Current state: " << stateToString(current)
              << ", Received event type: " << static_cast<int>(evType) << std::endl;
    if (isOnlineState(current) && evType == EventType::HeartbeatTick) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨
        std::cout << "[FSM] Online state, directly handle HeartbeatTick event" << std::endl;
        return { core::OutSendPing{} };
    }

    else if (isOnlineState(current) && evType == EventType::HeartbeatOk) {
        // ç›´æ¥è¿”å›ï¼Œä¸èµ° FSM è¡¨
        return { core::OutUpdateAlive{} };
    }

    for (auto& entry : table_) {
        if (entry.current_state == current &&
            entry.event_type == evType) {

            auto outputs = entry.action(current, ev);
            return outputs;
        }
    }
    return {};
}

EventType FSM::eventTypeFromInput(const core::CoreInput& ev) {
    EventType evType = EventType::Unknow;
    std::visit([&evType](auto&& e){
        using T = std::decay_t<decltype(e)>;
        // å…¨éƒ¨æ›¿æ¢ä¸º InXXX å‰ç¼€
        if constexpr (std::is_same_v<T, core::InCmdConnect>)      evType = EventType::CmdConnect;
        else if constexpr (std::is_same_v<T, core::InCmdDisconnect>) evType = EventType::CmdDisconnect;
        else if constexpr (std::is_same_v<T, core::InCmdLogin>)   evType = EventType::CmdLogin;

        else if constexpr (std::is_same_v<T, core::InTcpConnected>)    evType = EventType::TcpConnected;
        else if constexpr (std::is_same_v<T, core::InTcpDisconnected>) evType = EventType::TcpDisconnected;

        else if constexpr (std::is_same_v<T, core::InLoginOk>)   evType = EventType::LoginOk;
        else if constexpr (std::is_same_v<T, core::InLoginFail>) evType = EventType::LoginFail;
        else if constexpr (std::is_same_v<T, core::InOnlineUsers>) evType = EventType::OnlineUsers;

        else if constexpr (std::is_same_v<T, core::InHeartbeatOk>)
            evType = EventType::HeartbeatOk;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTimeout>)
            evType = EventType::HeartbeatTimeout;

        else if constexpr (std::is_same_v<T, core::InHeartbeatTick>)
            evType = EventType::HeartbeatTick;

        else evType = EventType::Unknow;
    }, ev);
    return evType;
}

void FSM::initTable() {
    table_ = {
          // ===== æ–­å¼€æ€ =====
          { State::Disconnected, EventType::CmdConnect,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InCmdConnect
                  if (auto e = std::get_if<core::InCmdConnect>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::Connecting}); // è¡¥å…… core::
                      out.push_back(core::OutConnect{e->host, e->port}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connecting
          },

          // ===== æ­£åœ¨è¿æ¥ =====
          { State::Connecting, EventType::TcpConnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InTcpConnected
                  if (auto e = std::get_if<core::InTcpConnected>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::Connected}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connected
          },

          { State::Connecting, EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){ return std::vector<core::CoreOutput>{}; },
              State::Disconnected
          },

          // ===== å·²è¿æ¥ =====
          { State::Connected, EventType::CmdLogin,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InCmdLogin
                  if (auto e = std::get_if<core::InCmdLogin>(&ev)) {
                      out.push_back(core::OutStateChanged{cur, State::LoggingIn}); // è¡¥å…… core::
                      out.push_back(core::OutSendLogin{e->user, e->pass}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::LoggingIn
          },

          // ===== æ­£åœ¨ç™»å½• =====
          { State::LoggingIn, EventType::LoginOk ,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InLoginOk
                  if (auto e = std::get_if<core::InLoginOk>(&ev)) {
                      out.push_back(core::OutLoginOk{}); // è¡¥å…… core::
                      out.push_back(core::OutStateChanged{cur, State::LoggedIn}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::LoggedIn
          },

          { State::LoggingIn, EventType::LoginFail ,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput& ev) -> std::vector<core::CoreOutput> {
                  std::vector<core::CoreOutput> out;
                  // æ›¿æ¢ä¸º InLoginFail
                  if (auto e = std::get_if<core::InLoginFail>(&ev)) {
                      out.push_back(core::OutLoginFail{e->msg}); // è¡¥å…… core::
                      out.push_back(core::OutStateChanged{cur, State::Connected}); // è¡¥å…… core::
                  }
                  return out;
              },
              State::Connected
          },

          // ===== ä»»ä½•åœ¨çº¿çŠ¶æ€æ–­çº¿ =====
          { State::Connected,  EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },
          { State::LoggingIn,  EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },
          { State::LoggedIn,   EventType::TcpDisconnected,
              // è¡¥å…… core:: å‰ç¼€
              [](State cur, const core::CoreInput&){
                  return std::vector<core::CoreOutput>{
                      core::OutStateChanged{cur, State::Disconnected}, // è¡¥å…… core::
                      core::OutDisconnected{} // è¡¥å…… core::
                  };
              },
              State::Disconnected
          },
    };
}

========== ./core/ClientCore.h ==========
Lines: 53

#pragma once
#include "CoreInput.h"
#include "CoreOutput.h"
#include "FSM.h"
#include "ClientState.h"
#include "CoreExecutor.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <memory>
#include "ICoreListener.h"
#include <vector>

class ClientCore {
public:
    ClientCore();
    ~ClientCore();

    // çº¿ç¨‹å®‰å…¨æ¥å£ï¼ˆå¯¹å¤–æš´éœ²ï¼‰
    void postInput(core::CoreInput ev);
    // bool pollOutput(core::CoreOutput& out); // è¡¥å…… core:: å‰ç¼€
    void stop();
    // ç›‘å¬è€…ç®¡ç†ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
    void addListener(core::ICoreListener* listener);   // æ–°å¢
    void removeListener(core::ICoreListener* listener);// æ–°å¢

private:
    FSM fsm_;
    State state_ = State::Disconnected;
    std::unique_ptr<CoreExecutor> executor_;

    // çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ï¼ˆè¡¥å…… core:: å‰ç¼€ï¼‰
    std::queue<core::CoreInput>  inputQueue_;
    std::queue<core::CoreOutput> outputQueue_; // è¡¥å…… core:: å‰ç¼€
    std::mutex mtx_;
    std::condition_variable cv_;

    // ç›‘å¬è€…ç®¡ç†ï¼ˆæ–°å¢ï¼‰
    std::vector<core::ICoreListener*> listeners_;
    std::mutex listener_mtx_;  // ç›‘å¬è€…æ“ä½œçš„çº¿ç¨‹å®‰å…¨é”

    // æ ¸å¿ƒæ–¹æ³•ï¼ˆå‚æ•°è¡¥å…… core:: å‰ç¼€ï¼‰
    void processEvents();
    void applyStateChange(const core::OutStateChanged& e); // è¡¥å…… core:: å‰ç¼€
    void handleOutput(core::CoreOutput&& o); // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutConnect& e) ; // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutSendLogin& e) ; // è¡¥å…… core:: å‰ç¼€
    void execute(const core::OutSendPing& e);
    void execute(const core::OutUpdateAlive&);
    void broadcastOutput(const core::CoreOutput& out);
    std::atomic<bool> is_running_{true};
};

========== ./core/CoreExecutor.cpp ==========
Lines: 110

//CoreExecutor.cpp
#include "CoreExecutor.h"
#include "ClientEventFactory.h"
#include <thread>
#include <iostream>

CoreExecutor::CoreExecutor(InputCallback cb)
    : postInput_(std::move(cb)) {
    initSocketCallbacks();
    heartbeatThread_ = std::thread(&CoreExecutor::heartbeatLoop, this);
}

CoreExecutor::~CoreExecutor() {
    stop();
}

void CoreExecutor::initSocketCallbacks() {
    // 1. è¿æ¥æˆåŠŸå›è°ƒï¼šæ¨é€ InTcpConnected åˆ° Core
    socket_.setConnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpConnected{}); // æ›¿æ¢ä¸º InTcpConnected
            std::cout << "[Executor] Socket connected, push InTcpConnected to Core" << std::endl;
        }
    });

    // 2. æ–­å¼€è¿æ¥å›è°ƒï¼šæ¨é€ InTcpDisconnected åˆ° Core
    socket_.setDisconnectCallback([this]() {
        if (isRunning_) {
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Socket disconnected, push InTcpDisconnected to Core" << std::endl;
        }
    });

    // 3. æ¶ˆæ¯æ¥æ”¶å›è°ƒï¼šè§£ææ¶ˆæ¯å¹¶æ¨é€å¯¹åº” CoreInput åˆ° Core
    socket_.setMessageCallback([this](const std::string& msg) {
        if (!isRunning_) return;

        ClientEvent event = ClientEventFactory::makeEvent(msg);
        std::visit([this](auto&& e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, ProtoEvtLoginOk>) {
                postInput_(core::InLoginOk{});
            } else if constexpr (std::is_same_v<T, ProtoEvtLoginFail>) {
                postInput_(core::InLoginFail{e.resp.message});
            } else if constexpr (std::is_same_v<T, ProtoEvtOnlineUsers>) {
                core::InOnlineUsers in;

                for (const auto& u : e.users) {
                    in.users.push_back(core::OnlineUser{
                        .name = u.username,
                        .privilege = u.privilege
                    });
                }

                postInput_(std::move(in));
            }
            else if constexpr (std::is_same_v<T, ProtoEvHeartbeatAck>) {
                postInput_(core::InHeartbeatOk{});
            }
            else {
                postInput_(core::InUnknow{});
            }
        }, event);
    });
}

void CoreExecutor::connectToServer(const std::string& host, int port) {
    // å¼‚æ­¥æ‰§è¡Œè¿æ¥
    std::thread([this, host, port]() {
        if (!socket_.connectToServer(host, port)) {
            // è¿æ¥å¤±è´¥ï¼šæ¨é€ InTcpDisconnected
            postInput_(core::InTcpDisconnected{}); // æ›¿æ¢ä¸º InTcpDisconnected
            std::cout << "[Executor] Connect to " << host << ":" << port << " failed" << std::endl;
        }
        else {
            std::cout << "[Executor] Successfully connected to server: " << host << ":" << port << std::endl;
        }
    }).detach();
}

void CoreExecutor::sendLoginRequest(const std::string& user, const std::string& pass) {
    std::string loginMsg = proto::makeLoginRequest(user, pass);
    socket_.sendMessage(loginMsg);
    std::cout << "[Executor] Send login request for user: " << user << std::endl;
}

void CoreExecutor::heartbeatLoop() {
    while (isRunning_) {
        std::this_thread::sleep_for(std::chrono::seconds(5));

        if (!isRunning_) break;

        // æ¨é€ HeartbeatTick ç»™ Core
        postInput_(core::InHeartbeatTick{});
        std::cout << "[Executor] push InHeartbeatTick" << std::endl;
    }
}


void CoreExecutor::sendPing() {
    std::string ping = proto::makeHeartbeat();
    socket_.sendMessage(ping);
    std::cout << "[Executor] Send PING" << std::endl;
}


void CoreExecutor::stop() {
    isRunning_ = false;
    socket_.stop();
}

========== ./core/ClientState.h ==========
Lines: 24

// ClientState.h
#pragma once

#include <string>

enum class State {
    Disconnected,
    Connecting,
    Connected,
    LoggingIn,
    LoggedIn
};

// å°† State è½¬æ¢ä¸ºå­—ç¬¦ä¸²
inline std::string stateToString(State s) {
    switch (s) {
    case State::Disconnected: return "Disconnected";
    case State::Connecting:   return "Connecting";
    case State::Connected:    return "Connected";
    case State::LoggingIn:    return "LoggingIn";
    case State::LoggedIn:     return "LoggedIn";
    default:                  return "Unknown";
    }
}

========== ./core/CoreExecutor.h ==========
Lines: 39

//CoreExecutor.h
#pragma once
#include "CoreInput.h"
#include "CommandSocket.h"
#include "protocol_text.h"
#include "ClientEventFactory.h"
#include <functional>
#include <memory>

// å®šä¹‰å›è°ƒç±»å‹ï¼šExecutor æ‰§è¡Œ IO åï¼Œé€šè¿‡è¯¥å›è°ƒå‘ ClientCore æ¨é€ CoreInput
using InputCallback = std::function<void(core::CoreInput)>;

class CoreExecutor {
public:
    // æ„é€ å‡½æ•°ï¼šæ¥æ”¶å›è°ƒå‡½æ•°ï¼ˆç”¨äºå‘ Core æ¨é€è¾“å…¥äº‹ä»¶ï¼‰
    explicit CoreExecutor(InputCallback cb);
    ~CoreExecutor();

    // å¯¹å¤–æš´éœ²çš„ IO æ“ä½œæ¥å£ï¼ˆè¯­ä¹‰åŒ–å‘½åï¼‰
    void connectToServer(const std::string& host, int port);
    void sendLoginRequest(const std::string& user, const std::string& pass);
    void sendPing();
    void stop(); // èµ„æºé‡Šæ”¾æ¥å£

private:
    // å°è£…çš„ socket å®ä¾‹ï¼ˆExecutor å”¯ä¸€æŒæœ‰ï¼‰
    CommandSocket socket_;
    // å‘ Core æ¨é€äº‹ä»¶çš„å›è°ƒ
    InputCallback postInput_;
    // çº¿ç¨‹å®‰å…¨æ ‡è®°
    std::atomic<bool> isRunning_{true};

    // åˆå§‹åŒ– socket å›è°ƒï¼ˆå†…éƒ¨ç§æœ‰ï¼‰
    void initSocketCallbacks();

    std::thread heartbeatThread_;
    void heartbeatLoop();   // æ–°å¢

};

========== ./core/ICoreListener.h ==========
Lines: 15

// core/ICoreListener.h
#pragma once
#include "CoreOutput.h"

namespace core {

class ICoreListener {
public:
    virtual ~ICoreListener() = default;

    // Core è¾“å‡ºäº‹ä»¶çš„ç»Ÿä¸€å›è°ƒï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼‰
    virtual void onCoreOutput(const CoreOutput& out) = 0;
};

} // namespace core

========== ./core/CoreOutput.h ==========
Lines: 32

// core/CoreOutput.h
#pragma once
#include <variant>
#include "ClientState.h"

// è¾“å‡ºå±‚äº‹ä»¶å…¨éƒ¨çº³å…¥ core å‘½åç©ºé—´
namespace core {

struct OutStateChanged {
    State from;
    State to;
};
struct OutLoginOk {};
struct OutLoginFail { std::string msg; };
struct OutDisconnected {};
struct OutConnect { std::string host; int port; };
struct OutSendLogin { std::string user; std::string pass; };
struct OutSendPing {};   // Core -> Executorï¼šå‘é€å¿ƒè·³
struct OutUpdateAlive {};

using CoreOutput = std::variant<
    OutStateChanged,
    OutLoginOk,
    OutLoginFail,
    OutDisconnected,
    OutConnect,
    OutSendLogin,
    OutSendPing,
    OutUpdateAlive
    >;

} // namespace core

========== ./net/PacketCodec.h ==========
Lines: 39

//PacketCodec.h
#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 48

//CommandSocket.h
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <vector>
#include "PacketCodec.h"

class CommandSocket {
public:
    using MessageCallback = std::function<void(const std::string&)>;
    using ConnectCallback = std::function<void()>;
    using DisconnectCallback = std::function<void()>;

    CommandSocket();
    ~CommandSocket();

    void setConnectCallback(ConnectCallback cb);
    void setDisconnectCallback(DisconnectCallback cb);
    // TCP å®¢æˆ·ç«¯
    bool connectToServer(const std::string& host, int port);

    // TCP æœåŠ¡å™¨
    bool startServer(int port);

    void setMessageCallback(MessageCallback cb);

    // å‘é€æ•°æ®
    void sendMessage(const std::string& msg);

    // åœæ­¢
    void stop();

private:
    void clientThreadFunc();
    void serverThreadFunc();
    void sendPacket(int fd, const std::string& payload);
    int sockfd_ = -1;
    int clientfd_ = -1;  // å¯¹äºæœåŠ¡å™¨ç«¯ä¿å­˜å®¢æˆ·ç«¯è¿æ¥
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    MessageCallback callback_;

    ConnectCallback onConnect_;
    DisconnectCallback onDisconnect_;

};

========== ./net/CommandSocket.cpp ==========
Lines: 141

//CommandSocket.cpp
#include "CommandSocket.h"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

CommandSocket::CommandSocket() {}

CommandSocket::~CommandSocket() {
    stop();
}

void CommandSocket::setMessageCallback(MessageCallback cb) {
    callback_ = std::move(cb);
}

void CommandSocket::setConnectCallback(ConnectCallback cb) {
    onConnect_ = std::move(cb);
}

void CommandSocket::setDisconnectCallback(DisconnectCallback cb) {
    onDisconnect_ = std::move(cb);
}


void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


bool CommandSocket::connectToServer(const std::string& host, int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &serv_addr.sin_addr);

    if (connect(sockfd_, (sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        close(sockfd_);
        sockfd_ = -1;
        return false;
    }

    if (onConnect_) onConnect_();   // â­ TCPçœŸæ­£å»ºç«‹
    // std::thread([this]{
    //     if (onConnect_) onConnect_();
    // }).detach();

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::clientThreadFunc, this);
    return true;
}

bool CommandSocket::startServer(int port) {
    sockfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(sockfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(sockfd_, 1) < 0) return false;

    running_ = true;
    workerThread_ = std::thread(&CommandSocket::serverThreadFunc, this);
    return true;
}

void CommandSocket::sendMessage(const std::string& msg) {
    int fd = (clientfd_ >= 0) ? clientfd_ : sockfd_;
    sendPacket(fd,msg);
}

void CommandSocket::stop() {
    running_ = false;
    if (workerThread_.joinable())
        workerThread_.join();
    if (sockfd_ >= 0) close(sockfd_);
    if (clientfd_ >= 0) close(clientfd_);
    sockfd_ = -1;
    clientfd_ = -1;
}

void CommandSocket::clientThreadFunc() {
    std::vector<char> recvBuffer;
    char temp[1024];

    while (running_) {
        int n = recv(sockfd_, temp, sizeof(temp), 0);
        if (n > 0) {

            // 1ï¸âƒ£ æŠŠæ”¶åˆ°çš„å­—èŠ‚å¡è¿›ç¼“å­˜
            std::cout << "[CommandSocket] Received data, length: " << n << " bytes" << std::endl;
            recvBuffer.insert(recvBuffer.end(), temp, temp + n);

            // 2ï¸âƒ£ å°è¯•ä»ç¼“å­˜ä¸­æ‹†å®Œæ•´åŒ…
            std::string payload;
            while (PacketCodec::tryDecode(recvBuffer, payload)) {

                // 3ï¸âƒ£ æ¯ä¸€ä¸ª payload = ä¸€æ¡å®Œæ•´â€œåº”ç”¨å±‚æ¶ˆæ¯â€
                if (callback_) {
                    callback_(payload);
                }
            }

        } else if (n <= 0) {
            std::cout << "[CommandSocket] Server disconnected (recv return <=0)" << std::endl;
            if (onDisconnect_) onDisconnect_();  // â­ TCPæ–­çº¿
            break; // æœåŠ¡å™¨æ­£å¸¸æ–­å¼€
        }
    }
}

void CommandSocket::serverThreadFunc() {
    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    clientfd_ = accept(sockfd_, (sockaddr*)&client_addr, &client_len);
    if (clientfd_ < 0) return;

    char buffer[1024];
    while (running_) {
        int n = recv(clientfd_, buffer, sizeof(buffer) - 1, 0);
        if (n > 0) {
            buffer[n] = '\0';
            if (callback_) callback_(std::string(buffer));
        } else if (n == 0) {
            break; // å®¢æˆ·ç«¯æ–­å¼€
        }
    }
}

========== ./ui/VideoWidget.cpp ==========
Lines: 35

//VideoWidget.cpp
#include "VideoWidget.h"
#include <QPainter>
#include <QDebug>
VideoWidget::VideoWidget(QWidget *parent)
    : QWidget(parent) {
    setMinimumSize(640, 480);
}

void VideoWidget::setFrame(const QImage &img) {
    frame_ = img;
    update();
}

void VideoWidget::paintEvent(QPaintEvent *) {
    QPainter p(this);
    p.fillRect(rect(), Qt::black);

    if (frame_.isNull())
        return;

    QSize imgSize = frame_.size();
    imgSize.scale(size(), Qt::KeepAspectRatio);

    QRect targetRect(
        (width()  - imgSize.width())  / 2,
        (height() - imgSize.height()) / 2,
        imgSize.width(),
        imgSize.height()
        );
    //qDebug() << "widget size:" << size();

    p.drawImage(targetRect, frame_);
}


========== ./ui/widget.cpp ==========
Lines: 72

// ui/widget.cppï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#include "widget.h"
#include "./ui_widget.h"
#include <QDebug>
#include "ClientCore.h" // åŒ…å«Coreå¤´æ–‡ä»¶
#include "ClientState.h" // åŒ…å«çŠ¶æ€è½¬æ¢å‡½æ•°

Widget::Widget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
    , core_(core)  // åˆå§‹åŒ–CoreæŒ‡é’ˆ
{
    ui->setupUi(this);
    video_ = new VideoWidget(ui->videoContainer);
    adapter_ = new QtCameraAdapter(video_, this);

    // å…³é”®ä¿®å¤ï¼šç»‘å®šæ‘„åƒå¤´å›è°ƒåˆ°Qtç•Œé¢
    camera_.setFrameCallback([this](const Frame& f) {
        // è·¨çº¿ç¨‹å®‰å…¨è°ƒç”¨ï¼ˆCameraManageråœ¨å­çº¿ç¨‹ï¼ŒUIåœ¨ä¸»çº¿ç¨‹ï¼‰
        QMetaObject::invokeMethod(adapter_, "onFrame", Qt::QueuedConnection, Q_ARG(Frame, f));
    });

    // å…³é”®ä¿®å¤ï¼šç»‘å®šCoreäº‹ä»¶çš„è·¨çº¿ç¨‹å¤„ç†
    connect(this, &Widget::coreOutputReceived,
            this, &Widget::handleCoreOutput,
            Qt::QueuedConnection);
}

Widget::~Widget()
{
    // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„ç§»é™¤ç›‘å¬è€…æ–¹æ³•
    if (core_) {
        core_->removeListener(this);
    }
    delete ui;
}

// å®ç°ICoreListeneræ¥å£ï¼šæ¥æ”¶Coreè¾“å‡ºäº‹ä»¶
void Widget::onCoreOutput(const core::CoreOutput& out)
{
    qDebug() << "Main UI received core output, type index:" << out.index();
    // è½¬å‘ä¸ºQtä¿¡å·ï¼ˆç¡®ä¿UIçº¿ç¨‹å¤„ç†ï¼‰
    emit coreOutputReceived(out);
}

// å®ç°æ§½å‡½æ•°ï¼šå¤„ç†Coreè¾“å‡ºäº‹ä»¶ï¼ˆUIçº¿ç¨‹ï¼‰
void Widget::handleCoreOutput(const core::CoreOutput& out)
{
    // å¯æ ¹æ®éœ€è¦æ‰©å±•å¤„ç†é€»è¾‘ï¼Œç›®å‰æ‰“å°æ—¥å¿—
    std::visit([](auto&& e) {
        using T = std::decay_t<decltype(e)>;
        if constexpr (std::is_same_v<T, core::OutStateChanged>) {
            qDebug() << "Main UI state change:" << QString::fromStdString(stateToString(e.from))
                     << "â†’" << QString::fromStdString(stateToString(e.to));
        }
    }, out);
}

void Widget::on_Bt_video_on_off_clicked()
{
    qDebug("Button clicked!");
    camera_.start("/dev/video0");
}

void Widget::on_Bt_video_off_clicked()
{
    qDebug("Button clicked!");
    camera_.stop();
}

void Widget::on_Bt_tcp_send_clicked() {}
void Widget::on_Bt_tcp_connect_clicked() {}

========== ./ui/QtCameraAdapter.cpp ==========
Lines: 18

//QtCameraAdapter.cpp
#include "QtCameraAdapter.h"
#include <QImage>

QtCameraAdapter::QtCameraAdapter(VideoWidget* view, QObject* parent)
    : QObject(parent), view_(view) {}

void QtCameraAdapter::onFrame(Frame f) {
    QImage img(
        f.data.data(),
        f.width,
        f.height,
        f.stride,
        QImage::Format_RGB888
        );

    view_->setFrame(img.copy());
}

========== ./ui/LoginWidget.h ==========
Lines: 54

//LoginWidget.h
#ifndef LOGINWIDGET_H
#define LOGINWIDGET_H

#include <QWidget>

#include "core/ICoreListener.h"  // å®ç°æŠ½è±¡æ¥å£
#include "core/CoreOutput.h"     // Core è¾“å‡ºäº‹ä»¶

class ClientCore;

namespace Ui {
class LoginWidget;
}

class LoginWidget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit LoginWidget(ClientCore* core, QWidget* parent = nullptr);
    ~LoginWidget() override;

    void onCoreOutput(const core::CoreOutput& out) override;

signals:
    void loginSuccess();
    void coreOutputReceived(const core::CoreOutput& out);

private slots:
    void on_Bt_Jump_Test_clicked();
    void on_Bt_ConnectToServer_clicked();
    void on_Bt_tcp_test_send_clicked();
    void on_Bt_Login_clicked();
    void handleCoreOutput(const core::CoreOutput& out);

private:
    Ui::LoginWidget *ui;
    ClientCore* core_;
    // æ–°å¢ï¼šUI çº¿ç¨‹å¤„ç† Core äº‹ä»¶
    // æ‰€æœ‰å‚æ•°è¡¥å…… core:: å‰ç¼€
    void handle(const core::OutLoginFail&);
    void handle(const core::OutDisconnected&) ;
    void handle(const core::OutLoginOk&) ;
    void handle(const core::OutStateChanged& e) ;
    void handle(const core::OutConnect&);       // æ–°å¢
    void handle(const core::OutSendLogin&);     // æ–°å¢

    void handle(const core::OutSendPing&);

    void handle(const core::OutUpdateAlive&);
};

#endif // LOGINWIDGET_H

========== ./ui/AppWindow.cpp ==========
Lines: 38

// ui/AppWindow.cpp
#include "AppWindow.h"
#include "LoginWidget.h"
#include "widget.h"
#include "core/ClientCore.h"  // åŒ…å« Core å¤´æ–‡ä»¶
#include <QVBoxLayout>

AppWindow::AppWindow(QWidget *parent)
    : QWidget(parent)
{
    resize(900, 600);
    stack = new QStackedWidget(this);

    // æ ¸å¿ƒï¼šåˆ›å»ºå”¯ä¸€çš„ ClientCore å®ä¾‹ï¼ˆçº¯ C++ï¼Œæ—  Qt ä¾èµ–ï¼‰
    core_ = std::make_unique<ClientCore>();

    // ä¼ é€’ Core æŒ‡é’ˆç»™å­çª—å£
    loginPage = new LoginWidget(core_.get(), this);
    mainPage  = new Widget(core_.get(), this);

    stack->addWidget(loginPage); // index 0
    stack->addWidget(mainPage);  // index 1

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(stack);
    setLayout(layout);

    // ç™»å½•æˆåŠŸ â†’ åˆ‡æ¢é¡µé¢
    connect(loginPage, &LoginWidget::loginSuccess, this, [=](){
        stack->setCurrentIndex(PAGE_MAIN);
    });

    // åˆå§‹é¡µé¢
    stack->setCurrentIndex(PAGE_LOGIN);
}

// ææ„ï¼šæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ Core
AppWindow::~AppWindow() = default;

========== ./ui/VideoWidget.h ==========
Lines: 17

//VideoWidget.h
#pragma once
#include <QWidget>
#include <QImage>

class VideoWidget : public QWidget {
    Q_OBJECT
public:
    explicit VideoWidget(QWidget *parent = nullptr);
    void setFrame(const QImage &img);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    QImage frame_;
};

========== ./ui/QtCameraAdapter.h ==========
Lines: 17

//QtCameraAdapter.h
#pragma once
#include <QObject>
#include "Frame.h"
#include "VideoWidget.h"

class QtCameraAdapter : public QObject {
    Q_OBJECT
public:
    explicit QtCameraAdapter(VideoWidget* view, QObject* parent = nullptr);

public slots:
    void onFrame(Frame frame);

private:
    VideoWidget* view_;
};

========== ./ui/LoginWidget.cpp ==========
Lines: 123

//LoginWidget.cpp
#include "LoginWidget.h"
#include "./ui_LoginWidget.h"
#include <QMessageBox>
#include <QMetaObject>
#include <QDebug>
#include "ClientCore.h"



LoginWidget::LoginWidget(ClientCore* core, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::LoginWidget)
    , core_(core)  // æ¥æ”¶ AppWindow ä¼ å…¥çš„ Core å®ä¾‹
{
    ui->setupUi(this);

    // æ³¨å†Œä¸º Core çš„ç›‘å¬è€…
    core_->addListener(this);

    // å…³é”®ï¼šè·¨çº¿ç¨‹ä¿¡å·æ§½ï¼ˆå¼ºåˆ¶ QueuedConnectionï¼Œç¡®ä¿ UI çº¿ç¨‹æ‰§è¡Œï¼‰
    connect(this, &LoginWidget::coreOutputReceived,
            this, &LoginWidget::handleCoreOutput,
            Qt::QueuedConnection);

    // ç§»é™¤ï¼šåˆ é™¤ QTimer è½®è¯¢é€»è¾‘
    // QTimer* timer = new QTimer(this);
    // connect(timer, &QTimer::timeout, this, [this]{ ... });
    // timer->start(10);
}

LoginWidget::~LoginWidget() {
    // ææ„æ—¶ç§»é™¤ç›‘å¬è€…ï¼ˆé¿å…é‡æŒ‡é’ˆï¼‰
    if (core_) {
        core_->removeListener(this);
    }
    delete ui;
}


// å®ç° ICoreListener æ¥å£ï¼ˆCore çº¿ç¨‹è°ƒç”¨ï¼Œç»ä¸æ“ä½œ UIï¼‰
void LoginWidget::onCoreOutput(const core::CoreOutput& out) {
    // ä»…è½¬å‘ä¸º Qt ä¿¡å·ï¼Œäº¤ç»™ UI çº¿ç¨‹å¤„ç†
    emit coreOutputReceived(out);
}

// UI çº¿ç¨‹å¤„ç† Core äº‹ä»¶ï¼ˆå®‰å…¨æ“ä½œ UIï¼‰
void LoginWidget::handleCoreOutput(const core::CoreOutput& out) {
    std::visit([this](auto&& e) {
        handle(e);
    }, out);
}

void LoginWidget::on_Bt_Jump_Test_clicked()
{
    emit loginSuccess();
}

void LoginWidget::on_Bt_ConnectToServer_clicked()
{
    //qDebug() << "current thread:" << QThread::currentThread();
    //qDebug() << "ui thread:" << qApp->thread();

    ui->TextEdit_tcp_test_recv->setPlainText("Connecting\n");
    // æ›¿æ¢ä¸º InCmdConnect
    core_->postInput(core::InCmdConnect{"127.0.0.1",6001});
}

void LoginWidget::on_Bt_tcp_test_send_clicked()
{
    QString qmsg = ui->LE_tcp_send_test->text();
    std::string msg = qmsg.toStdString();
}

// æ‰€æœ‰ handle å‡½æ•°å‚æ•°è¡¥å…… core:: å‰ç¼€
void LoginWidget::handle(const core::OutLoginFail&) {
    std::cout << "[UI] handle OutLoginFail: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login failed");
}

void LoginWidget::handle(const core::OutDisconnected&) {
    std::cout << "[UI] handle OutDisconnected: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("OutDisconnected");
}

void LoginWidget::handle(const core::OutLoginOk&) {
    std::cout << "[UI] handle OutLoginOk: " << std::endl;
    ui->TextEdit_tcp_test_recv->setPlainText("Login success");
    emit loginSuccess();
}

void LoginWidget::handle(const core::OutStateChanged& e) {
    std::cout << "[UI] handle OutStateChanged: " << stateToString(e.from) << " to " << stateToString(e.to) << std::endl;
    ui->TextEdit_FSM_State->setPlainText(QString::fromStdString(stateToString(e.to)));
}

void LoginWidget::handle(const core::OutConnect&) {
    std::cout << "[UI] Ignore OutConnect (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutSendLogin&) {
    std::cout << "[UI] Ignore OutSendLogin (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutSendPing&) {
    std::cout << "[UI] Ignore OutSendPing (CoreExecutor handles it)" << std::endl;
}

void LoginWidget::handle(const core::OutUpdateAlive&) {
    std::cout << "[UI] Ignore OutUpdateAlive" << std::endl;
}

void LoginWidget::on_Bt_Login_clicked()
{
    QString qstr_user_name = ui->LE_UserName->text();
    std::string msg_user_name = qstr_user_name.toStdString();

    QString qstr_user_pass = ui->LE_UserPass->text();
    std::string msg_user_pass = qstr_user_pass.toStdString();

    // æ›¿æ¢ä¸º InCmdLogin
    core_->postInput(core::InCmdLogin{msg_user_name, msg_user_pass});
}

========== ./ui/AppWindow.h ==========
Lines: 30

//AppWindow.h
#pragma once
#include <QWidget>
#include <QStackedWidget>
#include "memory"
#include "LoginWidget.h"
#include "widget.h"
#include "memory"

class ClientCore;

class AppWindow : public QWidget
{
    Q_OBJECT
public:
    explicit AppWindow(QWidget *parent = nullptr);
    ~AppWindow() override;
private:
    QStackedWidget *stack;
    LoginWidget *loginPage;
    Widget *mainPage;

    // æ ¸å¿ƒï¼šAppWindow å”¯ä¸€æŒæœ‰ ClientCore å®ä¾‹
    std::unique_ptr<ClientCore> core_;

    enum PageIndex {
        PAGE_LOGIN = 0,
        PAGE_MAIN
    };
};

========== ./ui/widget.h ==========
Lines: 48

// ui/widget.hï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "QtCameraAdapter.h"
#include "CameraManager.h"
#include "core/ICoreListener.h"
#include "core/CoreOutput.h"

// å‰ç½®å£°æ˜ï¼ˆå‡å°‘è€¦åˆï¼‰
class ClientCore;

QT_BEGIN_NAMESPACE
namespace Ui {
class Widget;
}
QT_END_NAMESPACE

class Widget : public QWidget, public core::ICoreListener
{
    Q_OBJECT

public:
    explicit Widget(ClientCore* core, QWidget *parent = nullptr);
    ~Widget() override;

    // ä»…å®ç°ICoreListenerè¦æ±‚çš„çº¯è™šå‡½æ•°
    void onCoreOutput(const core::CoreOutput& out) override;

signals:
    void coreOutputReceived(const core::CoreOutput& out);

private slots:
    void on_Bt_video_on_off_clicked();
    void on_Bt_video_off_clicked();
    void on_Bt_tcp_send_clicked();
    void on_Bt_tcp_connect_clicked();
    void handleCoreOutput(const core::CoreOutput& out); // æ§½å‡½æ•°å£°æ˜

private:
    Ui::Widget *ui;
    ClientCore* core_; // æ–°å¢ï¼šCoreæŒ‡é’ˆæˆå‘˜
    VideoWidget *video_;
    CameraManager camera_;
    QtCameraAdapter* adapter_;
};
#endif // WIDGET_H

========== ./protocol/protocol_types.h ==========
Lines: 27

//protocol_types.h
#pragma once
#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct Unknown {
    std::string message;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

}

========== ./protocol/protocol_text.h ==========
Lines: 20

//protocol_text.h
#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);
std::string makeHeartbeat();
// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);
bool parseHeartbeatAck(const std::string& msg);

}

========== ./protocol/protocol_text.cpp ==========
Lines: 139

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    oss ;
    return oss.str();
}

std::string makeHeartbeat() {
    return CMD_HEARTBEAT;
}

/* ================= parse ================= */

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}


bool parseHeartbeatAck(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_HEARTBEAT_ACK;   // "PONG"
}


} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 22

//protocol_common.h
#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN         = "LOGIN";
constexpr const char* CMD_LOGIN_OK      = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL    = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS  = "ONLINE_USERS";
constexpr const char* CMD_HEARTBEAT     = "PING";
constexpr const char* CMD_HEARTBEAT_ACK = "PONG";

// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}

========== ./app/ClientEvent.h ==========
Lines: 42

//ClientEvent.h
#pragma once

#include <string>
#include "protocol_types.h"
#include <variant>

// åè®®å±‚äº‹ä»¶ç»Ÿä¸€å‰ç¼€ï¼šProtoEvt
struct ProtoEvtTcpConnected {};
struct ProtoEvtTcpDisconnected {};
struct ProtoEvtLoginOk    { proto::LoginResponse resp; };
struct ProtoEvtLoginFail { proto::LoginResponse resp; };
struct ProtoEvtOnlineUsers { proto::OnlineUsers users; };
struct ProtoEvtUnknow { proto::Unknown error_msg; };
struct ProtoEvtCmdConnect {
    std::string host;
    int port;
};
struct ProtoEvtCmdDisconnect {};
struct ProtoEvtCmdLogin {
    std::string user;
    std::string pass;
};
struct ProtoEvHeartbeatAck{};

using ClientEvent = std::variant<
    // UI è§¦å‘çš„åè®®å‘½ä»¤
    ProtoEvtCmdConnect,
    ProtoEvtCmdDisconnect,
    ProtoEvtCmdLogin,

    // TCP åº•å±‚äº‹ä»¶
    ProtoEvtTcpConnected,
    ProtoEvtTcpDisconnected,

    // åè®®è§£æåçš„ä¸šåŠ¡äº‹ä»¶
    ProtoEvtLoginOk,
    ProtoEvtLoginFail,
    ProtoEvtOnlineUsers,
    ProtoEvtUnknow,
    ProtoEvHeartbeatAck
    >;

========== ./app/ClientEventFactory.h ==========
Lines: 18

//ClientEventFactory.h
#ifndef CLIENTEVENTFACTORY_H
#define CLIENTEVENTFACTORY_H

#include "protocol_types.h"
#include "ClientEvent.h"
class ClientEventFactory
{
public:
    ClientEventFactory();
    static ClientEvent makeEvent(const std::string& msg);

private:


};

#endif // CLIENTEVENTFACTORY_H

========== ./app/ClientEventFactory.cpp ==========
Lines: 31

//ClientEventFactory.cpp
#include "ClientEventFactory.h"

// åªåœ¨ cpp ä¸­ include è§£æå‡½æ•°
#include "protocol_text.h"

ClientEventFactory::ClientEventFactory() {}

ClientEvent ClientEventFactory::makeEvent(const std::string& msg)
{
    proto::LoginResponse login;
    if (proto::parseLoginResponse(msg, login)) {
        if (login.success)
            return ProtoEvtLoginOk{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
        else
            return ProtoEvtLoginFail{login}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    proto::OnlineUsers users;
    if (proto::parseOnlineUsers(msg, users)) {
        return ProtoEvtOnlineUsers{users}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    if (proto::parseHeartbeatAck(msg)) {
        return ProtoEvHeartbeatAck{}; // æ”¹ä¸º ProtoEvt å‰ç¼€
    }

    proto::Unknown req_error;
    req_error.message = msg;
    return ProtoEvtUnknow{req_error}; // æ”¹ä¸º ProtoEvt å‰ç¼€
}

========== ./app/ClientEventEnum.h ==========
Lines: 24

//ClientEventEnum.h
#pragma once


enum class EventType {
    // ===== UI å‘½ä»¤ =====
    CmdConnect,
    CmdDisconnect,
    CmdLogin,

    // ===== TCP =====
    TcpConnected,
    TcpDisconnected,

    // ===== åè®® =====
    LoginOk,
    LoginFail,
    OnlineUsers,
    Unknow,

    HeartbeatOk,
    HeartbeatTimeout,
    HeartbeatTick
};

========== ./media/CameraManager.cpp ==========
Lines: 99

//CameraManager.cpp
#include "CameraManager.h"
#include <iostream>
#include <cstring>

CameraManager::CameraManager() {
    gst_init(nullptr, nullptr);
}

CameraManager::~CameraManager() {
    stop();
}

void CameraManager::setFrameCallback(FrameCallback cb) {
    callback_ = std::move(cb);
}

bool CameraManager::start(const std::string& device) {
    if (pipeline_) return true;
    std::cout << "[CameraManager] Attempting to start camera: " << device << std::endl;
    std::string pipelineStr =
        "v4l2src device=" + device +
        " ! video/x-raw,format=YUY2,width=640,height=480,framerate=30/1 "
        " ! videoconvert "
        " ! openh264enc bitrate=2000000 "
        " ! h264parse "
        " ! tee name=t "
        " t. ! queue "
        "     ! avdec_h264 "
        "     ! videoconvert "
        "     ! video/x-raw,format=RGB "
        "     ! appsink name=sink "
        " t. ! queue "
        "     ! rtph264pay pt=96 config-interval=1 "
        "     ! udpsink host=192.168.6.15 port=5000 sync=false async=false";

    pipeline_ = gst_parse_launch(pipelineStr.c_str(), nullptr);
    if (!pipeline_) {
        std::cerr << "Failed to create pipeline\n";
        return false;
    }

    /* appsink ç”¨äº Qt æ˜¾ç¤º */
    appsink_ = gst_bin_get_by_name(GST_BIN(pipeline_), "sink");

    gst_app_sink_set_emit_signals(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_drop(GST_APP_SINK(appsink_), true);
    gst_app_sink_set_max_buffers(GST_APP_SINK(appsink_), 1);
    
    g_signal_connect(appsink_, "new-sample",
                     G_CALLBACK(onNewSample), this);

    gst_element_set_state(pipeline_, GST_STATE_PLAYING);
    std::cout << "[CameraManager] Camera started successfully: " << device << std::endl;
    return true;
}

void CameraManager::stop() {
    if (!pipeline_) return;

    gst_element_set_state(pipeline_, GST_STATE_NULL);
    gst_object_unref(pipeline_);
    pipeline_ = nullptr;
    appsink_ = nullptr;
}

GstFlowReturn CameraManager::onNewSample(GstAppSink* sink, gpointer user_data) {
    auto* self = static_cast<CameraManager*>(user_data);
    if (!self->callback_) return GST_FLOW_OK;

    GstSample* sample = gst_app_sink_pull_sample(sink);
    GstBuffer* buffer = gst_sample_get_buffer(sample);
    GstCaps* caps = gst_sample_get_caps(sample);

    GstStructure* s = gst_caps_get_structure(caps, 0);
    int width = 0, height = 0;
    gst_structure_get_int(s, "width", &width);
    gst_structure_get_int(s, "height", &height);

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);

    Frame frame;
    frame.width = width;
    frame.height = height;
    frame.stride = width * 3;
    frame.format = PixelFormat::RGB888;
    frame.timestamp = GST_BUFFER_PTS(buffer);

    frame.data.resize(map.size);
    std::memcpy(frame.data.data(), map.data, map.size);

    self->callback_(frame);

    gst_buffer_unmap(buffer, &map);
    gst_sample_unref(sample);

    return GST_FLOW_OK;
}

========== ./media/CameraManager.h ==========
Lines: 29

//CameraManager.h
#pragma once

#include <string>
#include <functional>
#include <gst/gst.h>
#include <gst/app/gstappsink.h>
#include "Frame.h"

class CameraManager {
public:
    using FrameCallback = std::function<void(const Frame&)>;

    CameraManager();
    ~CameraManager();

    bool start(const std::string& device);
    void stop();

    void setFrameCallback(FrameCallback cb);

private:
    GstElement* pipeline_ = nullptr;
    GstElement* appsink_  = nullptr;

    FrameCallback callback_;

    static GstFlowReturn onNewSample(GstAppSink* sink, gpointer user_data);
};

========== ./media/Frame.h ==========
Lines: 19

//Frame.h
#pragma once
#include <vector>
#include <cstdint>
#include <QMetaType>   // âš ï¸ å¿…é¡»åŠ è¿™ä¸€è¡Œ
enum class PixelFormat {
    RGB888
};

struct Frame {
    std::vector<uint8_t> data; // è¿ç»­å†…å­˜
    int width = 0;
    int height = 0;
    int stride = 0;
    PixelFormat format;
    uint64_t timestamp = 0;
};

Q_DECLARE_METATYPE(Frame)


=====================================
Total files: 35
Total lines: 1878
