========== å·¥ç¨‹ç›®å½•ç»“æ„ï¼ˆä»…å«.h/.cppï¼‰==========

ğŸ“‚ .:
  â””â”€ server_main.cpp

ğŸ“‚ ./util:
  â””â”€ ThreadPool.cpp
  â””â”€ ThreadPool.h

ğŸ“‚ ./core:
  â””â”€ LoginServer.cpp
  â””â”€ LoginServer.h

ğŸ“‚ ./service:
  â””â”€ CallService.cpp
  â””â”€ CallService.h
  â””â”€ LoginService.cpp
  â””â”€ LoginService.h
  â””â”€ ServerAction.h
  â””â”€ ServerActions.h

ğŸ“‚ ./dispatcher:
  â””â”€ ServerEventDispatcher.cpp
  â””â”€ ServerEventDispatcher.h

ğŸ“‚ ./domain:
  â””â”€ User.h

ğŸ“‚ ./session:
  â””â”€ SessionManager.cpp
  â””â”€ SessionManager.h

ğŸ“‚ ./event:
  â””â”€ ServerEvent.h
  â””â”€ ServerEventFactory.cpp
  â””â”€ ServerEventFactory.h
  â””â”€ ServerEvents.h

ğŸ“‚ ./net:
  â””â”€ CommandSocket.cpp
  â””â”€ CommandSocket.h
  â””â”€ PacketCodec.h

ğŸ“‚ ./protocol:
  â””â”€ protocol_common.h
  â””â”€ protocol_text.cpp
  â””â”€ protocol_text.h
  â””â”€ protocol_types.h

==================================================
========== æ‰€æœ‰.h/.cppæ–‡ä»¶å†…å®¹ ==========


========== ./server_main.cpp ==========
Lines: 15

//server_main.cpp
#include "./core/LoginServer.h"
#include <iostream>
#include <unistd.h>

int main() {
    LoginServer server;
    if (!server.start(6001)) {
        std::cerr << "Server start failed\n";
        return -1;
    }

    std::cout << "Login server running on port 6001\n";
    while (true) sleep(1);
}

========== ./util/ThreadPool.cpp ==========
Lines: 52

// ThreadPool.cpp
#include "./util/ThreadPool.h"

ThreadPool::~ThreadPool() {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        stop_ = true;
    }

    cv_.notify_all();

    for (auto& t : workers_) {
        if (t.joinable())
            t.join();
    }
}


ThreadPool::ThreadPool(size_t workerCount) {
    for (size_t i = 0; i < workerCount; ++i) {
        workers_.emplace_back(&ThreadPool::workerLoop, this);
    }
}

void ThreadPool::post(std::function<void()> task) {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        tasks_.push(std::move(task));
    }
    cv_.notify_one();
}

void ThreadPool::workerLoop() {
    while (true) {
        std::function<void()> task;

        {
            std::unique_lock<std::mutex> lock(mutex_);
            cv_.wait(lock, [&] {
                return stop_ || !tasks_.empty();
            });

            if (stop_ && tasks_.empty())
                return;

            task = std::move(tasks_.front());
            tasks_.pop();
        }

        task();  // â­ çœŸæ­£æ‰§è¡Œä»»åŠ¡
    }
}

========== ./util/ThreadPool.h ==========
Lines: 29

// ThreadPool.h
#pragma once
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <functional>

class ThreadPool {
public:
    explicit ThreadPool(size_t workerCount);
    ~ThreadPool();

    // å‘çº¿ç¨‹æ± æŠ•é€’ä»»åŠ¡
    void post(std::function<void()> task);

private:
    // æ¯ä¸ª worker çº¿ç¨‹æ‰§è¡Œçš„å‡½æ•°
    void workerLoop();

private:
    std::vector<std::thread> workers_;          // å›ºå®šæ•°é‡çº¿ç¨‹
    std::queue<std::function<void()>> tasks_;   // ä»»åŠ¡é˜Ÿåˆ—

    std::mutex mutex_;
    std::condition_variable cv_;
    bool stop_ = false;
};

========== ./core/LoginServer.cpp ==========
Lines: 306

//LoginServer.cpp
// LoginServer: protocol â†” domain çš„è¾¹ç•Œå±‚

#include "./core/LoginServer.h"

// å®ç° LoginServer æ„é€ å‡½æ•°
LoginServer::LoginServer() 
    : dispatcher_(loginService_, sessionMgr_, callService_)  // æ‰‹åŠ¨åˆå§‹åŒ– dispatcher_ï¼Œä¼ å…¥æ‰€éœ€ä¸¤ä¸ªå‚æ•°
{
    // æ„é€ å‡½æ•°ä½“å¯ç•™ç©ºï¼ˆå¦‚éœ€å…¶ä»–åˆå§‹åŒ–é€»è¾‘å¯è¡¥å……ï¼‰
}
LoginServer::~LoginServer() {
    listener_.stop();      // åœæ­¢ accept çº¿ç¨‹
    // ThreadPool ææ„ä¼šè‡ªåŠ¨ join
}


bool LoginServer::start(int port) {
    listener_.setAcceptCallback(
        [this](int clientfd) {
            onAccept(clientfd);
        }
    );
    bool ok = listener_.startListen(port);

    if (ok) {
        startHeartbeatMonitor(); // âš¡ å¯åŠ¨å¿ƒè·³ç›‘æµ‹
    }

    return ok;
}

void LoginServer::startHeartbeatMonitor() {
    std::thread([this] {
        while (true) {
            auto snapshot = sessionMgr_.snapshot();
            auto now = std::chrono::steady_clock::now();

            for (auto& [fd, info] : snapshot) {
                auto dur = std::chrono::duration_cast<std::chrono::seconds>(
                    now - info.lastHeartbeat
                ).count();

                if (dur > 15) { // è¶…è¿‡ 15 ç§’æ²¡å¿ƒè·³å°±ä¸‹çº¿
                    std::cout << "[Server] heartbeat timeout fd=" << fd << std::endl;
                    sessionMgr_.logout(fd);
                    close(fd);

                    // å¹¿æ’­æ–°çš„åœ¨çº¿ç”¨æˆ·åˆ—è¡¨
                    auto onlineSnapshot = sessionMgr_.snapshot();
                    proto::OnlineUsers users;
                    for (auto& [fd2, info2] : onlineSnapshot) {
                        users.users.push_back({info2.user.username, info2.user.privilege});
                    }
                    auto payload = proto::makeOnlineUsers(users);
                    for (auto& [fd2, _] : onlineSnapshot) {
                        listener_.sendPacket(fd2, payload);
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }).detach();
}


void LoginServer::onAccept(int clientfd) {
    std::cout << "[Server] new client fd=" << clientfd << std::endl;
    
    pool_.post([this, clientfd] {
        clientThread(clientfd);
    });
}

void LoginServer::clientThread(int clientfd) {
    std::vector<char> recvBuffer;
    char buf[1024];


    
    while (true) {
        int n = recv(clientfd, buf, sizeof(buf), 0);
        if (n <= 0) {
            break;}

        recvBuffer.insert(recvBuffer.end(), buf, buf + n);

        std::string payload;
        while (PacketCodec::tryDecode(recvBuffer, payload)) {
            onMessage(clientfd, payload);
        }
    }

    

    // å®¢æˆ·ç«¯æ–­å¼€å¤„ç†
    sessionMgr_.logout(clientfd);

    auto snapshot = sessionMgr_.snapshot();
    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        users.users.push_back({info.user.username, info.user.privilege});
    }
    auto payload = proto::makeOnlineUsers(users);
    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }

    close(clientfd);
    std::cout << "[Server] client disconnected fd=" << clientfd << std::endl;
}

void LoginServer::onMessage(int fd, const std::string& msg)
{
    ServerEvent event = ServerEventFactory::makeEvent(msg);

    auto actions = dispatcher_.dispatch(fd, event);

    for (auto& act : actions) {
        std::visit([this](auto&& a) {
            handle(a);
        }, act);
    }
}

// å¤„ç†SendMediaOfferåŠ¨ä½œï¼ˆä¸‹å‘å¯¹æ–¹IP/Portï¼‰
void LoginServer::handle(const SendMediaOffer& a) {
    // æ„å»ºåª’ä½“Offerå›åº”ï¼ˆæºå¸¦å¯¹æ–¹IP/Portï¼‰
    auto payload = proto::makeMediaOfferResp(
        a.peer,
        a.peer_net.lanIp,
        a.peer_net.vpnIp,
        a.peer_net.udpPort
    );
    // å‘é€ç»™ç›®æ ‡ç”¨æˆ·
    listener_.sendPacket(a.fd, payload);
    std::cout << "[Server] Send media offer resp to fd=" << a.fd 
              << " peer=" << a.peer 
              << " lan=" << a.peer_net.lanIp
              << " vpn=" << a.peer_net.vpnIp
              << " port=" << a.peer_net.udpPort << std::endl;
}

// å¤„ç†SendMediaAnsweråŠ¨ä½œï¼ˆä¸‹å‘å¯¹æ–¹IP/Portï¼‰
void LoginServer::handle(const SendMediaAnswer& a) {
    // æ„å»ºåª’ä½“Answerå›åº”ï¼ˆæºå¸¦å¯¹æ–¹IP/Portï¼‰
    auto payload = proto::makeMediaAnswerResp(
        a.peer,
        a.peer_net.lanIp,
        a.peer_net.vpnIp,
        a.peer_net.udpPort
    );
    // å‘é€ç»™ç›®æ ‡ç”¨æˆ·
    listener_.sendPacket(a.fd, payload);
    std::cout << "[Server] Send media answer resp to fd=" << a.fd 
              << " peer=" << a.peer 
              << " lan=" << a.peer_net.lanIp
              << " vpn=" << a.peer_net.vpnIp
              << " port=" << a.peer_net.udpPort << std::endl;
}



// å¤„ç†å‘é€æ–°æ¥ç”µé€šçŸ¥çš„Action
void LoginServer::handle(const SendCallIncoming& a) {
    // æ„å»ºæ–°æ¥ç”µçš„payload
    auto payload = proto::makeCallIncoming(a.from_user);
    // å‘é€ç»™è¢«å‘¼å«æ–¹
    listener_.sendPacket(a.target_fd, payload);
    std::cout << "[Server] Send call incoming to fd=" << a.target_fd 
              << " from=" << a.from_user << std::endl;
}

// å¤„ç†å‘é€é€šè¯æ¥é€šé€šçŸ¥çš„Action
void LoginServer::handle(const SendCallAccepted& a) {
    // æ„å»ºé€šè¯æ¥é€šçš„payload
    auto payload = proto::makeCallAccepted(a.peer);
    // å‘é€ç»™ç›®æ ‡ç”¨æˆ·
    listener_.sendPacket(a.fd, payload);
    std::cout << "[Server] Send call accepted to fd=" << a.fd 
              << " peer=" << a.peer << std::endl;
}

// å¤„ç†å‘é€é€šè¯è¢«æ‹’é€šçŸ¥çš„Action
void LoginServer::handle(const SendCallRejected& a) {
    // æ„å»ºé€šè¯è¢«æ‹’çš„payload
    auto payload = proto::makeCallRejected(a.peer);
    // å‘é€ç»™å‘¼å«æ–¹
    listener_.sendPacket(a.fd, payload);
    std::cout << "[Server] Send call rejected to fd=" << a.fd 
              << " peer=" << a.peer << std::endl;
}




void LoginServer::handle(const SendLoginOk& a)
{
    proto::UserInfo u;
    u.username = a.username;
    u.privilege = a.privilege;

    auto payload = proto::makeLoginOk(u, "welcome");
    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const SendLoginFail& a)
{
    auto payload = proto::makeLoginFail(a.reason);
    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const BroadcastOnlineUsers&)
{
    auto snapshot = sessionMgr_.snapshot();

    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        const domain::User& u = info.user;

        users.users.push_back(proto::UserInfo{
            u.username,
            u.privilege
        });
    }


    auto payload = proto::makeOnlineUsers(users);

    std::cout << "Broadcast: " << payload << std::endl;
    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }
}

void LoginServer::handle(const SendError& a)
{
    auto payload = (a.reason);
    std::cout << "Error: " << payload << std::endl;

    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const BroadcastLogout&)
{
    auto snapshot = sessionMgr_.snapshot();

    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        const domain::User& u = info.user;
        users.users.push_back({u.username, u.privilege});
    }

    auto payload = proto::makeOnlineUsers(users);

    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }
}

void LoginServer::handle(const SendHeartbeatAck& a)
{
    std::cout << "[Server] Send PONG to fd= " << a.fd << std::endl;
    std::string payload = proto::makeHeartbeatAck(); // â­ PONG

    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const UpdatePeerInfo& a)
{
    ClientNetInfo net{
        .lanIp = a.lanIp,
        .vpnIp = a.vpnIp,
        .udpPort = a.udpPort
    };

    sessionMgr_.updateNetInfo(a.fd, net);

    std::cout << "[Server] Registered peer info for fd=" << a.fd << std::endl;
}


void LoginServer::handle(const SendUserNotFound& a)
{
    std::string reason = "User not found: " + a.target_user;
    auto payload = proto::makeLoginFail(reason); // å¤ç”¨ LoginFail æ ¼å¼è¿”å›é”™è¯¯
    listener_.sendPacket(a.fd, payload);
    std::cout << "[Server] Send user not found to fd=" << a.fd << ": " << a.target_user << std::endl;
}

// è°ƒæ•´ï¼šå®šå‘è½¬å‘æ–‡æœ¬æ¶ˆæ¯ç»™ç›®æ ‡ç”¨æˆ·
void LoginServer::handle(const ForwardText& a)
{
    // ç›®æ ‡ç”¨æˆ·ä¸å­˜åœ¨åˆ™è·³è¿‡
    if (a.target_fd == -1) return;

    // æ„å»ºè½¬å‘æ–‡æœ¬çš„ payload
    auto payload = proto::makeForwardTextMsg(a.from_user, a.content);

    // ä»…å‘é€ç»™ç›®æ ‡ FD
    listener_.sendPacket(a.target_fd, payload);
    std::cout << "[Server] Forward text to fd=" << a.target_fd 
              << " from=" << a.from_user 
              << " content=" << a.content << std::endl;
}

========== ./core/LoginServer.h ==========
Lines: 58

//LoginServer.h
#pragma once
#include <thread>
#include <mutex>
#include <map>
#include <iostream>
#include <sstream>


#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "./util/ThreadPool.h"
#include "./net/PacketCodec.h"
#include "./net/CommandSocket.h"
#include "./event/ServerEvent.h"
#include "./event/ServerEventFactory.h"
#include "./session/SessionManager.h"
#include "./dispatcher/ServerEventDispatcher.h"
#include "./service/ServerAction.h"
#include "./protocol/protocol_text.h"
#include "./protocol/protocol_common.h"
#include "./service/CallService.h"

class LoginServer {
public:
    LoginServer();
    ~LoginServer();
    bool start(int port);

private:
    void onAccept(int clientfd);
    void clientThread(int clientfd);
    void onMessage(int clientfd, const std::string& msg);
    void handleLogin(int fd, ServerEvent& event);
    void startHeartbeatMonitor();
    void handle(const SendLoginOk&);
    void handle(const SendLoginFail&);
    void handle(const BroadcastOnlineUsers&);
    void handle(const SendError&);
    void handle(const BroadcastLogout&);
    void handle(const SendHeartbeatAck& a);
    void handle(const UpdatePeerInfo&);
    void handle(const ForwardText&);          
    void handle(const SendUserNotFound&);     
    void handle(const SendCallIncoming& a);
    void handle(const SendCallAccepted& a);
    void handle(const SendCallRejected& a);
    void handle(const SendMediaOffer& a);   
    void handle(const SendMediaAnswer& a);   
    CommandSocket listener_;
    ThreadPool pool_{8};
    SessionManager sessionMgr_;
    LoginService loginService_;
    CallService callService_;  // æ–°å¢ï¼šCallServiceæˆå‘˜
    ServerEventDispatcher dispatcher_; // è°ƒæ•´é¡ºåºï¼šéœ€åœ¨callService_ä¹‹ååˆå§‹åŒ–
};

========== ./service/ServerActions.h ==========
Lines: 91

// Service/ServerActions.h
#pragma once
#include <string>
#include <vector>
#include <map>
//#include "SessionManager.h"

// å•æ’­ï¼šç™»å½•æˆåŠŸ
struct SendLoginOk {
    int fd;
    std::string username;
    int privilege;
};

// å•æ’­ï¼šç™»å½•å¤±è´¥
struct SendLoginFail {
    int fd;
    std::string reason;
};

struct SendError {
    int fd;
    std::string reason;
};

// å¹¿æ’­ï¼šåœ¨çº¿ç”¨æˆ·åˆ—è¡¨
struct BroadcastOnlineUsers {
};

struct BroadcastLogout {
};

// æ–°å¢ï¼šæœåŠ¡å™¨å›åº”å¿ƒè·³
struct SendHeartbeatAck {
    int fd;
};

struct UpdatePeerInfo {
    int fd;
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};

struct ForwardText {
    int target_fd;               // ç›®æ ‡ç”¨æˆ· FDï¼ˆ-1 è¡¨ç¤ºç”¨æˆ·ä¸å­˜åœ¨ï¼‰
    std::string from_user;       // å‘é€è€…ç”¨æˆ·å
    std::string content;         // æ¶ˆæ¯å†…å®¹
    int sender_fd;               // å‘é€è€… FDï¼ˆç”¨äºè¿”å›é”™è¯¯ï¼‰
};

struct SendUserNotFound {
    int fd;                      // å‘é€è€… FD
    std::string target_user;     // ä¸å­˜åœ¨çš„ç”¨æˆ·å
};

// å•æ’­ç»™è¢«å‘¼å«æ–¹ï¼šæœ‰æ–°æ¥ç”µ
struct SendCallIncoming {
    int target_fd;       // è¢«å‘¼å«æ–¹çš„FD
    std::string from_user; // å‘¼å«æ–¹ç”¨æˆ·å
};

// å•æ’­ï¼šé€šè¯å·²æ¥é€šï¼ˆç»™å‘¼å«æ–¹/è¢«å‘¼å«æ–¹ï¼‰
struct SendCallAccepted {
    int fd;              // ç›®æ ‡FD
    std::string peer;    // é€šè¯å¯¹æ–¹çš„ç”¨æˆ·å
};

// å•æ’­ï¼šé€šè¯è¢«æ‹’ç»ï¼ˆä»…ç»™å‘¼å«æ–¹ï¼‰
struct SendCallRejected {
    int fd;              // å‘¼å«æ–¹çš„FD
    std::string peer;    // è¢«å‘¼å«æ–¹çš„ç”¨æˆ·å
};

//å‘é€åª’ä½“Offerï¼ˆæºå¸¦å¯¹æ–¹IP/Portï¼‰
struct SendMediaOffer {
    int fd;              // ç›®æ ‡FD
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    ClientNetInfo peer_net; // å¯¹æ–¹çš„ç½‘ç»œä¿¡æ¯ï¼ˆlanIp/vpnIp/udpPortï¼‰
};

// å‘é€åª’ä½“Answerï¼ˆæºå¸¦å¯¹æ–¹IP/Portï¼‰
struct SendMediaAnswer {
    int fd;              // ç›®æ ‡FD
    std::string peer;    // å¯¹æ–¹ç”¨æˆ·å
    ClientNetInfo peer_net; // å¯¹æ–¹çš„ç½‘ç»œä¿¡æ¯
};
// æœªæ¥å¯æ— é™åŠ 
// struct KickUser { int fd; };
// struct ForceLogout { int fd; };
// struct SendChat { int from; std::string msg; };

========== ./service/LoginService.h ==========
Lines: 22

//LoginService.h
#pragma once
#include <string>

#include "./event/ServerEvent.h" // for proto::LoginRequest





struct LoginResult {
    bool success = false;
    std::string username;
    int privilege = 0;
    std::string reason;   // å¤±è´¥åŸå› 
    //UserInfo user;
};

class LoginService {
public:
    LoginResult handleLogin(const event::LoginRequest& req);
};

========== ./service/CallService.h ==========
Lines: 42

// CallService.h
#pragma once
#include <map>
#include <optional>
#include <string>
#include <mutex>

// é€šè¯ä¼šè¯ï¼šç»´æŠ¤å•æ¬¡é€šè¯çš„åŒæ–¹å’ŒçŠ¶æ€
struct CallSession {
    std::string caller;    // å‘¼å«æ–¹ç”¨æˆ·å
    std::string callee;    // è¢«å‘¼å«æ–¹ç”¨æˆ·å
    enum State { 
        RINGING,           // æŒ¯é“ƒä¸­ï¼ˆè¢«å‘¼å«æ–¹æœªå“åº”ï¼‰
        CONNECTED,         // ä¿¡ä»¤æ¥é€šï¼ˆåŒæ–¹åŒæ„é€šè¯ï¼Œæœªåå•†åª’ä½“ï¼‰
        MEDIA_NEGOTIATING, // åª’ä½“åå•†ä¸­ï¼ˆæ­£åœ¨ä¸‹å‘IP/Portï¼‰
        MEDIA_READY,       // åª’ä½“å°±ç»ªï¼ˆå¯å¼€å§‹UDPæ¨æµï¼‰
        REJECTED           // é€šè¯è¢«æ‹’ç»
    } state;
};

// é€šè¯æœåŠ¡ï¼šé›†ä¸­ç®¡ç†æ‰€æœ‰æ´»è·ƒé€šè¯ï¼Œä¿è¯çº¿ç¨‹å®‰å…¨
class CallService {
public:
    // å¤„ç†å‘¼å«è¯·æ±‚ï¼šè¿”å›åˆ›å»ºçš„é€šè¯ä¼šè¯ï¼ˆå¤±è´¥åˆ™è¿”å›ç©ºï¼‰
    std::optional<CallSession> onCallRequest(const std::string& from, const std::string& to);
    
    // å¤„ç†æ¥å—é€šè¯ï¼šæ ¹æ®è¢«å‘¼å«æ–¹ç”¨æˆ·åæ‰¾åˆ°å¯¹åº”çš„é€šè¯ä¼šè¯
    std::optional<CallSession> onAccept(const std::string& user);
    
    // å¤„ç†æ‹’ç»é€šè¯ï¼šåŒç†
    std::optional<CallSession> onReject(const std::string& user);

    std::optional<CallSession> onMediaNegotiate(const std::string& user);

    void onMediaReady(const std::string& user);    

private:
    // å­˜å‚¨æ´»è·ƒé€šè¯ï¼škey=è¢«å‘¼å«æ–¹ç”¨æˆ·åï¼ˆä¿è¯ä¸€ä¸ªç”¨æˆ·åŒæ—¶åªèƒ½æ¥ä¸€ä¸ªæ¥ç”µï¼‰
    std::map<std::string, CallSession> activeCalls_;
    // çº¿ç¨‹å®‰å…¨é”ï¼ˆå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¿æŠ¤activeCalls_ï¼‰
    std::mutex mutex_;
};
========== ./service/LoginService.cpp ==========
Lines: 35

//LoginService
#include "LoginService.h"

LoginResult LoginService::handleLogin(const event::LoginRequest& req) {
    LoginResult r;

    if (req.username == "admin" && req.password == "123") {
        r.success = true;
        r.username = "admin";
        r.privilege = 10;
    } 
    else if (req.username == "user_a" && req.password == "123") {
        r.success = true;
        r.username = "user_a";
        r.privilege = 10;
    } 
    else if (req.username == "user_b" && req.password == "123") {
        r.success = true;
        r.username = "user_b";
        r.privilege = 10;
    }     
    else if (req.username == "user_c" && req.password == "123") {
        r.success = true;
        r.username = "user_c";
        r.privilege = 10;
    }     


    else {
        r.success = false;
        r.reason = "invalid username or password";
    }

    return r;
}

========== ./service/CallService.cpp ==========
Lines: 121

// CallService.cpp
#include "CallService.h"
#include <iostream>

// å¤„ç†å‘¼å«è¯·æ±‚ï¼šæ£€æŸ¥è¢«å‘¼å«æ–¹æ˜¯å¦å·²æœ‰æœªå¤„ç†æ¥ç”µ
std::optional<CallSession> CallService::onCallRequest(const std::string& from, const std::string& to) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // æ£€æŸ¥è¢«å‘¼å«æ–¹æ˜¯å¦å·²æœ‰æ´»è·ƒæ¥ç”µï¼ˆé˜²æ­¢é‡å¤å‘¼å«ï¼‰
    if (activeCalls_.find(to) != activeCalls_.end()) {
        std::cout << "[CallService] User " << to << " is already in a call" << std::endl;
        return std::nullopt;
    }
    
    // åˆ›å»ºæ–°çš„é€šè¯ä¼šè¯ï¼ˆæŒ¯é“ƒçŠ¶æ€ï¼‰
    CallSession session{
        .caller = from,
        .callee = to,
        .state = CallSession::RINGING
    };
    activeCalls_[to] = session;
    
    std::cout << "[CallService] Create call session: " << from << " -> " << to << std::endl;
    return session;
}

// å¤„ç†æ¥å—é€šè¯ï¼šæ‰¾åˆ°è¢«å‘¼å«æ–¹çš„æ´»è·ƒé€šè¯å¹¶æ›´æ–°çŠ¶æ€
std::optional<CallSession> CallService::onAccept(const std::string& user) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = activeCalls_.find(user);
    if (it == activeCalls_.end()) {
        std::cout << "[CallService] No incoming call for user " << user << std::endl;
        return std::nullopt;
    }
    
    // æ›´æ–°é€šè¯çŠ¶æ€ä¸ºå·²æ¥é€šï¼ˆä»…æ›´æ–°çŠ¶æ€ï¼Œä¸åˆ é™¤ä¼šè¯ï¼‰
    it->second.state = CallSession::CONNECTED;
    auto session = it->second;
    
    std::cout << "[CallService] Call accepted: " << session.caller << " <-> " << session.callee << std::endl;
    return session; // âœ… ä¿ç•™ä¼šè¯ï¼Œä¾›åç»­åª’ä½“åå•†ä½¿ç”¨
}

// å¤„ç†æ‹’ç»é€šè¯ï¼šæ‰¾åˆ°è¢«å‘¼å«æ–¹çš„æ´»è·ƒé€šè¯å¹¶æ›´æ–°çŠ¶æ€
std::optional<CallSession> CallService::onReject(const std::string& user) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = activeCalls_.find(user);
    if (it == activeCalls_.end()) {
        std::cout << "[CallService] No incoming call for user " << user << std::endl;
        return std::nullopt;
    }
    
    // æ›´æ–°é€šè¯çŠ¶æ€ä¸ºå·²æ‹’ç»
    it->second.state = CallSession::REJECTED;
    auto session = it->second;
    
    // æ‹’ç»åç§»é™¤æ´»è·ƒé€šè¯
    activeCalls_.erase(it);
    
    std::cout << "[CallService] Call rejected: " << session.caller << " -> " << session.callee << std::endl;
    return session;
}

// æ ‡è®°åª’ä½“åå•†å¼€å§‹
std::optional<CallSession> CallService::onMediaNegotiate(const std::string& user) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // æ–¹å¼1ï¼šå…ˆæŒ‰ callee æŸ¥æ‰¾ï¼ˆåŸé€»è¾‘ï¼‰
    auto it = activeCalls_.find(user);
    if (it != activeCalls_.end()) {
        // ä»…å¤„ç†ä¿¡ä»¤å·²æ¥é€šçš„ä¼šè¯
        if (it->second.state != CallSession::CONNECTED) {
            std::cout << "[CallService] Call not connected for media negotiate: " << user << std::endl;
            return std::nullopt;
        }
        it->second.state = CallSession::MEDIA_NEGOTIATING;
        std::cout << "[CallService] Media negotiate start: " << it->second.caller << " <-> " << it->second.callee << std::endl;
        return it->second;
    }
    
    // æ–¹å¼2ï¼šæŒ‰ caller æŸ¥æ‰¾ï¼ˆè¡¥å……åŒå‘æŸ¥æ‰¾ï¼‰
    for (auto& [key, session] : activeCalls_) {
        if (session.caller == user && session.state == CallSession::CONNECTED) {
            session.state = CallSession::MEDIA_NEGOTIATING;
            std::cout << "[CallService] Media negotiate start (by caller): " << session.caller << " <-> " << session.callee << std::endl;
            return session;
        }
    }
    
    std::cout << "[CallService] No active call for media negotiate: " << user << std::endl;
    return std::nullopt;
}

// æ ‡è®°åª’ä½“å°±ç»ªï¼ˆå®Œæˆååˆ é™¤ä¼šè¯ï¼‰
void CallService::onMediaReady(const std::string& user) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // æŒ‰ callee åˆ é™¤
    auto it = activeCalls_.find(user);
    if (it != activeCalls_.end()) {
        it->second.state = CallSession::MEDIA_READY;
        std::cout << "[CallService] Media ready, remove session: " << it->second.caller << " <-> " << it->second.callee << std::endl;
        activeCalls_.erase(it);
        return;
    }
    
    // æŒ‰ caller åˆ é™¤ï¼ˆè¡¥å……åŒå‘åˆ é™¤ï¼‰
    for (auto iter = activeCalls_.begin(); iter != activeCalls_.end(); ++iter) {
        if (iter->second.caller == user) {
            iter->second.state = CallSession::MEDIA_READY;
            std::cout << "[CallService] Media ready, remove session (by caller): " << iter->second.caller << " <-> " << iter->second.callee << std::endl;
            activeCalls_.erase(iter);
            break;
        }
    }
}




========== ./service/ServerAction.h ==========
Lines: 21

// Service/ServerAction.h
#pragma once
#include <variant>
#include "ServerActions.h"

using ServerAction = std::variant<
    SendError,
    SendLoginOk,
    SendLoginFail,
    BroadcastOnlineUsers,
    BroadcastLogout,
    SendHeartbeatAck,
    UpdatePeerInfo,
    ForwardText,
    SendUserNotFound,
    SendCallIncoming,
    SendCallAccepted,
    SendCallRejected,
    SendMediaOffer,
    SendMediaAnswer
>;

========== ./dispatcher/ServerEventDispatcher.cpp ==========
Lines: 451

//ServerEventDispatcher.cpp
#include "./dispatcher/ServerEventDispatcher.h"
#include "iostream"


ServerEventDispatcher::ServerEventDispatcher(
    LoginService& loginService,
    SessionManager& sessionMgr,
    CallService& callService)
    : loginService_(loginService),
      sessionMgr_(sessionMgr),
      callService_(callService)
{}


std::vector<ServerAction>
ServerEventDispatcher::dispatch(int fd, const ServerEvent& event)
{
    return std::visit([&](auto&& ev) {
        return handle(fd, ev);
    }, event);
}



// å¤„ç†MediaOfferäº‹ä»¶
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::MediaOffer& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯å‘é€è€…æ˜¯å¦å·²ç™»å½•
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot send media offer"
        });
        return actions;
    }

    // 2. è·å–å‘é€è€…ç”¨æˆ·å
    auto snapshot = sessionMgr_.snapshot();
    std::string from_user = snapshot.at(fd).user.username;

    // 3. æ£€æŸ¥ç›®æ ‡ç”¨æˆ·æ˜¯å¦åœ¨çº¿
    int target_fd = sessionMgr_.getFdByUsername(ev.target_user);
    if (target_fd == -1) {
        actions.emplace_back(SendUserNotFound{
            .fd = fd,
            .target_user = ev.target_user
        });
        return actions;
    }

    // âœ… ä¿®å¤ï¼šä¼ å…¥ã€Œå‘é€è€…ç”¨æˆ·åã€è€Œéã€Œç›®æ ‡ç”¨æˆ·ã€æŸ¥æ‰¾ä¼šè¯ï¼ˆé€‚é…åŒå‘æŸ¥æ‰¾é€»è¾‘ï¼‰
    auto call_session = callService_.onMediaNegotiate(from_user);
    if (!call_session) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "No active call for media offer"
        });
        return actions;
    }

    // 4. éªŒè¯ä¼šè¯çš„ç›®æ ‡ç”¨æˆ·æ˜¯å¦åŒ¹é…ï¼ˆé˜²æ­¢è·¨ä¼šè¯åå•†ï¼‰
    if (call_session->callee != ev.target_user && call_session->caller != ev.target_user) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Media offer target mismatch with active call"
        });
        return actions;
    }

    // 5. è·å–ç›®æ ‡ç”¨æˆ·çš„IP/Portï¼ˆä»SessionManagerä¸­è¯»å–ï¼‰
    ClientNetInfo target_net = snapshot.at(target_fd).net;
    if (target_net.udpPort == 0 || target_net.lanIp.empty()) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Target user has no registered peer info"
        });
        return actions;
    }

    // 6. ç”ŸæˆActionï¼šå‘å‘é€è€…ä¸‹å‘ç›®æ ‡ç”¨æˆ·çš„IP/Port
    actions.emplace_back(SendMediaOffer{
        .fd = fd,
        .peer = ev.target_user,
        .peer_net = target_net
    });

    std::cout << "[Dispatcher] Media offer from " << from_user << " to " << ev.target_user 
              << " lan=" << target_net.lanIp << " vpn=" << target_net.vpnIp << " port=" << target_net.udpPort << std::endl;
    return actions;
}

// å¤„ç†MediaAnsweräº‹ä»¶
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::MediaAnswer& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯å‘é€è€…æ˜¯å¦å·²ç™»å½•
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot send media answer"
        });
        return actions;
    }

    // 2. è·å–å‘é€è€…ç”¨æˆ·å
    auto snapshot = sessionMgr_.snapshot();
    std::string from_user = snapshot.at(fd).user.username;

    // 3. æ£€æŸ¥ç›®æ ‡ç”¨æˆ·æ˜¯å¦åœ¨çº¿
    int target_fd = sessionMgr_.getFdByUsername(ev.target_user);
    if (target_fd == -1) {
        actions.emplace_back(SendUserNotFound{
            .fd = fd,
            .target_user = ev.target_user
        });
        return actions;
    }

    // âœ… ä¿®å¤ï¼šä¼ å…¥ã€Œå‘é€è€…ç”¨æˆ·åã€æŸ¥æ‰¾ä¼šè¯
    auto call_session = callService_.onMediaNegotiate(from_user);
    if (!call_session) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "No active call for media answer"
        });
        return actions;
    }

    // 4. éªŒè¯ä¼šè¯çš„ç›®æ ‡ç”¨æˆ·æ˜¯å¦åŒ¹é…
    if (call_session->callee != ev.target_user && call_session->caller != ev.target_user) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Media answer target mismatch with active call"
        });
        return actions;
    }

    // 5. è·å–ç›®æ ‡ç”¨æˆ·çš„IP/Portï¼ˆä»SessionManagerä¸­è¯»å–ï¼‰
    ClientNetInfo target_net = snapshot.at(target_fd).net;
    if (target_net.udpPort == 0 || target_net.lanIp.empty()) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Target user has no registered peer info"
        });
        return actions;
    }

    // 6. ç”ŸæˆActionï¼šå‘å‘é€è€…ä¸‹å‘ç›®æ ‡ç”¨æˆ·çš„IP/Port
    actions.emplace_back(SendMediaAnswer{
        .fd = fd,
        .peer = ev.target_user,
        .peer_net = target_net
    });

    // 7. æ ‡è®°åª’ä½“å°±ç»ªï¼ˆå®Œæˆååˆ é™¤é€šè¯ä¼šè¯ï¼‰
    callService_.onMediaReady(from_user);

    std::cout << "[Dispatcher] Media answer from " << from_user << " to " << ev.target_user 
              << " lan=" << target_net.lanIp << " vpn=" << target_net.vpnIp << " port=" << target_net.udpPort << std::endl;
    return actions;
}

std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::CallRequest& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯å‘é€è€…æ˜¯å¦å·²ç™»å½•
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot make call"
        });
        return actions;
    }

    // 2. è·å–å‘é€è€…ç”¨æˆ·å
    auto snapshot = sessionMgr_.snapshot();
    std::string from_user = snapshot.at(fd).user.username;

    // 3. æ£€æŸ¥ç›®æ ‡ç”¨æˆ·æ˜¯å¦åœ¨çº¿
    int target_fd = sessionMgr_.getFdByUsername(ev.target_user);
    if (target_fd == -1) {
        actions.emplace_back(SendUserNotFound{
            .fd = fd,
            .target_user = ev.target_user
        });
        return actions;
    }

    // 4. è°ƒç”¨CallServiceåˆ›å»ºé€šè¯ä¼šè¯
    auto call_session = callService_.onCallRequest(from_user, ev.target_user);
    if (!call_session) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Failed to make call: target user is busy"
        });
        return actions;
    }

    // 5. ç”ŸæˆActionï¼šé€šçŸ¥è¢«å‘¼å«æ–¹æœ‰æ–°æ¥ç”µ
    actions.emplace_back(SendCallIncoming{
        .target_fd = target_fd,
        .from_user = from_user
    });

    std::cout << "[Dispatcher] Call request from " << from_user << " to " << ev.target_user << std::endl;
    return actions;
}

// å¤„ç†æ¥å—é€šè¯äº‹ä»¶
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::CallAccept& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot accept call"
        });
        return actions;
    }

    // 2. è·å–å½“å‰ç”¨æˆ·ï¼ˆè¢«å‘¼å«æ–¹ï¼‰ç”¨æˆ·å
    auto snapshot = sessionMgr_.snapshot();
    std::string callee = snapshot.at(fd).user.username;

    // 3. è°ƒç”¨CallServiceå¤„ç†æ¥å—é€šè¯
    auto call_session = callService_.onAccept(callee);
    if (!call_session) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "No incoming call to accept"
        });
        return actions;
    }

    // 4. è·å–å‘¼å«æ–¹çš„FD
    int caller_fd = sessionMgr_.getFdByUsername(call_session->caller);
    if (caller_fd == -1) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "Caller is offline"
        });
        return actions;
    }

    // 5. ç”ŸæˆActionï¼šé€šçŸ¥å‘¼å«æ–¹å’Œè¢«å‘¼å«æ–¹é€šè¯å·²æ¥é€š
    // é€šçŸ¥è¢«å‘¼å«æ–¹
    actions.emplace_back(SendCallAccepted{
        .fd = fd,
        .peer = call_session->caller
    });
    // é€šçŸ¥å‘¼å«æ–¹
    actions.emplace_back(SendCallAccepted{
        .fd = caller_fd,
        .peer = callee
    });

    std::cout << "[Dispatcher] Call accepted: " << call_session->caller << " <-> " << callee << std::endl;
    return actions;
}

// å¤„ç†æ‹’ç»é€šè¯äº‹ä»¶
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::CallReject& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot reject call"
        });
        return actions;
    }

    // 2. è·å–å½“å‰ç”¨æˆ·ï¼ˆè¢«å‘¼å«æ–¹ï¼‰ç”¨æˆ·å
    auto snapshot = sessionMgr_.snapshot();
    std::string callee = snapshot.at(fd).user.username;

    // 3. è°ƒç”¨CallServiceå¤„ç†æ‹’ç»é€šè¯
    auto call_session = callService_.onReject(callee);
    if (!call_session) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "No incoming call to reject"
        });
        return actions;
    }

    // 4. è·å–å‘¼å«æ–¹çš„FD
    int caller_fd = sessionMgr_.getFdByUsername(call_session->caller);
    if (caller_fd != -1) {
        // ç”ŸæˆActionï¼šé€šçŸ¥å‘¼å«æ–¹é€šè¯è¢«æ‹’ç»
        actions.emplace_back(SendCallRejected{
            .fd = caller_fd,
            .peer = callee
        });
    }

    std::cout << "[Dispatcher] Call rejected: " << call_session->caller << " -> " << callee << std::endl;
    return actions;
}




// ç™»å½•
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::LoginRequest& ev)
{
    std::vector<ServerAction> actions;

    LoginResult r = loginService_.handleLogin(ev);

    if (r.success) {
        sessionMgr_.login(fd, {
            domain::User{ r.username, r.privilege },
            true
        });

        actions.emplace_back(SendLoginOk{
            .fd = fd,
            .username = r.username,
            .privilege = r.privilege
        });

        actions.emplace_back(BroadcastOnlineUsers{
            
        });
    } else {
        actions.emplace_back(SendLoginFail{
            .fd = fd,
            .reason = r.reason
        });
    }

    return actions;
}


std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::ErrorEvent& ev)
{
    std::vector<ServerAction> actions;
    
    actions.emplace_back(SendError{
        .fd = fd,
        .reason = ev.reason +ev.rawMsg
    });

    return actions;
}

std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::Logout& ev)
{
    std::vector<ServerAction> actions;

    // å…³é”®ï¼šå…ˆä» SessionManager é‡Œç§»é™¤
    sessionMgr_.logout(fd);

    // ç„¶åå¹¿æ’­æ–°çš„åœ¨çº¿åˆ—è¡¨
    actions.emplace_back(BroadcastOnlineUsers{});

    return actions;
}

std::vector<ServerAction> ServerEventDispatcher::handle(int fd, const event::Heartbeat&) {
    if (!sessionMgr_.exists(fd)) {
        std::cout << "[Server] Ignore heartbeat before login, fd=" << fd << std::endl;
        return {};   // â— ä¸å› PONG
    }

    sessionMgr_.updateHeartbeat(fd);
    return {SendHeartbeatAck{ .fd = fd }};
}

std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::RegisterPeer& ev)
{
    std::cout << "[Dispatcher] RegisterPeer from fd=" << fd
              << " lan=" << ev.lanIp
              << " vpn=" << ev.vpnIp
              << " port=" << ev.udpPort << std::endl;

    return {
        UpdatePeerInfo{
            .fd = fd,
            .lanIp = ev.lanIp,
            .vpnIp = ev.vpnIp,
            .udpPort = ev.udpPort
        }
    };
}


std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::SendTextToUser& ev)
{
    std::vector<ServerAction> actions;

    // 1. éªŒè¯å‘é€è€…æ˜¯å¦åœ¨çº¿
    if (!sessionMgr_.exists(fd)) {
        actions.emplace_back(SendError{
            .fd = fd,
            .reason = "You are not logged in, cannot send message"
        });
        return actions;
    }

    // 2. è·å–å‘é€è€…ç”¨æˆ·åï¼ˆä» Session ä¸­è¯»å–ï¼‰
    auto snapshot = sessionMgr_.snapshot();
    std::string from_user = snapshot.at(fd).user.username;

    // 3. æ ¹æ®ç›®æ ‡ç”¨æˆ·åæŸ¥æ‰¾ FD
    int target_fd = sessionMgr_.getFdByUsername(ev.target_user);

    if (target_fd == -1) {
        // ç›®æ ‡ç”¨æˆ·ä¸å­˜åœ¨ï¼šè¿”å›é”™è¯¯
        actions.emplace_back(SendUserNotFound{
            .fd = fd,
            .target_user = ev.target_user
        });
    } else {
        // ç›®æ ‡ç”¨æˆ·å­˜åœ¨ï¼šç”Ÿæˆå®šå‘è½¬å‘ Action
        actions.emplace_back(ForwardText{
            .target_fd = target_fd,
            .from_user = from_user,
            .content = ev.content,
            .sender_fd = fd
        });
    }

    std::cout << "[Dispatcher] SendTextToUser from fd=" << fd 
              << " user=" << from_user 
              << " target=" << ev.target_user 
              << " content=" << ev.content << std::endl;

    return actions;
}

========== ./dispatcher/ServerEventDispatcher.h ==========
Lines: 36

//ServerEventDispatcher.h
#pragma once
#include "./event/ServerEvent.h"

#include "./service/LoginService.h"
#include "./session/SessionManager.h"
#include "./service/ServerAction.h"
#include "./service/ServerActions.h"
#include "./service/CallService.h"

class ServerEventDispatcher {
public:
    ServerEventDispatcher(LoginService& loginService,
                          SessionManager& sessionMgr,
                          CallService& callService);

    std::vector<ServerAction> dispatch(int fd, const ServerEvent& event);

private:
    std::vector<ServerAction> handle(int fd, const event::CallRequest& ev);
    std::vector<ServerAction> handle(int fd, const event::CallAccept& ev);
    std::vector<ServerAction> handle(int fd, const event::CallReject& ev);
    std::vector<ServerAction> handle(int fd, const event::LoginRequest& ev);
    std::vector<ServerAction> handle(int fd, const event::ErrorEvent& ev);
    std::vector<ServerAction> handle(int fd, const event::Logout& ev);
    std::vector<ServerAction> handle(int fd, const event::Heartbeat& ev);
    std::vector<ServerAction> handle(int fd, const event::RegisterPeer& ev);
    std::vector<ServerAction> handle(int fd, const event::SendTextToUser& ev);
    std::vector<ServerAction> handle(int fd, const event::MediaOffer& ev);   
    std::vector<ServerAction> handle(int fd, const event::MediaAnswer& ev);  
        //std::vector<ServerAction> handle(int fd, const event::Logout&)

    LoginService&  loginService_;
    SessionManager& sessionMgr_;
    CallService& callService_;
};

========== ./domain/User.h ==========
Lines: 13

//User.h
#pragma once
#include <string>


namespace domain {

struct User {
    std::string username;
    int privilege = 0;
};

} // namespace domain

========== ./session/SessionManager.cpp ==========
Lines: 59

//SessionManager.cpp
#include "./session/SessionManager.h"
#include "iostream"
void SessionManager::login(int fd, const ClientInfo& info) {
    std::lock_guard<std::mutex> lock(mutex_);
    sessions_[fd] = info;
    std::cout << "[SessionManager] User logged in: FD=" << fd 
              << ", Username=" << info.user.username << std::endl;
}

void SessionManager::logout(int fd) {
    std::lock_guard<std::mutex> lock(mutex_);
    sessions_.erase(fd);
}

std::map<int, ClientInfo> SessionManager::snapshot() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return sessions_;
}

void SessionManager::updateHeartbeat(int fd) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = sessions_.find(fd);
    if (it != sessions_.end()) {
        it->second.lastHeartbeat = std::chrono::steady_clock::now();
        std::cout << "[SessionManager] Updated heartbeat: FD=" << fd << std::endl;
    }
    else {
         std::cout << "[SessionManager] Failed to update heartbeat: FD=" << fd << " does not exist" << std::endl;
    }
}

void SessionManager::updateNetInfo(int fd, const ClientNetInfo& net) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = sessions_.find(fd);
    if (it != sessions_.end()) {
        it->second.net = net;
        std::cout << "[SessionManager] Updated net info for fd=" << fd
                  << " lan=" << net.lanIp
                  << " vpn=" << net.vpnIp
                  << " port=" << net.udpPort << std::endl;
    }
}

bool SessionManager::exists(int fd) {
    std::lock_guard<std::mutex> lock(mutex_);
    return sessions_.count(fd) > 0;
}

int SessionManager::getFdByUsername(const std::string& username) const {
    std::lock_guard<std::mutex> lock(mutex_);
    for (const auto& [fd, info] : sessions_) {
        if (info.user.username == username) {
            return fd;
        }
    }
    return -1; // ç›®æ ‡ç”¨æˆ·ä¸å­˜åœ¨
}


========== ./session/SessionManager.h ==========
Lines: 34

//SessionManager.h
#pragma once
#include <map>
#include <mutex>
#include <string>
#include "./domain/User.h"

struct ClientNetInfo {
    std::string lanIp;
    std::string vpnIp;
    int udpPort = 0;
};

struct ClientInfo {
    domain::User user;
    bool online = false;
    std::chrono::steady_clock::time_point lastHeartbeat = std::chrono::steady_clock::now();
    ClientNetInfo net;
};

class SessionManager {
public:
    void login(int fd, const ClientInfo& info);
    void logout(int fd);
    std::map<int, ClientInfo> snapshot() const;

    void updateHeartbeat(int fd);
    void updateNetInfo(int fd, const ClientNetInfo& net);
    bool exists(int fd);
    int getFdByUsername(const std::string& username) const;
private:
    mutable std::mutex mutex_;
    std::map<int, ClientInfo> sessions_;
};

========== ./event/ServerEventFactory.h ==========
Lines: 9

//ServerEventFactory.h
#pragma once
#include <string>
#include "./event/ServerEvent.h"

class ServerEventFactory {
public:
    static ServerEvent makeEvent(const std::string& msg);
};

========== ./event/ServerEventFactory.cpp ==========
Lines: 74

// ServerEventFactory.cpp
#include "ServerEventFactory.h"
#include "protocol/protocol_text.h"
#include <stdexcept>


ServerEvent ServerEventFactory::makeEvent(const std::string& msg)
{
    std::string user, pwd;
    if (proto::parseLoginRequest(msg, user, pwd)) {
        return event::LoginRequest{
            .username = user,
            .password = pwd
        };
    }

    if (proto::parseLogout(msg)) {
        return event::Logout{};
    }    

    if (proto::parseHeartbeat(msg)) {
        return event::Heartbeat{};
    }

    std::string lan, vpn;
    int port;
    if (proto::parseRegisterPeer(msg, lan, vpn, port)) {
        return event::RegisterPeer{
            .lanIp = lan,
            .vpnIp = vpn,
            .udpPort = port
        };
    }

    // æ›¿æ¢åŸ parseSendText é€»è¾‘ï¼šè§£æå®¢æˆ·ç«¯çš„ SEND_TEXT æ¶ˆæ¯ï¼ˆtarget_user + contentï¼‰
    std::string target_user, content;
    if (proto::parseSendTextMsg(msg, target_user, content)) {
        return event::SendTextToUser{
            .target_user = target_user,
            .content = content,
            .from_user = "" // å‘é€è€…ç”¨æˆ·åç”± Dispatcher è¡¥å…¨
        };
    }
        
    std::string call_target;
    if (proto::parseCallRequest(msg, call_target)) {
        return event::CallRequest{.target_user = call_target};
    }

    if (proto::parseCallAccept(msg)) {
        return event::CallAccept{};
    }

    if (proto::parseCallReject(msg)) {
        return event::CallReject{};
    }

    // è§£æåª’ä½“Offerè¯·æ±‚
    std::string media_target;
    if (proto::parseMediaOffer(msg, media_target)) {
        return event::MediaOffer{.target_user = media_target};
    }

    // è§£æåª’ä½“Answerè¯·æ±‚
    if (proto::parseMediaAnswer(msg, media_target)) {
        return event::MediaAnswer{.target_user = media_target};
    }
    // â— å¦‚æœä½ æ„¿æ„ï¼Œå¯ä»¥æŠ›å¼‚å¸¸ / optional
    // fallback -> è¿”å› ErrorEvent
    return event::ErrorEvent{
        .rawMsg = msg,
        .reason = "Unknown or malformed command"
    };
}

========== ./event/ServerEvents.h ==========
Lines: 61

//ServerEvents.h
#pragma once
#include <string>




namespace event {

struct SendTextToUser {
    std::string target_user;  // å®¢æˆ·ç«¯æŒ‡å®šçš„ç›®æ ‡ç”¨æˆ·å
    std::string content;      // æ¶ˆæ¯å†…å®¹
    std::string from_user;    // å‘é€è€…ç”¨æˆ·åï¼ˆæœåŠ¡ç«¯ä» Session ä¸­è¡¥å…¨ï¼‰
};

struct ErrorEvent {
    std::string rawMsg;  // æ”¶åˆ°çš„åŸå§‹æ¶ˆæ¯
    std::string reason;  // è§£æå¤±è´¥åŸå› 
};

// ç™»å½•è¯·æ±‚
struct LoginRequest {
    std::string username;
    std::string password;
};

// ä»¥åå¯ä»¥éå¸¸è‡ªç„¶åœ°åŠ 
struct Logout {
};

struct Heartbeat {};  // å®¢æˆ·ç«¯å¿ƒè·³

struct RegisterPeer {
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};


struct Chat {
    std::string message;
};

struct CallRequest {
    std::string target_user;   // å‘¼å«çš„ç›®æ ‡ç”¨æˆ·å
};

struct CallAccept {};  // æ¥å—é€šè¯ï¼ˆæ— éœ€å¸¦targetï¼Œç”±CallSessionç»´æŠ¤ï¼‰
struct CallReject {};  // æ‹’ç»é€šè¯ï¼ˆåŒç†ï¼‰

// åª’ä½“åå•†ç›¸å…³äº‹ä»¶
struct MediaOffer {
    std::string target_user;  // åå•†çš„ç›®æ ‡ç”¨æˆ·
};

struct MediaAnswer {
    std::string target_user;  // åå•†çš„ç›®æ ‡ç”¨æˆ·
};


} // namespace event

========== ./event/ServerEvent.h ==========
Lines: 26

//ServerEvent.h
#pragma once
#include <variant>
#include "ServerEvents.h"




using ServerEvent = std::variant<
    event::ErrorEvent,
    event::LoginRequest,
    event::Logout,
    event::Heartbeat,
    event::RegisterPeer,
    event::SendTextToUser,
    event::CallRequest,
    event::CallAccept,
    event::CallReject,
    event::MediaOffer,
    event::MediaAnswer
    // event::Chat,
    // ä»¥ååªéœ€è¦å¾€è¿™é‡ŒåŠ 
>;




========== ./net/PacketCodec.h ==========
Lines: 38

#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 26

//CommandSocket.h
#pragma once
#include <functional>
#include <thread>
#include <atomic>
#include "./net/PacketCodec.h"

class CommandSocket {
public:
    using AcceptCallback = std::function<void(int)>;

    bool startListen(int port);
    void setAcceptCallback(AcceptCallback cb);
    void stop();
    void sendPacket(int fd, const std::string& payload);
    void sendMessage(const std::string& msg);
    void configureClientSocket(int clientfd);

    
private:
    void acceptThreadFunc();
    int listenfd_ = -1;
    std::thread acceptThread_;
    std::atomic<bool> running_{false};
    AcceptCallback acceptCb_;
};

========== ./net/CommandSocket.cpp ==========
Lines: 77

//CommandSocket.cpp
#include "./net/CommandSocket.h"
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/tcp.h>

bool CommandSocket::startListen(int port) {
    listenfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(listenfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(listenfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(listenfd_, 16) < 0) return false;

    running_ = true;
    acceptThread_ = std::thread(&CommandSocket::acceptThreadFunc, this);
    return true;
}

void CommandSocket::setAcceptCallback(AcceptCallback cb) {
    acceptCb_ = std::move(cb);
}

void CommandSocket::acceptThreadFunc() {
    while (running_) {
        int clientfd = accept(listenfd_, nullptr, nullptr);
        if (clientfd >= 0 && acceptCb_) {
            configureClientSocket(clientfd);
            acceptCb_(clientfd);   // â­ æŠ›ç»™ LoginServer
        }
    }
}

void CommandSocket::stop() {
    running_ = false;
    if (acceptThread_.joinable())
        acceptThread_.join();
    if (listenfd_ >= 0)
        close(listenfd_);
}

void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


void CommandSocket::sendMessage(const std::string& msg) {
    sendPacket(listenfd_,msg);
}


void CommandSocket::configureClientSocket(int clientfd) {
    // 1. è®¾ç½®æ¥æ”¶è¶…æ—¶
    struct timeval timeout{5, 0}; // 5ç§’
    setsockopt(clientfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    // 2. å¯ç”¨ TCP KeepAlive
    int opt = 1;
    setsockopt(clientfd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));

    // 3. KeepAlive å‚æ•°
    int keepidle = 10;   // 10 ç§’æ²¡æ•°æ®å¼€å§‹æ¢æµ‹
    int keepintvl = 3;   // æ¯ 3 ç§’æ¢æµ‹ä¸€æ¬¡
    int keepcnt = 3;     // æ¢æµ‹å¤±è´¥ 3 æ¬¡å°±åˆ¤å®šè¿æ¥æ­»
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle, sizeof(keepidle));
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPINTVL, &keepintvl, sizeof(keepintvl));
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPCNT, &keepcnt, sizeof(keepcnt));
}

========== ./protocol/protocol_types.h ==========
Lines: 25

//protocol_types.h
#pragma once


#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

}

========== ./protocol/protocol_text.h ==========
Lines: 47

//protocol_text.h

#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);
std::string makeLogout();
std::string makeHeartbeat();
std::string makeHeartbeatAck();   // â­ æ–°å¢
std::string makeSendText(const std::string& from_user, const std::string& content);
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content);
std::string makeCallIncoming(const std::string& from_user);       // é€šçŸ¥æ–°æ¥ç”µ
std::string makeCallAccepted(const std::string& peer);            // é€šçŸ¥é€šè¯æ¥é€š
std::string makeCallRejected(const std::string& peer);            // é€šçŸ¥é€šè¯è¢«æ‹’
// åª’ä½“åå•†æŒ‡ä»¤æ„å»ºå‡½æ•°
std::string makeMediaOfferResp(const std::string& peer, const std::string& lanIp, const std::string& vpnIp, int udpPort);
std::string makeMediaAnswerResp(const std::string& peer, const std::string& lanIp, const std::string& vpnIp, int udpPort);


// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);
bool parseLogout(const std::string& msg);
bool parseHeartbeat(const std::string& msg);
bool parseRegisterPeer(const std::string& msg,std::string& lan,std::string& vpn,int& port);
bool parseSendText(const std::string& msg, std::string& from_user, std::string& content);
bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content);
bool parseCallRequest(const std::string& msg, std::string& target_user); // è§£æå‘¼å«è¯·æ±‚
bool parseCallAccept(const std::string& msg);                            // è§£ææ¥å—å‘¼å«
bool parseCallReject(const std::string& msg);                            // è§£ææ‹’ç»å‘¼å«
// åª’ä½“åå•†æŒ‡ä»¤è§£æå‡½æ•°
bool parseMediaOffer(const std::string& msg, std::string& target_user);
bool parseMediaAnswer(const std::string& msg, std::string& target_user);





}

========== ./protocol/protocol_text.cpp ==========
Lines: 304

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */


// ========== é€šè¯åè®®æ„å»ºå‡½æ•° ==========
// æ„å»ºåª’ä½“Offerå›åº”ï¼ˆæœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼Œæºå¸¦å¯¹æ–¹IP/Portï¼‰
std::string makeMediaOfferResp(const std::string& peer, const std::string& lanIp, const std::string& vpnIp, int udpPort) {
    std::ostringstream oss;
    oss << CMD_MEDIA_OFFER_RESP << " " 
        << peer << " " 
        << lanIp << " " 
        << vpnIp << " " 
        << udpPort;
    return oss.str();
}

// æ„å»ºåª’ä½“Answerå›åº”ï¼ˆæœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼Œæºå¸¦å¯¹æ–¹IP/Portï¼‰
std::string makeMediaAnswerResp(const std::string& peer, const std::string& lanIp, const std::string& vpnIp, int udpPort) {
    std::ostringstream oss;
    oss << CMD_MEDIA_ANSWER_RESP << " " 
        << peer << " " 
        << lanIp << " " 
        << vpnIp << " " 
        << udpPort;
    return oss.str();
}

// æ„å»ºæœåŠ¡ç«¯é€šçŸ¥æ–°æ¥ç”µçš„æ¶ˆæ¯ï¼ˆCMD_CALL_INCOMING from_userï¼‰
std::string makeCallIncoming(const std::string& from_user) {
    std::ostringstream oss;
    oss << CMD_CALL_INCOMING << " " << from_user;
    return oss.str();
}

// æ„å»ºæœåŠ¡ç«¯é€šçŸ¥é€šè¯æ¥é€šçš„æ¶ˆæ¯ï¼ˆCMD_CALL_ACCEPTED peerï¼‰
std::string makeCallAccepted(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_CALL_ACCEPTED << " " << peer;
    return oss.str();
}

// æ„å»ºæœåŠ¡ç«¯é€šçŸ¥é€šè¯è¢«æ‹’çš„æ¶ˆæ¯ï¼ˆCMD_CALL_REJECTED peerï¼‰
std::string makeCallRejected(const std::string& peer) {
    std::ostringstream oss;
    oss << CMD_CALL_REJECTED << " " << peer;
    return oss.str();
}

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    return oss.str();
}

std::string makeLogout() {
    return CMD_LOGOUT;
}

std::string makeHeartbeat() {
    return CMD_HEARTBEAT;
}

std::string makeHeartbeatAck() {
    return CMD_HEARTBEAT_ACK;  // "PONG"
}

// æ„å»ºå®¢æˆ·ç«¯å‘é€çš„æ–‡æœ¬æ¶ˆæ¯ï¼ˆCMD_SEND_TEXTï¼‰
std::string makeSendText(const std::string& from_user, const std::string& content) {
    std::ostringstream oss;
    oss << CMD_SEND_TEXT << " " << from_user << " " << content;
    return oss.str();
}

// æ„å»ºæœåŠ¡ç«¯è½¬å‘çš„æ–‡æœ¬æ¶ˆæ¯ï¼ˆCMD_FORWARD_TEXTï¼‰
std::string makeForwardTextMsg(const std::string& from_user, const std::string& content) {
    std::ostringstream oss;
    oss << CMD_FORWARD_TEXT << " " << from_user << " " << content;
    return oss.str();
}



/* ================= parse ================= */

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}


bool parseLogout(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_LOGOUT;
}

bool parseHeartbeat(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_HEARTBEAT;
}

bool parseRegisterPeer(
    const std::string& msg,
    std::string& lan,
    std::string& vpn,
    int& port)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_REGISTER_PEER) return false;

    iss >> lan >> vpn >> port;
    return !lan.empty() && port > 0;
}

// è§£æå®¢æˆ·ç«¯å‘é€çš„æ–‡æœ¬æ¶ˆæ¯
bool parseSendText(const std::string& msg, std::string& from_user, std::string& content) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_SEND_TEXT) return false;
    
    iss >> from_user;
    // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯ä½“ï¼ˆæ”¯æŒç©ºæ ¼ï¼‰
    std::getline(iss >> std::ws, content);
    return !from_user.empty() && !content.empty();
}

// è§£æå®¢æˆ·ç«¯å‘é€çš„å®šå‘æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼šSEND_TEXT target_user contentï¼‰
    bool parseSendTextMsg(const std::string& msg, std::string& target_user, std::string& content) {
        std::istringstream iss(msg);
        std::string cmd;
        iss >> cmd;

        if (cmd != CMD_SEND_TEXT) return false;

        // è¯»å–ç›®æ ‡ç”¨æˆ·å
        iss >> target_user;
        // è¯»å–å‰©ä½™æ‰€æœ‰å†…å®¹ä½œä¸ºæ¶ˆæ¯ï¼ˆæ”¯æŒå«ç©ºæ ¼çš„æ¶ˆæ¯ï¼‰
        std::getline(iss >> std::ws, content);
        return !target_user.empty() && !content.empty();
    }

// è§£æå®¢æˆ·ç«¯çš„å‘¼å«è¯·æ±‚ï¼ˆCMD_CALL target_userï¼‰
bool parseCallRequest(const std::string& msg, std::string& target_user) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_CALL) return false;
    iss >> target_user;
    return !target_user.empty();
}

// è§£æå®¢æˆ·ç«¯çš„æ¥å—å‘¼å«è¯·æ±‚ï¼ˆCMD_CALL_ACCEPTï¼‰
bool parseCallAccept(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_CALL_ACCEPT;
}

// è§£æå®¢æˆ·ç«¯çš„æ‹’ç»å‘¼å«è¯·æ±‚ï¼ˆCMD_CALL_REJECTï¼‰
bool parseCallReject(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_CALL_REJECT;
}

// è§£æå®¢æˆ·ç«¯çš„åª’ä½“Offerè¯·æ±‚
bool parseMediaOffer(const std::string& msg, std::string& target_user) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_MEDIA_OFFER) return false;
    iss >> target_user;
    return !target_user.empty();
}

// è§£æå®¢æˆ·ç«¯çš„åª’ä½“Answerè¯·æ±‚
bool parseMediaAnswer(const std::string& msg, std::string& target_user) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    if (cmd != CMD_MEDIA_ANSWER) return false;
    iss >> target_user;
    return !target_user.empty();
}

} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 45

// proto::*
// âš ï¸ PROTOCOL DTO â€” do NOT use as domain model
// âš ï¸ ä»…ç”¨äºåè®®åºåˆ—åŒ– / ååºåˆ—åŒ–
// âš ï¸ ç¦æ­¢åœ¨ä¸šåŠ¡å±‚ã€äº‹ä»¶å±‚ã€æœåŠ¡å±‚ä¸­ä½œä¸ºä¸šåŠ¡æ¨¡å‹ä½¿ç”¨

//protocol_common.h

#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN        = "LOGIN";
constexpr const char* CMD_LOGIN_OK     = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL   = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS = "ONLINE_USERS";
constexpr const char* CMD_LOGOUT       = "LOGOUT";
constexpr const char* CMD_HEARTBEAT = "PING";
constexpr const char* CMD_HEARTBEAT_ACK = "PONG";
constexpr const char* CMD_REGISTER_PEER = "REGISTER_PEER";
constexpr const char* CMD_SEND_TEXT     = "SEND_TEXT";       // å®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šå‘é€æ–‡æœ¬
constexpr const char* CMD_FORWARD_TEXT  = "FORWARD_TEXT"; // æœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šè½¬å‘æ–‡æœ¬

constexpr const char* CMD_CALL         = "CALL";         // å®¢æˆ·ç«¯å‘èµ·å‘¼å«
constexpr const char* CMD_CALL_ACCEPT  = "CALL_ACCEPT";  // å®¢æˆ·ç«¯æ¥å—å‘¼å«
constexpr const char* CMD_CALL_REJECT  = "CALL_REJECT";  // å®¢æˆ·ç«¯æ‹’ç»å‘¼å«
constexpr const char* CMD_CALL_INCOMING = "CALL_INCOMING"; // æœåŠ¡ç«¯é€šçŸ¥æ–°æ¥ç”µ
constexpr const char* CMD_CALL_ACCEPTED = "CALL_ACCEPTED"; // æœåŠ¡ç«¯é€šçŸ¥é€šè¯æ¥é€š
constexpr const char* CMD_CALL_REJECTED = "CALL_REJECTED"; // æœåŠ¡ç«¯é€šçŸ¥é€šè¯è¢«æ‹’

// åª’ä½“åå•†æŒ‡ä»¤
constexpr const char* CMD_MEDIA_OFFER  = "MEDIA_OFFER";   // å®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šå‘èµ·åª’ä½“åå•†
constexpr const char* CMD_MEDIA_ANSWER = "MEDIA_ANSWER";  // å®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šå›åº”åª’ä½“åå•†
constexpr const char* CMD_MEDIA_OFFER_RESP  = "MEDIA_OFFER_RESP";  // æœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šä¸‹å‘å¯¹æ–¹IPï¼ˆOfferå›åº”ï¼‰
constexpr const char* CMD_MEDIA_ANSWER_RESP = "MEDIA_ANSWER_RESP"; // æœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šä¸‹å‘å¯¹æ–¹IPï¼ˆAnswerå›åº”

// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}


=====================================
Total files: 27
Total lines: 2117
