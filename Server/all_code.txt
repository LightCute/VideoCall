========== å·¥ç¨‹ç›®å½•ç»“æ„ï¼ˆä»…å«.h/.cppï¼‰==========

ğŸ“‚ .:
  â””â”€ server_main.cpp

ğŸ“‚ ./util:
  â””â”€ ThreadPool.cpp
  â””â”€ ThreadPool.h

ğŸ“‚ ./core:
  â””â”€ LoginServer.cpp
  â””â”€ LoginServer.h

ğŸ“‚ ./service:
  â””â”€ LoginService.cpp
  â””â”€ LoginService.h
  â””â”€ ServerAction.h
  â””â”€ ServerActions.h

ğŸ“‚ ./dispatcher:
  â””â”€ ServerEventDispatcher.cpp
  â””â”€ ServerEventDispatcher.h

ğŸ“‚ ./domain:
  â””â”€ User.h

ğŸ“‚ ./session:
  â””â”€ SessionManager.cpp
  â””â”€ SessionManager.h

ğŸ“‚ ./event:
  â””â”€ ServerEvent.h
  â””â”€ ServerEventFactory.cpp
  â””â”€ ServerEventFactory.h
  â””â”€ ServerEvents.h

ğŸ“‚ ./net:
  â””â”€ CommandSocket.cpp
  â””â”€ CommandSocket.h
  â””â”€ PacketCodec.h

ğŸ“‚ ./protocol:
  â””â”€ protocol_common.h
  â””â”€ protocol_text.cpp
  â””â”€ protocol_text.h
  â””â”€ protocol_types.h

==================================================
========== æ‰€æœ‰.h/.cppæ–‡ä»¶å†…å®¹ ==========


========== ./server_main.cpp ==========
Lines: 15

//server_main.cpp
#include "./core/LoginServer.h"
#include <iostream>
#include <unistd.h>

int main() {
    LoginServer server;
    if (!server.start(6001)) {
        std::cerr << "Server start failed\n";
        return -1;
    }

    std::cout << "Login server running on port 6001\n";
    while (true) sleep(1);
}

========== ./util/ThreadPool.cpp ==========
Lines: 52

// ThreadPool.cpp
#include "./util/ThreadPool.h"

ThreadPool::~ThreadPool() {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        stop_ = true;
    }

    cv_.notify_all();

    for (auto& t : workers_) {
        if (t.joinable())
            t.join();
    }
}


ThreadPool::ThreadPool(size_t workerCount) {
    for (size_t i = 0; i < workerCount; ++i) {
        workers_.emplace_back(&ThreadPool::workerLoop, this);
    }
}

void ThreadPool::post(std::function<void()> task) {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        tasks_.push(std::move(task));
    }
    cv_.notify_one();
}

void ThreadPool::workerLoop() {
    while (true) {
        std::function<void()> task;

        {
            std::unique_lock<std::mutex> lock(mutex_);
            cv_.wait(lock, [&] {
                return stop_ || !tasks_.empty();
            });

            if (stop_ && tasks_.empty())
                return;

            task = std::move(tasks_.front());
            tasks_.pop();
        }

        task();  // â­ çœŸæ­£æ‰§è¡Œä»»åŠ¡
    }
}

========== ./util/ThreadPool.h ==========
Lines: 29

// ThreadPool.h
#pragma once
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <functional>

class ThreadPool {
public:
    explicit ThreadPool(size_t workerCount);
    ~ThreadPool();

    // å‘çº¿ç¨‹æ± æŠ•é€’ä»»åŠ¡
    void post(std::function<void()> task);

private:
    // æ¯ä¸ª worker çº¿ç¨‹æ‰§è¡Œçš„å‡½æ•°
    void workerLoop();

private:
    std::vector<std::thread> workers_;          // å›ºå®šæ•°é‡çº¿ç¨‹
    std::queue<std::function<void()>> tasks_;   // ä»»åŠ¡é˜Ÿåˆ—

    std::mutex mutex_;
    std::condition_variable cv_;
    bool stop_ = false;
};

========== ./core/LoginServer.cpp ==========
Lines: 214

//LoginServer.cpp
// LoginServer: protocol â†” domain çš„è¾¹ç•Œå±‚

#include "./core/LoginServer.h"

// å®ç° LoginServer æ„é€ å‡½æ•°
LoginServer::LoginServer() 
    : dispatcher_(loginService_, sessionMgr_)  // æ‰‹åŠ¨åˆå§‹åŒ– dispatcher_ï¼Œä¼ å…¥æ‰€éœ€ä¸¤ä¸ªå‚æ•°
{
    // æ„é€ å‡½æ•°ä½“å¯ç•™ç©ºï¼ˆå¦‚éœ€å…¶ä»–åˆå§‹åŒ–é€»è¾‘å¯è¡¥å……ï¼‰
}
LoginServer::~LoginServer() {
    listener_.stop();      // åœæ­¢ accept çº¿ç¨‹
    // ThreadPool ææ„ä¼šè‡ªåŠ¨ join
}


bool LoginServer::start(int port) {
    listener_.setAcceptCallback(
        [this](int clientfd) {
            onAccept(clientfd);
        }
    );
    bool ok = listener_.startListen(port);

    if (ok) {
        startHeartbeatMonitor(); // âš¡ å¯åŠ¨å¿ƒè·³ç›‘æµ‹
    }

    return ok;
}

void LoginServer::startHeartbeatMonitor() {
    std::thread([this] {
        while (true) {
            auto snapshot = sessionMgr_.snapshot();
            auto now = std::chrono::steady_clock::now();

            for (auto& [fd, info] : snapshot) {
                auto dur = std::chrono::duration_cast<std::chrono::seconds>(
                    now - info.lastHeartbeat
                ).count();

                if (dur > 15) { // è¶…è¿‡ 15 ç§’æ²¡å¿ƒè·³å°±ä¸‹çº¿
                    std::cout << "[Server] heartbeat timeout fd=" << fd << std::endl;
                    sessionMgr_.logout(fd);
                    close(fd);

                    // å¹¿æ’­æ–°çš„åœ¨çº¿ç”¨æˆ·åˆ—è¡¨
                    auto onlineSnapshot = sessionMgr_.snapshot();
                    proto::OnlineUsers users;
                    for (auto& [fd2, info2] : onlineSnapshot) {
                        users.users.push_back({info2.user.username, info2.user.privilege});
                    }
                    auto payload = proto::makeOnlineUsers(users);
                    for (auto& [fd2, _] : onlineSnapshot) {
                        listener_.sendPacket(fd2, payload);
                    }
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }).detach();
}


void LoginServer::onAccept(int clientfd) {
    std::cout << "[Server] new client fd=" << clientfd << std::endl;
    
    pool_.post([this, clientfd] {
        clientThread(clientfd);
    });
}

void LoginServer::clientThread(int clientfd) {
    std::vector<char> recvBuffer;
    char buf[1024];


    
    while (true) {
        int n = recv(clientfd, buf, sizeof(buf), 0);
        if (n <= 0) {
            break;}

        recvBuffer.insert(recvBuffer.end(), buf, buf + n);

        std::string payload;
        while (PacketCodec::tryDecode(recvBuffer, payload)) {
            onMessage(clientfd, payload);
        }
    }

    

    // å®¢æˆ·ç«¯æ–­å¼€å¤„ç†
    sessionMgr_.logout(clientfd);

    auto snapshot = sessionMgr_.snapshot();
    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        users.users.push_back({info.user.username, info.user.privilege});
    }
    auto payload = proto::makeOnlineUsers(users);
    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }

    close(clientfd);
    std::cout << "[Server] client disconnected fd=" << clientfd << std::endl;
}

void LoginServer::onMessage(int fd, const std::string& msg)
{
    ServerEvent event = ServerEventFactory::makeEvent(msg);

    auto actions = dispatcher_.dispatch(fd, event);

    for (auto& act : actions) {
        std::visit([this](auto&& a) {
            handle(a);
        }, act);
    }
}


// LoginServer.cpp

void LoginServer::handle(const SendLoginOk& a)
{
    proto::UserInfo u;
    u.username = a.username;
    u.privilege = a.privilege;

    auto payload = proto::makeLoginOk(u, "welcome");
    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const SendLoginFail& a)
{
    auto payload = proto::makeLoginFail(a.reason);
    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const BroadcastOnlineUsers&)
{
    auto snapshot = sessionMgr_.snapshot();

    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        const domain::User& u = info.user;

        users.users.push_back(proto::UserInfo{
            u.username,
            u.privilege
        });
    }


    auto payload = proto::makeOnlineUsers(users);

    std::cout << "Broadcast: " << payload << std::endl;
    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }
}

void LoginServer::handle(const SendError& a)
{
    auto payload = (a.reason);
    std::cout << "Error: " << payload << std::endl;

    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const BroadcastLogout&)
{
    auto snapshot = sessionMgr_.snapshot();

    proto::OnlineUsers users;
    for (auto& [fd, info] : snapshot) {
        const domain::User& u = info.user;
        users.users.push_back({u.username, u.privilege});
    }

    auto payload = proto::makeOnlineUsers(users);

    for (auto& [fd, _] : snapshot) {
        listener_.sendPacket(fd, payload);
    }
}

void LoginServer::handle(const SendHeartbeatAck& a)
{
    std::cout << "[Server] Send PONG to fd= " << a.fd << std::endl;
    std::string payload = proto::makeHeartbeatAck(); // â­ PONG

    listener_.sendPacket(a.fd, payload);
}

void LoginServer::handle(const UpdatePeerInfo& a)
{
    ClientNetInfo net{
        .lanIp = a.lanIp,
        .vpnIp = a.vpnIp,
        .udpPort = a.udpPort
    };

    sessionMgr_.updateNetInfo(a.fd, net);

    std::cout << "[Server] Registered peer info for fd=" << a.fd << std::endl;
}


========== ./core/LoginServer.h ==========
Lines: 51

//LoginServer.h
#pragma once
#include <thread>
#include <mutex>
#include <map>
#include <iostream>
#include <sstream>


#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "./util/ThreadPool.h"
#include "./net/PacketCodec.h"
#include "./net/CommandSocket.h"
#include "./event/ServerEvent.h"
#include "./event/ServerEventFactory.h"
#include "./session/SessionManager.h"
#include "./dispatcher/ServerEventDispatcher.h"
#include "./service/ServerAction.h"
#include "./protocol/protocol_text.h"
#include "./protocol/protocol_common.h"

class LoginServer {
public:
    LoginServer();
    ~LoginServer();
    bool start(int port);

private:
    void onAccept(int clientfd);
    void clientThread(int clientfd);
    void onMessage(int clientfd, const std::string& msg);
    void handleLogin(int fd, ServerEvent& event);
    void startHeartbeatMonitor();
    void handle(const SendLoginOk&);
    void handle(const SendLoginFail&);
    void handle(const BroadcastOnlineUsers&);
    void handle(const SendError&);
    void handle(const BroadcastLogout&);
    void handle(const SendHeartbeatAck& a);
    void handle(const UpdatePeerInfo&);


    CommandSocket listener_;
    ThreadPool pool_{8};
    SessionManager sessionMgr_;
    ServerEventDispatcher dispatcher_;
    LoginService loginService_;
};

========== ./service/ServerActions.h ==========
Lines: 50

// Service/ServerActions.h
#pragma once
#include <string>
#include <vector>
#include <map>
//#include "SessionManager.h"

// å•æ’­ï¼šç™»å½•æˆåŠŸ
struct SendLoginOk {
    int fd;
    std::string username;
    int privilege;
};

// å•æ’­ï¼šç™»å½•å¤±è´¥
struct SendLoginFail {
    int fd;
    std::string reason;
};

struct SendError {
    int fd;
    std::string reason;
};

// å¹¿æ’­ï¼šåœ¨çº¿ç”¨æˆ·åˆ—è¡¨
struct BroadcastOnlineUsers {
};

struct BroadcastLogout {
};

// æ–°å¢ï¼šæœåŠ¡å™¨å›åº”å¿ƒè·³
struct SendHeartbeatAck {
    int fd;
};

struct UpdatePeerInfo {
    int fd;
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};



// æœªæ¥å¯æ— é™åŠ 
// struct KickUser { int fd; };
// struct ForceLogout { int fd; };
// struct SendChat { int from; std::string msg; };

========== ./service/LoginService.h ==========
Lines: 22

//LoginService.h
#pragma once
#include <string>

#include "./event/ServerEvent.h" // for proto::LoginRequest





struct LoginResult {
    bool success = false;
    std::string username;
    int privilege = 0;
    std::string reason;   // å¤±è´¥åŸå› 
    //UserInfo user;
};

class LoginService {
public:
    LoginResult handleLogin(const event::LoginRequest& req);
};

========== ./service/LoginService.cpp ==========
Lines: 35

//LoginService
#include "LoginService.h"

LoginResult LoginService::handleLogin(const event::LoginRequest& req) {
    LoginResult r;

    if (req.username == "admin" && req.password == "123") {
        r.success = true;
        r.username = "admin";
        r.privilege = 10;
    } 
    else if (req.username == "user_a" && req.password == "123") {
        r.success = true;
        r.username = "user_a";
        r.privilege = 10;
    } 
    else if (req.username == "user_b" && req.password == "123") {
        r.success = true;
        r.username = "user_b";
        r.privilege = 10;
    }     
    else if (req.username == "user_c" && req.password == "123") {
        r.success = true;
        r.username = "user_c";
        r.privilege = 10;
    }     


    else {
        r.success = false;
        r.reason = "invalid username or password";
    }

    return r;
}

========== ./service/ServerAction.h ==========
Lines: 14

// Service/ServerAction.h
#pragma once
#include <variant>
#include "ServerActions.h"

using ServerAction = std::variant<
    SendError,
    SendLoginOk,
    SendLoginFail,
    BroadcastOnlineUsers,
    BroadcastLogout,
    SendHeartbeatAck,
    UpdatePeerInfo
>;

========== ./dispatcher/ServerEventDispatcher.cpp ==========
Lines: 107

//ServerEventDispatcher.cpp
#include "./dispatcher/ServerEventDispatcher.h"
#include "iostream"


ServerEventDispatcher::ServerEventDispatcher(
    LoginService& loginService,
    SessionManager& sessionMgr)
    : loginService_(loginService),
      sessionMgr_(sessionMgr)
{}


std::vector<ServerAction>
ServerEventDispatcher::dispatch(int fd, const ServerEvent& event)
{
    return std::visit([&](auto&& ev) {
        return handle(fd, ev);
    }, event);
}


// ç™»å½•
std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::LoginRequest& ev)
{
    std::vector<ServerAction> actions;

    LoginResult r = loginService_.handleLogin(ev);

    if (r.success) {
        sessionMgr_.login(fd, {
            domain::User{ r.username, r.privilege },
            true
        });

        actions.emplace_back(SendLoginOk{
            .fd = fd,
            .username = r.username,
            .privilege = r.privilege
        });

        actions.emplace_back(BroadcastOnlineUsers{
            
        });
    } else {
        actions.emplace_back(SendLoginFail{
            .fd = fd,
            .reason = r.reason
        });
    }

    return actions;
}


std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::ErrorEvent& ev)
{
    std::vector<ServerAction> actions;
    
    actions.emplace_back(SendError{
        .fd = fd,
        .reason = ev.reason +ev.rawMsg
    });

    return actions;
}

std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::Logout& ev)
{
    std::vector<ServerAction> actions;

    // å…³é”®ï¼šå…ˆä» SessionManager é‡Œç§»é™¤
    sessionMgr_.logout(fd);

    // ç„¶åå¹¿æ’­æ–°çš„åœ¨çº¿åˆ—è¡¨
    actions.emplace_back(BroadcastOnlineUsers{});

    return actions;
}

std::vector<ServerAction> ServerEventDispatcher::handle(int fd, const event::Heartbeat&) {
    std::cout << "[Server] Received PING from fd= " << fd << std::endl;
    sessionMgr_.updateHeartbeat(fd);  // æ›´æ–°æ—¶é—´æˆ³
    return {SendHeartbeatAck{ .fd = fd }}; // å¿ƒè·³ä¸è§¦å‘Ack
}

std::vector<ServerAction>
ServerEventDispatcher::handle(int fd, const event::RegisterPeer& ev)
{
    std::cout << "[Dispatcher] RegisterPeer from fd=" << fd
              << " lan=" << ev.lanIp
              << " vpn=" << ev.vpnIp
              << " port=" << ev.udpPort << std::endl;

    return {
        UpdatePeerInfo{
            .fd = fd,
            .lanIp = ev.lanIp,
            .vpnIp = ev.vpnIp,
            .udpPort = ev.udpPort
        }
    };
}


========== ./dispatcher/ServerEventDispatcher.h ==========
Lines: 29

//ServerEventDispatcher.h
#pragma once
#include "./event/ServerEvent.h"

#include "./service/LoginService.h"
#include "./session/SessionManager.h"
#include "./service/ServerAction.h"
#include "./service/ServerActions.h"


class ServerEventDispatcher {
public:
    ServerEventDispatcher(LoginService& loginService,
                          SessionManager& sessionMgr);

    std::vector<ServerAction> dispatch(int fd, const ServerEvent& event);

private:
    std::vector<ServerAction> handle(int fd, const event::LoginRequest& ev);
    std::vector<ServerAction> handle(int fd, const event::ErrorEvent& ev);
    std::vector<ServerAction> handle(int fd, const event::Logout& ev);
    std::vector<ServerAction> handle(int fd, const event::Heartbeat& ev);
    std::vector<ServerAction> handle(int fd, const event::RegisterPeer& ev);

    //std::vector<ServerAction> handle(int fd, const event::Logout&)

    LoginService&  loginService_;
    SessionManager& sessionMgr_;
};

========== ./domain/User.h ==========
Lines: 13

//User.h
#pragma once
#include <string>


namespace domain {

struct User {
    std::string username;
    int privilege = 0;
};

} // namespace domain

========== ./session/SessionManager.cpp ==========
Lines: 44

//SessionManager.cpp
#include "./session/SessionManager.h"
#include "iostream"
void SessionManager::login(int fd, const ClientInfo& info) {
    std::lock_guard<std::mutex> lock(mutex_);
    sessions_[fd] = info;
    std::cout << "[SessionManager] User logged in: FD=" << fd 
              << ", Username=" << info.user.username << std::endl;
}

void SessionManager::logout(int fd) {
    std::lock_guard<std::mutex> lock(mutex_);
    sessions_.erase(fd);
}

std::map<int, ClientInfo> SessionManager::snapshot() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return sessions_;
}

void SessionManager::updateHeartbeat(int fd) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = sessions_.find(fd);
    if (it != sessions_.end()) {
        it->second.lastHeartbeat = std::chrono::steady_clock::now();
        std::cout << "[SessionManager] Updated heartbeat: FD=" << fd << std::endl;
    }
    else {
         std::cout << "[SessionManager] Failed to update heartbeat: FD=" << fd << " does not exist" << std::endl;
    }
}

void SessionManager::updateNetInfo(int fd, const ClientNetInfo& net) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = sessions_.find(fd);
    if (it != sessions_.end()) {
        it->second.net = net;
        std::cout << "[SessionManager] Updated net info for fd=" << fd
                  << " lan=" << net.lanIp
                  << " vpn=" << net.vpnIp
                  << " port=" << net.udpPort << std::endl;
    }
}


========== ./session/SessionManager.h ==========
Lines: 32

//SessionManager.h
#pragma once
#include <map>
#include <mutex>
#include <string>
#include "./domain/User.h"

struct ClientNetInfo {
    std::string lanIp;
    std::string vpnIp;
    int udpPort = 0;
};

struct ClientInfo {
    domain::User user;
    bool online = false;
    std::chrono::steady_clock::time_point lastHeartbeat = std::chrono::steady_clock::now();
    ClientNetInfo net;
};

class SessionManager {
public:
    void login(int fd, const ClientInfo& info);
    void logout(int fd);
    std::map<int, ClientInfo> snapshot() const;

    void updateHeartbeat(int fd);
    void updateNetInfo(int fd, const ClientNetInfo& net);
private:
    mutable std::mutex mutex_;
    std::map<int, ClientInfo> sessions_;
};

========== ./event/ServerEventFactory.h ==========
Lines: 9

//ServerEventFactory.h
#pragma once
#include <string>
#include "./event/ServerEvent.h"

class ServerEventFactory {
public:
    static ServerEvent makeEvent(const std::string& msg);
};

========== ./event/ServerEventFactory.cpp ==========
Lines: 41

// ServerEventFactory.cpp
#include "ServerEventFactory.h"
#include "protocol/protocol_text.h"
#include <stdexcept>


ServerEvent ServerEventFactory::makeEvent(const std::string& msg)
{
    std::string user, pwd;
    if (proto::parseLoginRequest(msg, user, pwd)) {
        return event::LoginRequest{
            .username = user,
            .password = pwd
        };
    }

    if (proto::parseLogout(msg)) {
        return event::Logout{};
    }    

    if (proto::parseHeartbeat(msg)) {
        return event::Heartbeat{};
    }

    std::string lan, vpn;
    int port;
    if (proto::parseRegisterPeer(msg, lan, vpn, port)) {
        return event::RegisterPeer{
            .lanIp = lan,
            .vpnIp = vpn,
            .udpPort = port
        };
    }
    
    // â— å¦‚æœä½ æ„¿æ„ï¼Œå¯ä»¥æŠ›å¼‚å¸¸ / optional
    // fallback -> è¿”å› ErrorEvent
    return event::ErrorEvent{
        .rawMsg = msg,
        .reason = "Unknown or malformed command"
    };
}

========== ./event/ServerEvents.h ==========
Lines: 38

//ServerEvents.h
#pragma once
#include <string>




namespace event {

struct ErrorEvent {
    std::string rawMsg;  // æ”¶åˆ°çš„åŸå§‹æ¶ˆæ¯
    std::string reason;  // è§£æå¤±è´¥åŸå› 
};

// ç™»å½•è¯·æ±‚
struct LoginRequest {
    std::string username;
    std::string password;
};

// ä»¥åå¯ä»¥éå¸¸è‡ªç„¶åœ°åŠ 
struct Logout {
};

struct Heartbeat {};  // å®¢æˆ·ç«¯å¿ƒè·³

struct RegisterPeer {
    std::string lanIp;
    std::string vpnIp;
    int udpPort;
};


struct Chat {
    std::string message;
};

} // namespace event

========== ./event/ServerEvent.h ==========
Lines: 20

//ServerEvent.h
#pragma once
#include <variant>
#include "ServerEvents.h"




using ServerEvent = std::variant<
    event::ErrorEvent,
    event::LoginRequest,
    event::Logout,
    event::Heartbeat,
    event::RegisterPeer
    // event::Chat,
    // ä»¥ååªéœ€è¦å¾€è¿™é‡ŒåŠ 
>;




========== ./net/PacketCodec.h ==========
Lines: 38

#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

class PacketCodec {
public:
    // æ‰“åŒ…ï¼špayload â†’ å¸¦é•¿åº¦å¤´çš„äºŒè¿›åˆ¶æ•°æ®
    static std::vector<char> encode(const std::string& payload) {
        uint32_t len = payload.size();
        uint32_t netLen = htonl(len);

        std::vector<char> buf(sizeof(netLen) + len);
        std::memcpy(buf.data(), &netLen, sizeof(netLen));
        std::memcpy(buf.data() + sizeof(netLen), payload.data(), len);
        return buf;
    }

    // å°è¯•è§£åŒ…ï¼šä» buffer ä¸­æå–ä¸€ä¸ªå®Œæ•´ payload
    // æˆåŠŸè¿”å› trueï¼Œå¹¶å¡«å…… outPayload
    static bool tryDecode(std::vector<char>& buffer, std::string& outPayload) {
        if (buffer.size() < 4)
            return false;

        uint32_t netLen;
        std::memcpy(&netLen, buffer.data(), 4);
        uint32_t len = ntohl(netLen);

        if (buffer.size() < 4 + len)
            return false;

        outPayload.assign(buffer.data() + 4, len);
        buffer.erase(buffer.begin(), buffer.begin() + 4 + len);
        return true;
    }
};

========== ./net/CommandSocket.h ==========
Lines: 26

//CommandSocket.h
#pragma once
#include <functional>
#include <thread>
#include <atomic>
#include "./net/PacketCodec.h"

class CommandSocket {
public:
    using AcceptCallback = std::function<void(int)>;

    bool startListen(int port);
    void setAcceptCallback(AcceptCallback cb);
    void stop();
    void sendPacket(int fd, const std::string& payload);
    void sendMessage(const std::string& msg);
    void configureClientSocket(int clientfd);

    
private:
    void acceptThreadFunc();
    int listenfd_ = -1;
    std::thread acceptThread_;
    std::atomic<bool> running_{false};
    AcceptCallback acceptCb_;
};

========== ./net/CommandSocket.cpp ==========
Lines: 77

//CommandSocket.cpp
#include "./net/CommandSocket.h"
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/tcp.h>

bool CommandSocket::startListen(int port) {
    listenfd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd_ < 0) return false;

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    int opt = 1;
    setsockopt(listenfd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    if (bind(listenfd_, (sockaddr*)&addr, sizeof(addr)) < 0) return false;
    if (listen(listenfd_, 16) < 0) return false;

    running_ = true;
    acceptThread_ = std::thread(&CommandSocket::acceptThreadFunc, this);
    return true;
}

void CommandSocket::setAcceptCallback(AcceptCallback cb) {
    acceptCb_ = std::move(cb);
}

void CommandSocket::acceptThreadFunc() {
    while (running_) {
        int clientfd = accept(listenfd_, nullptr, nullptr);
        if (clientfd >= 0 && acceptCb_) {
            configureClientSocket(clientfd);
            acceptCb_(clientfd);   // â­ æŠ›ç»™ LoginServer
        }
    }
}

void CommandSocket::stop() {
    running_ = false;
    if (acceptThread_.joinable())
        acceptThread_.join();
    if (listenfd_ >= 0)
        close(listenfd_);
}

void CommandSocket::sendPacket(int fd, const std::string& payload) {
    auto data = PacketCodec::encode(payload);
    send(fd, data.data(), data.size(), 0);
}


void CommandSocket::sendMessage(const std::string& msg) {
    sendPacket(listenfd_,msg);
}


void CommandSocket::configureClientSocket(int clientfd) {
    // 1. è®¾ç½®æ¥æ”¶è¶…æ—¶
    struct timeval timeout{5, 0}; // 5ç§’
    setsockopt(clientfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    // 2. å¯ç”¨ TCP KeepAlive
    int opt = 1;
    setsockopt(clientfd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));

    // 3. KeepAlive å‚æ•°
    int keepidle = 10;   // 10 ç§’æ²¡æ•°æ®å¼€å§‹æ¢æµ‹
    int keepintvl = 3;   // æ¯ 3 ç§’æ¢æµ‹ä¸€æ¬¡
    int keepcnt = 3;     // æ¢æµ‹å¤±è´¥ 3 æ¬¡å°±åˆ¤å®šè¿æ¥æ­»
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle, sizeof(keepidle));
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPINTVL, &keepintvl, sizeof(keepintvl));
    setsockopt(clientfd, IPPROTO_TCP, TCP_KEEPCNT, &keepcnt, sizeof(keepcnt));
}

========== ./protocol/protocol_types.h ==========
Lines: 25

//protocol_types.h
#pragma once


#include <string>
#include <vector>

namespace proto {

struct UserInfo {
    std::string username;
    int privilege = 0;
};

struct LoginResponse {
    bool success = false;
    UserInfo user;
    std::string message;
};

struct OnlineUsers {
    std::vector<UserInfo> users;
};

}

========== ./protocol/protocol_text.h ==========
Lines: 28

//protocol_text.h

#pragma once
#include <string>
#include "protocol_types.h"

namespace proto {

// build
std::string makeLoginRequest(const std::string& user, const std::string& pwd);
std::string makeLoginOk(const UserInfo& user, const std::string& msg);
std::string makeLoginFail(const std::string& msg);
std::string makeOnlineUsers(const OnlineUsers& users);
std::string makeLogout();
std::string makeHeartbeat();
std::string makeHeartbeatAck();   // â­ æ–°å¢

// parse
bool parseLoginRequest(const std::string& msg, std::string& user, std::string& pwd);
bool parseLoginResponse(const std::string& msg, LoginResponse& resp);
bool parseOnlineUsers(const std::string& msg, OnlineUsers& users);
bool parseLogout(const std::string& msg);
bool parseHeartbeat(const std::string& msg);
bool parseRegisterPeer(const std::string& msg,std::string& lan,std::string& vpn,int& port);



}

========== ./protocol/protocol_text.cpp ==========
Lines: 169

//protocol_text.cpp
#include "protocol_text.h"
#include "protocol_common.h"

#include <sstream>

namespace proto {

/* ================= build ================= */

// Client ä½¿ç”¨
std::string makeLoginRequest(const std::string& user,
                             const std::string& pwd)
{
    std::ostringstream oss;
    oss << CMD_LOGIN << " " << user << " " << pwd ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginOk(const UserInfo& user,
                        const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_OK << " "
        << user.privilege << " "
        << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeLoginFail(const std::string& msg)
{
    std::ostringstream oss;
    oss << CMD_LOGIN_FAIL << " " << msg ;
    return oss.str();
}

// Server ä½¿ç”¨
std::string makeOnlineUsers(const OnlineUsers& users)
{
    std::ostringstream oss;
    oss << CMD_ONLINE_USERS << " "
        << users.users.size();

    for (const auto& u : users.users) {
        oss << " " << u.username << ":" << u.privilege;
    }
    return oss.str();
}

std::string makeLogout() {
    return CMD_LOGOUT;
}

std::string makeHeartbeat() {
    return CMD_HEARTBEAT;
}

std::string makeHeartbeatAck() {
    return CMD_HEARTBEAT_ACK;  // "PONG"
}


/* ================= parse ================= */

// Server ä½¿ç”¨
bool parseLoginRequest(const std::string& msg,
                       std::string& user,
                       std::string& pwd)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_LOGIN) return false;
    iss >> user >> pwd;
    return !user.empty() && !pwd.empty();
}

// Client ä½¿ç”¨
bool parseLoginResponse(const std::string& msg,
                        LoginResponse& resp)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd == CMD_LOGIN_OK) {
        resp.success = true;
        iss >> resp.user.privilege;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    if (cmd == CMD_LOGIN_FAIL) {
        resp.success = false;
        std::getline(iss, resp.message);
        if (!resp.message.empty() && resp.message[0] == ' ')
            resp.message.erase(0, 1);
        return true;
    }

    return false;
}

// Client ä½¿ç”¨
bool parseOnlineUsers(const std::string& msg,
                      OnlineUsers& users)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_ONLINE_USERS) return false;

    int count = 0;
    iss >> count;

    users.users.clear();

    for (int i = 0; i < count; ++i) {
        std::string token;
        iss >> token;           // user:priv
        auto pos = token.find(':');
        if (pos == std::string::npos) continue;

        UserInfo u;
        u.username = token.substr(0, pos);
        u.privilege = std::stoi(token.substr(pos + 1));
        users.users.push_back(u);
    }
    return true;
}


bool parseLogout(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_LOGOUT;
}

bool parseHeartbeat(const std::string& msg) {
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;
    return cmd == CMD_HEARTBEAT;
}

bool parseRegisterPeer(
    const std::string& msg,
    std::string& lan,
    std::string& vpn,
    int& port)
{
    std::istringstream iss(msg);
    std::string cmd;
    iss >> cmd;

    if (cmd != CMD_REGISTER_PEER) return false;

    iss >> lan >> vpn >> port;
    return !lan.empty() && port > 0;
}

} // namespace proto

========== ./protocol/protocol_common.h ==========
Lines: 29

// proto::*
// âš ï¸ PROTOCOL DTO â€” do NOT use as domain model
// âš ï¸ ä»…ç”¨äºåè®®åºåˆ—åŒ– / ååºåˆ—åŒ–
// âš ï¸ ç¦æ­¢åœ¨ä¸šåŠ¡å±‚ã€äº‹ä»¶å±‚ã€æœåŠ¡å±‚ä¸­ä½œä¸ºä¸šåŠ¡æ¨¡å‹ä½¿ç”¨

//protocol_common.h

#pragma once

namespace proto {

// commands
constexpr const char* CMD_LOGIN        = "LOGIN";
constexpr const char* CMD_LOGIN_OK     = "LOGIN_OK";
constexpr const char* CMD_LOGIN_FAIL   = "LOGIN_FAIL";
constexpr const char* CMD_ONLINE_USERS = "ONLINE_USERS";
constexpr const char* CMD_LOGOUT       = "LOGOUT";
constexpr const char* CMD_HEARTBEAT = "PING";
constexpr const char* CMD_HEARTBEAT_ACK = "PONG";
constexpr const char* CMD_REGISTER_PEER = "REGISTER_PEER";
// keys
constexpr const char* KEY_USERNAME  = "username";
constexpr const char* KEY_PASSWORD  = "password";
constexpr const char* KEY_PRIVILEGE = "privilege";
constexpr const char* KEY_MESSAGE   = "message";
constexpr const char* KEY_USERS     = "users";
constexpr const char* KEY_COUNT     = "count";

}


=====================================
Total files: 25
Total lines: 1207
